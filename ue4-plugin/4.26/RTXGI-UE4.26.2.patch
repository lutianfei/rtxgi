diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/RTXGI.uplugin b/Engine/Plugins/Runtime/Nvidia/RTXGI/RTXGI.uplugin
new file mode 100644
index 00000000000..0116354bcdb
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/RTXGI.uplugin
@@ -0,0 +1,27 @@
+{
+    "FileVersion": 3,
+    "Version": 1,
+    "VersionName": "1.1.31",
+    "FriendlyName": "NVIDIA RTX Global Illumination",
+    "Description": "Real-Time Ray Traced Global Illumination",
+    "Category": "Rendering",
+    "CreatedBy": "NVIDIA",
+    "CreatedByURL": "http://developer.nvidia.com/rtxgi",
+    "DocsURL": "",
+    "MarketplaceURL": "",
+    "SupportURL": "mailto:rtxgi-support-service@nvidia.com",
+    "EnabledByDefault": false,
+    "CanContainContent": true,
+    "IsBetaVersion": false,
+    "Installed": false,
+    "Modules": [
+        {
+            "Name": "RTXGI",
+            "Type": "Runtime",
+            "LoadingPhase": "PostConfigInit",
+            "WhitelistPlatforms": [
+                "Win64"
+            ]
+        }
+    ]
+}
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/ApplyLightingDeferred.usf b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/ApplyLightingDeferred.usf
new file mode 100644
index 00000000000..1cc39e068c5
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/ApplyLightingDeferred.usf
@@ -0,0 +1,226 @@
+/*
+* Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#include "/Engine/Public/Platform.ush"
+#include "/Engine/Private/GammaCorrectionCommon.ush"
+
+struct DDGIVolumeDescGPU
+{
+    float3      origin;
+    float       probeIrradianceEncodingGamma;
+    float4      rotation;
+    float3      probeGridSpacing;
+    float       normalBias;
+    int3        probeGridCounts;
+    int         probeNumIrradianceTexels;
+    int         probeNumDistanceTexels;
+    float       viewBias;
+    int3        probeScrollOffsets;
+};
+
+#include "/Plugin/RTXGI/Private/SDK/ddgi/Irradiance.ush"
+
+// VOLUME_LIST is defined by DDGIVolumeComponent.cpp and is a macro list like: VOLUME_ENTRY(0), VOLUME_ENTRY(1), etc
+
+Texture2D<float4> Normals;
+Texture2D<float>  Depth;
+Texture2D<float4> BaseColor;
+Texture2D<float4> Metallic;
+
+SamplerState LinearClampSampler;
+
+#if USE_LIGHTING_CHANNELS
+Texture2D<uint> LightingChannelsTexture;
+#endif
+
+float4x4 ScreenToTranslatedWorld;
+float3 WorldCameraOrigin;
+float PreExposure;
+float4 InvDeviceZToWorldZTransform;
+uint ShouldUsePreExposure;
+uint NumVolumes;
+
+// generate an array of structures for each probe volume
+#define VOLUME_ENTRY(x) \
+    Texture2D<float4> DDGIVolume_##x##_ProbeIrradiance; \
+    Texture2D<float4> DDGIVolume_##x##_ProbeDistance; \
+    RWTexture2D<float4> DDGIVolume_##x##_ProbeOffsets; \
+    Texture2D<uint> DDGIVolume_##x##_ProbeStates; \
+    float3 DDGIVolume_##x##_Position; \
+    float4 DDGIVolume_##x##_Rotation; \
+    float3 DDGIVolume_##x##_Radius; \
+    float3 DDGIVolume_##x##_ProbeGridSpacing; \
+    int3   DDGIVolume_##x##_ProbeGridCounts; \
+    uint   DDGIVolume_##x##_LightingChannelMask; \
+    int    DDGIVolume_##x##_ProbeNumIrradianceTexels; \
+    int    DDGIVolume_##x##_ProbeNumDistanceTexels; \
+    float  DDGIVolume_##x##_ProbeIrradianceEncodingGamma; \
+    float  DDGIVolume_##x##_NormalBias; \
+    float  DDGIVolume_##x##_ViewBias; \
+    float  DDGIVolume_##x##_BlendDistance; \
+    float  DDGIVolume_##x##_BlendDistanceBlack; \
+    float  DDGIVolume_##x##_ApplyLighting; \
+    int3   DDGIVolume_##x##_ProbeScrollOffsets; \
+    float  DDGIVolume_##x##_IrradianceScalar;
+VOLUME_LIST
+#undef VOLUME_ENTRY
+
+float ConvertFromDeviceZ(float DeviceZ)
+{
+    // Supports ortho and perspective, see CreateInvDeviceZToWorldZTransform()
+    return DeviceZ * InvDeviceZToWorldZTransform[0] + InvDeviceZToWorldZTransform[1] + 1.0f / (DeviceZ * InvDeviceZToWorldZTransform[2] - InvDeviceZToWorldZTransform[3]);
+}
+
+void MainVS(
+    in uint VertexId : SV_VertexID,
+    out float4 OutPosition : SV_POSITION,
+    out float3 OutScreenVector : TEXCOORD0)
+{
+    float2 uv = float2((VertexId << 1) & 2, VertexId & 2);
+    OutPosition = float4(uv * float2(2.0f, -2.0f) + float2(-1.0f, 1.0f), 0.0f, 1.0f);
+    OutScreenVector = mul(float4(OutPosition.xy, 1, 0), ScreenToTranslatedWorld).xyz;
+}
+
+bool ApplyVolumeLightingContribution(out float4 lightWeight, in Texture2D<float4> ProbeIrradiance, in Texture2D<float4> ProbeDistance, in RWTexture2D<float4> ProbeOffsets, in Texture2D<uint> ProbeStates, in float3 WorldPosition, in float3 Normal, in float3 CameraDirection,
+uint pixelLightingMask, in uint volumeLightingChannelMask, in float3 volumeRadius, in DDGIVolumeDescGPU DDGIVolume, in float3 albedo, in float BlendDistance, in float BlendDistanceBlack, in float ApplyLighting, in float IrradianceScalar)
+{
+    lightWeight = float4(0.0f, 0.0f, 0.0f, 0.0f);
+
+    // ignore the volume if the lighting mask doesn't overlap
+    #if USE_LIGHTING_CHANNELS
+    if ((pixelLightingMask & volumeLightingChannelMask) == 0)
+        return false;
+    #endif
+
+    // ignore the volume if the pixel is outside of the volume
+    float3 relPos = WorldPosition - DDGIVolume.origin;
+    relPos = abs(RTXGIQuaternionRotate(relPos, RTXGIQuaternionConjugate(DDGIVolume.rotation)));
+    if((relPos.x > volumeRadius.x || relPos.y > volumeRadius.y || relPos.z > volumeRadius.z))
+        return false;
+
+    // fill out a DDGIVolumeResources
+    DDGIVolumeResources resources;
+    {
+        resources.probeIrradianceSRV = ProbeIrradiance;
+        resources.probeDistanceSRV = ProbeDistance;
+        resources.bilinearSampler = LinearClampSampler;
+#if RTXGI_DDGI_PROBE_RELOCATION
+        resources.probeOffsets = ProbeOffsets;
+#endif
+#if RTXGI_DDGI_PROBE_STATE_CLASSIFIER
+        resources.probeStates = ProbeStates;
+#endif
+    }
+
+    // Get irradiance from the DDGIVolume
+    if (ApplyLighting > 0.0f)
+    {
+        float3 surfaceBias = DDGIGetSurfaceBias(Normal, CameraDirection, DDGIVolume);
+        float3 irradiance = DDGIGetVolumeIrradiance(
+            WorldPosition,
+            surfaceBias,
+            Normal,
+            DDGIVolume,
+            resources
+        );
+
+        lightWeight.rgb = irradiance * (albedo / RTXGI_PI) / IrradianceScalar;
+    }
+    else
+    {
+        lightWeight.rgb = float3(0.0f, 0.0f, 0.0f);
+    }
+
+    float3 edgeDist = (volumeRadius - abs(relPos));
+    float edgeMinDist = min(edgeDist.x, min(edgeDist.y, edgeDist.z));
+    if (BlendDistance == 0.0f)
+        lightWeight.a = (edgeMinDist < BlendDistanceBlack) ? 0.0f : 1.0f;
+    else
+        lightWeight.a = clamp((edgeMinDist - BlendDistanceBlack) / BlendDistance, 0.0f, 1.0f);
+    return true;
+}
+
+void MainPS(
+    float4 SvPosition : SV_POSITION,
+    float3 InScreenVector : TEXCOORD0,
+    out float4 OutColor : SV_Target0
+    )
+{
+    int2 PixelPos = int2(SvPosition.xy);
+
+    // get information about our pixel
+    float DeviceZ = Depth.Load(int3(PixelPos, 0));
+    float SceneDepth = ConvertFromDeviceZ(DeviceZ);
+    float3 WorldPosition = InScreenVector * SceneDepth + WorldCameraOrigin;
+    float3 Normal = normalize(Normals.Load(int3(PixelPos, 0)).xyz * 2.0f - 1.0f);
+    float3 baseColor = BaseColor.Load(int3(PixelPos, 0)).rgb;
+    float metallic = Metallic.Load(int3(PixelPos, 0)).r;
+    float3 CameraDirection = normalize(InScreenVector);
+
+    float3 albedo = baseColor - baseColor * metallic;
+
+    #if USE_LIGHTING_CHANNELS
+    uint pixelLightingMask = uint(LightingChannelsTexture.Load(int3(PixelPos, 0)).x);
+    #else
+    uint pixelLightingMask = 0;
+    #endif
+
+    // Make DDGIVolumeDescGPU's. Rely on inlining and deadstripping to make this a noop.
+    #define VOLUME_ENTRY(x) \
+        DDGIVolumeDescGPU DDGIVolume_##x; \
+        DDGIVolume_##x.origin = DDGIVolume_##x##_Position; \
+        DDGIVolume_##x.rotation = DDGIVolume_##x##_Rotation; \
+        DDGIVolume_##x.probeGridSpacing = DDGIVolume_##x##_ProbeGridSpacing; \
+        DDGIVolume_##x.probeGridCounts = DDGIVolume_##x##_ProbeGridCounts; \
+        DDGIVolume_##x.probeNumIrradianceTexels = DDGIVolume_##x##_ProbeNumIrradianceTexels; \
+        DDGIVolume_##x.probeNumDistanceTexels = DDGIVolume_##x##_ProbeNumDistanceTexels; \
+        DDGIVolume_##x.probeIrradianceEncodingGamma = DDGIVolume_##x##_ProbeIrradianceEncodingGamma; \
+        DDGIVolume_##x.normalBias = DDGIVolume_##x##_NormalBias; \
+        DDGIVolume_##x.viewBias = DDGIVolume_##x##_ViewBias; \
+        DDGIVolume_##x.probeScrollOffsets = DDGIVolume_##x##_ProbeScrollOffsets;
+    VOLUME_LIST
+    #undef VOLUME_ENTRY
+
+    // NOTE: if wanting to visualize / debug the blend, it's useful to hard code some colors temporarily.
+    // like have volume zero be red, and volume one be yellow
+
+    // Gather up to 2 lighting contributions
+    float4 primaryLightWeight = float4(0.0f, 0.0f, 0.0f, 0.0f);
+    float4 secondaryLightWeight = float4(0.0f, 0.0f, 0.0f, 0.0f);
+    float4 lightWeight = float4(0.0f, 0.0f, 0.0f, 0.0f);
+    #define VOLUME_ENTRY(x) \
+    if (x < NumVolumes && primaryLightWeight.a < 1.0f && secondaryLightWeight.a == 0.0f && ApplyVolumeLightingContribution(lightWeight, DDGIVolume_##x##_ProbeIrradiance, DDGIVolume_##x##_ProbeDistance, DDGIVolume_##x##_ProbeOffsets, DDGIVolume_##x##_ProbeStates, WorldPosition, Normal, CameraDirection, pixelLightingMask, \
+        uint(DDGIVolume_##x##_LightingChannelMask), DDGIVolume_##x##_Radius, DDGIVolume_##x, albedo, DDGIVolume_##x##_BlendDistance, DDGIVolume_##x##_BlendDistanceBlack, DDGIVolume_##x##_ApplyLighting, DDGIVolume_##x##_IrradianceScalar)) \
+        { \
+            if (primaryLightWeight.a == 0.0f) \
+                primaryLightWeight = lightWeight; \
+            else \
+                secondaryLightWeight = lightWeight; \
+        }
+    VOLUME_LIST
+    #undef VOLUME_ENTRY
+
+    float preExposure = ShouldUsePreExposure ? PreExposure : 1.0f;
+
+    // Explanation of the statements below
+    // 1) If the pixel is not inside of any volume, return black.
+    // 2) If the pixel is inside of 1 volume, we want to fade it out by multiplying the primaryLightWeight color by the weight.
+    // 3) If we are in the non fade region of the primary volume, just use that color.
+    // 4) if we are in the fade region of both volumes, do something that preserves luminance of fade, since the color is going to be real similar anyways (this is the case for the max usage)
+    if (primaryLightWeight.a == 0.0f || secondaryLightWeight.a == 0.0f || primaryLightWeight.a == 1.0f || secondaryLightWeight.a < 1.0f)
+    {
+        OutColor = float4(primaryLightWeight.rgb * max(primaryLightWeight.a, secondaryLightWeight.a) * preExposure, 1.0f);
+    }
+    // else we are in the fade region of the primary volume, but not the fade region of the secondary volume, so blend between primary and secondary
+    else
+    {
+        OutColor = float4(lerp(secondaryLightWeight.rgb, primaryLightWeight.rgb, primaryLightWeight.a) * preExposure, 1.0f);
+    }
+}
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/ProbeUpdateRGS.usf b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/ProbeUpdateRGS.usf
new file mode 100644
index 00000000000..0efd944cd7e
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/ProbeUpdateRGS.usf
@@ -0,0 +1,315 @@
+/*
+* Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#include "/Engine/Private/HairStrands/HairStrandsVoxelPageCommonStruct.ush"
+#include "/Engine/Private/Common.ush"
+
+struct DDGIVolumeDescGPU
+{
+    float3 origin;
+    int numRaysPerProbe;
+    float4 rotation;
+    float3 probeGridSpacing;
+    float probeMaxRayDistance;
+    int3 probeGridCounts;
+    float4x4 probeRayRotationTransform;
+    float normalBias;
+    float viewBias;
+    float probeNumIrradianceTexels;
+    float probeNumDistanceTexels;
+    float probeIrradianceEncodingGamma;
+    int3 probeScrollOffsets;
+};
+
+// RTXGI SDK
+#include "/Plugin/RTXGI/Private/SDK/ddgi/Irradiance.ush"
+
+// needed by DeferredLightingCommon included indirectly
+#define SUPPORT_CONTACT_SHADOWS 0
+
+// from RayTracingPrimaryRays.usf - see that .cpp for how to pass all these params properly
+#define LTCMatTexture               RaytracingLightsDataPacked.LTCMatTexture
+#define LTCMatSampler               RaytracingLightsDataPacked.LTCMatSampler
+#define LTCAmpTexture               RaytracingLightsDataPacked.LTCAmpTexture
+#define LTCAmpSampler               RaytracingLightsDataPacked.LTCAmpSampler
+#define PreIntegratedGF             ReflectionStruct.PreIntegratedGF
+#define PreIntegratedGFSampler      ReflectionStruct.PreIntegratedGFSampler
+
+#include "/Engine/Private/DeferredLightingCommon.ush"
+#include "/Engine/Private/DeferredShadingCommon.ush"
+#include "/Engine/Private/PathTracing/Utilities/PathTracingRandomSequence.ush"
+#include "/Engine/Private/SceneTextureParameters.ush"
+#include "/Engine/Private/RayTracing/RayTracingCommon.ush"
+#include "/Engine/Private/RayTracing/RayTracingDeferredShadingCommon.ush"
+#include "/Engine/Private/RayTracing/RayTracingHitGroupCommon.ush"
+#include "/Engine/Private/RayTracing/RayTracingDirectionalLight.ush"
+#include "/Engine/Private/RayTracing/RayTracingRectLight.ush"
+#include "/Engine/Private/RayTracing/RayTracingSphereLight.ush"
+#include "/Engine/Private/RayTracing/RayTracingSpotLight.ush"
+#include "/Engine/Private/RayTracing/RayTracingPointLight.ush"
+#include "/Engine/Private/RayTracing/RayTracingLightingCommon.ush"
+#include "/Engine/Private/ReflectionEnvironmentShared.ush"
+#include "/Engine/Private/Montecarlo.ush"
+#include "/Engine/Private/HeightFogCommon.ush"
+#include "/Engine/Private/SobolRandom.ush"
+
+// START RGS PARAMS
+RaytracingAccelerationStructure TLAS;
+
+RWTexture2D<float4> RadianceOutput;
+RWTexture2D<float4> DebugOutput;
+
+uint   FrameRandomSeed;
+
+Texture2D<float4>   DDGIVolume_ProbeIrradiance;
+Texture2D<float4>   DDGIVolume_ProbeDistance;
+RWTexture2D<float4> DDGIVolume_ProbeOffsets;
+Texture2D<uint>     DDGIVolume_ProbeStates;
+float3              DDGIVolume_Origin;
+float4              DDGIVolume_Rotation;
+float3              DDGIVolume_ProbeGridSpacing;
+float               DDGIVolume_ProbeMaxRayDistance;
+int3                DDGIVolume_ProbeGridCounts;
+float4x4            DDGIVolume_ProbeRayRotationTransform;
+int                 DDGIVolume_NumRaysPerProbe;
+float3              DDGIVolume_Radius;
+int                 DDGIVolume_ProbeNumIrradianceTexels;
+int                 DDGIVolume_ProbeNumDistanceTexels;
+float               DDGIVolume_ProbeIrradianceEncodingGamma;
+float               DDGIVolume_NormalBias;
+float               DDGIVolume_ViewBias;
+SamplerState        DDGIVolume_LinearClampSampler;
+int3                DDGIVolume_ProbeScrollOffsets;
+float               DDGIVolume_IrradianceScalar;
+int                 DDGIVolume_ProbeIndexStart;
+int                 DDGIVolume_ProbeIndexCount;
+float               DDGIVolume_EmissiveMultiplier;
+
+float3              Sky_Color;
+TextureCube<float4> Sky_Texture;
+SamplerState        Sky_TextureSampler;
+
+// END RGS PARAMS
+
+float3 GetEnvironmentalRadiance(in float3 direction)
+{
+    return Sky_Color * TextureCubeSampleLevel(Sky_Texture, Sky_TextureSampler, direction, 0).rgb;
+}
+
+void WriteRadianceOutput(uint2 DispatchIndex, float4 value)
+{
+#if !RTXGI_DDGI_DEBUG_FORMAT_RADIANCE
+    static const float c_threshold = 1.f / 255.f;
+    if (RTXGIMaxComponent(value.rgb) <= c_threshold) value.rgb = float3(0.f, 0.f, 0.f);
+#endif
+
+    // Radiance / irradiance is multipled by this when stored, but divided by this when recalled.
+    // This feature is to avoid clipping when using the 10 bit texture format.
+    value.rgb *= DDGIVolume_IrradianceScalar;
+
+#if RTXGI_DDGI_DEBUG_FORMAT_RADIANCE
+    // Use R32G32B32A32_FLOAT format. Store color components and hit distance as 32-bit float values.
+    RadianceOutput[DispatchIndex.xy] = value;
+#else
+    // Use R32G32_FLOAT format (don't use R32G32_UINT since hit distance needs to be negative sometimes).
+    // Pack color as R10G10B10 in R32 and store hit distance in G32.
+    RadianceOutput[DispatchIndex.xy] = float4(asfloat(RTXGIFloat3ToUint(clamp(value.rgb, 0.0f, 1.0f))), value.w, 0.f, 0.f);
+#endif
+
+#if DDGIVolumeUpdateDebug != 0
+    DebugOutput[DispatchIndex.xy] = value;
+#endif
+}
+
+RAY_TRACING_ENTRY_RAYGEN(ProbeUpdateRGS)
+{
+    DDGIVolumeDescGPU DDGIVolume;
+    DDGIVolume.origin = DDGIVolume_Origin;
+    DDGIVolume.numRaysPerProbe = DDGIVolume_NumRaysPerProbe;
+    DDGIVolume.rotation = DDGIVolume_Rotation;
+    DDGIVolume.probeGridSpacing = DDGIVolume_ProbeGridSpacing;
+    DDGIVolume.probeMaxRayDistance = DDGIVolume_ProbeMaxRayDistance;
+    DDGIVolume.probeGridCounts = DDGIVolume_ProbeGridCounts;
+    DDGIVolume.probeRayRotationTransform = DDGIVolume_ProbeRayRotationTransform;
+    DDGIVolume.normalBias = DDGIVolume_NormalBias;
+    DDGIVolume.viewBias = DDGIVolume_ViewBias;
+    DDGIVolume.probeNumIrradianceTexels = DDGIVolume_ProbeNumIrradianceTexels;
+    DDGIVolume.probeNumDistanceTexels = DDGIVolume_ProbeNumDistanceTexels;
+    DDGIVolume.probeIrradianceEncodingGamma = DDGIVolume_ProbeIrradianceEncodingGamma;
+    DDGIVolume.probeScrollOffsets = DDGIVolume_ProbeScrollOffsets;
+
+    // Adapted from ProbeTraceRGS.hlsl in the test harness aiming for minimal changes to help future merges.
+
+    float4 result = 0.f;
+
+    uint2 DispatchIndex = DispatchRaysIndex().xy;
+    int rayIndex = DispatchIndex.x;                    // index of ray within a probe
+    int probeIndex = DispatchIndex.y;                  // index of current probe
+
+    // Handle round robin updating.
+    // If this probe is outside of the window for updating, bail out.
+    {
+        int numProbes = DDGIVolume_ProbeGridCounts.x * DDGIVolume_ProbeGridCounts.y * DDGIVolume_ProbeGridCounts.z;
+        int probeRRIndex = (probeIndex < DDGIVolume_ProbeIndexStart) ? probeIndex + numProbes : probeIndex;
+        if (probeRRIndex >= DDGIVolume_ProbeIndexStart + DDGIVolume_ProbeIndexCount)
+            return;
+    }
+
+#if RTXGI_DDGI_PROBE_STATE_CLASSIFIER
+#if RTXGI_DDGI_PROBE_SCROLL
+    int storageProbeIndex = DDGIGetProbeIndexOffset(probeIndex, DDGIVolume.probeGridCounts, DDGIVolume.probeScrollOffsets);
+#else
+    int storageProbeIndex = probeIndex;
+#endif
+    int2 texelPosition = DDGIGetProbeTexelPosition(storageProbeIndex, DDGIVolume.probeGridCounts);
+    int  probeState = DDGIVolume_ProbeStates.Load(int3(texelPosition, 0));
+    if (probeState == PROBE_STATE_INACTIVE && rayIndex >= RTXGI_DDGI_NUM_FIXED_RAYS)
+    {
+       // if the probe is inactive, do not shoot rays, unless it is one of the fixed rays that could potentially reactivate the probe
+       return;
+    }
+#endif
+
+#if RTXGI_DDGI_PROBE_RELOCATION
+    #if RTXGI_DDGI_PROBE_SCROLL
+    float3 probeWorldPosition = DDGIGetProbeWorldPositionWithOffset(probeIndex, DDGIVolume.origin, DDGIVolume.rotation, DDGIVolume.probeGridCounts, DDGIVolume.probeGridSpacing, DDGIVolume.probeScrollOffsets, DDGIVolume_ProbeOffsets);
+    #else
+    float3 probeWorldPosition = DDGIGetProbeWorldPositionWithOffset(probeIndex, DDGIVolume.origin, DDGIVolume.rotation, DDGIVolume.probeGridCounts, DDGIVolume.probeGridSpacing, DDGIVolume_ProbeOffsets);
+    #endif
+#else
+    float3 probeWorldPosition = DDGIGetProbeWorldPosition(probeIndex, DDGIVolume.origin, DDGIVolume.rotation, DDGIVolume.probeGridCounts, DDGIVolume.probeGridSpacing);
+#endif
+
+    float3 probeRayDirection = DDGIGetProbeRayDirection(rayIndex, DDGIVolume.numRaysPerProbe, DDGIVolume.probeRayRotationTransform);
+
+    // Setup the probe ray
+    RayDesc Ray;
+    Ray.Origin = probeWorldPosition;
+    Ray.Direction = probeRayDirection;
+    Ray.TMin = 0.f;
+    Ray.TMax = DDGIVolume.probeMaxRayDistance;
+
+    const int ReflectedShadowsType = 1; // = hard shadows.  make configurable?
+    const uint RefractionRayFlags = 0;
+    const uint RefractionInstanceInclusionMask = RAY_TRACING_MASK_ALL;
+
+    #if DDGI_SKYLIGHT
+    const bool bRefractionEnableSkyLightContribution = true;
+    #else
+    const bool bRefractionEnableSkyLightContribution = false;
+    #endif
+
+    const bool bRefractionRayTraceSkyLightContribution = false;
+    const bool bRefractionDecoupleSampleGeneration = true;
+    const bool ShouldDoDirectLighting = true;
+    const bool ShouldDoEmissiveAndIndirectLighting = true;
+    float3 PathVertexRadiance = float3(0, 0, 0);
+    FRayCone RayCone = (FRayCone)0;
+    float MaxNormalBias = 0.01f;
+
+    // Trace
+    uint linear_rand = DispatchIndex.x + DispatchIndex.y * 9973;
+    RandomSequence RandSequence;
+    RandomSequence_Initialize(RandSequence, linear_rand, FrameRandomSeed);
+    uint2 PixelCoord = DispatchRaysIndex().xy; // Hmmmm.... does TraceRayAndAccumulateResults() assume screen-space trace or is this just for stochastics?  hopefully the latter but fixme:checkme
+
+    FMaterialClosestHitPayload Payload = TraceRayAndAccumulateResults(
+        Ray,
+        TLAS,
+        RefractionRayFlags,
+        RefractionInstanceInclusionMask,
+        RandSequence,
+        PixelCoord,
+        MaxNormalBias,
+        ReflectedShadowsType,
+        ShouldDoDirectLighting,
+        ShouldDoEmissiveAndIndirectLighting,
+        bRefractionRayTraceSkyLightContribution,
+        bRefractionDecoupleSampleGeneration,
+        RayCone,
+        bRefractionEnableSkyLightContribution,
+        PathVertexRadiance);
+
+    // Adjust emissive contribution if we should
+    PathVertexRadiance += Payload.Radiance * (DDGIVolume_EmissiveMultiplier - 1.0f);
+
+    result = float4(PathVertexRadiance.xyz, Payload.HitT);
+
+    // Ray miss. Set hit distance to a large value and exit early.
+    if (Payload.IsMiss())
+    {
+        result.rgb += GetEnvironmentalRadiance(Ray.Direction);
+        result.w = 1e27f;
+        WriteRadianceOutput(DispatchIndex.xy, result);
+        return;
+    }
+
+    // Hit a surface backface. Set the radiance to black and exit early.
+    if (!Payload.IsFrontFace() && Payload.ShadingModelID != SHADINGMODELID_TWOSIDED_FOLIAGE)
+    {
+        // Shorten the hit distance on a backface hit by 80%
+        // Make distance negative to encode backface for the probe position preprocess.
+        WriteRadianceOutput(DispatchIndex.xy, float4(0.0f, 0.0f, 0.0f, -Payload.HitT * 0.2f));
+        return;
+    }
+
+#if RTXGI_DDGI_PROBE_STATE_CLASSIFIER
+    // hit a frontface, but probe is inactive, so this ray will only be used for reclassification, don't need any lighting
+    if (probeState == PROBE_STATE_INACTIVE)
+    {
+        WriteRadianceOutput(DispatchIndex.xy, float4(0.0f, 0.0f, 0.0f, Payload.HitT));
+        return;
+    }
+#endif
+
+    float3 probeLighting = float3(0.0f, 0.0f, 0.0f);
+    {
+        float3 albedo = Payload.BaseColor - Payload.BaseColor * Payload.Metallic;
+
+        // fill out a DDGIVolumeResources
+        DDGIVolumeResources resources;
+        {
+            resources.probeIrradianceSRV = DDGIVolume_ProbeIrradiance;
+            resources.probeDistanceSRV = DDGIVolume_ProbeDistance;
+            resources.bilinearSampler = DDGIVolume_LinearClampSampler;
+#if RTXGI_DDGI_PROBE_RELOCATION
+            resources.probeOffsets = DDGIVolume_ProbeOffsets;
+#endif
+#if RTXGI_DDGI_PROBE_STATE_CLASSIFIER
+            resources.probeStates = DDGIVolume_ProbeStates;
+#endif
+        }
+
+        // Get irradiance from the DDGIVolume
+        float3 surfacePosWS = Ray.Origin + Ray.Direction * Payload.HitT;
+        float3 surfaceBias = DDGIGetSurfaceBias(Payload.WorldNormal, Ray.Direction, DDGIVolume);
+        float3 irradiance = DDGIGetVolumeIrradiance(
+            surfacePosWS,
+            surfaceBias,
+            Payload.WorldNormal,
+            DDGIVolume,
+            resources
+        );
+
+        // Perfectly diffuse reflectors don't exist in the real world. Limit the BRDF
+        // albedo to a maximum value to account for the energy loss at each bounce.
+        float maxAlbedo = 0.9f;
+
+        probeLighting = irradiance * (min(albedo, maxAlbedo) / RTXGI_PI);
+        probeLighting /= DDGIVolume_IrradianceScalar;
+
+        // don't apply volume lighting outside the volume
+        float3 relPos = abs(surfacePosWS - DDGIVolume_Origin);
+        if((relPos.x > DDGIVolume_Radius.x || relPos.y > DDGIVolume_Radius.y || relPos.z > DDGIVolume_Radius.z))
+            probeLighting = float3(0.0f, 0.0f, 0.0f);
+    }
+
+    WriteRadianceOutput(DispatchIndex.xy, float4(PathVertexRadiance.xyz + probeLighting, Payload.HitT));
+}
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/ProbeViewRGS.usf b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/ProbeViewRGS.usf
new file mode 100644
index 00000000000..95a0cf4c1a8
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/ProbeViewRGS.usf
@@ -0,0 +1,177 @@
+/*
+* Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+/*
+This shader shoots a viewport of rays so you can see what the volume sees, copying the logic of ProbeUpdateRGS.usf.
+
+r.RTXGI.DDGIProbeVis 0 - turn it off
+r.RTXGI.DDGIProbeVis 1 - render the scene color.  (VOLUME_DEBUG_VIEW == 0)
+r.RTXGI.DDGIProbeVis 2 - render misses (blue), hits (green), back face hits (red).  (VOLUME_DEBUG_VIEW == 1)
+
+then "vis DDGIProbeVis" to see the texture
+*/
+
+#include "/Engine/Private/HairStrands/HairStrandsVoxelPageCommonStruct.ush"
+#include "/Engine/Private/Common.ush"
+
+// needed by DeferredLightingCommon included indirectly
+#define SUPPORT_CONTACT_SHADOWS 0
+
+//macro to deal with parameter not used by miss shaders
+#define OcclusionCullDirection 0
+
+// from RayTracingPrimaryRays.usf - see that .cpp for how to pass all these params properly
+#define LTCMatTexture               RaytracingLightsDataPacked.LTCMatTexture
+#define LTCMatSampler               RaytracingLightsDataPacked.LTCMatSampler
+#define LTCAmpTexture               RaytracingLightsDataPacked.LTCAmpTexture
+#define LTCAmpSampler               RaytracingLightsDataPacked.LTCAmpSampler
+#define PreIntegratedGF             ReflectionStruct.PreIntegratedGF
+#define PreIntegratedGFSampler      ReflectionStruct.PreIntegratedGFSampler
+
+#include "/Engine/Private/DeferredLightingCommon.ush"
+#include "/Engine/Private/DeferredShadingCommon.ush"
+#include "/Engine/Private/PathTracing/Utilities/PathTracingRandomSequence.ush"
+#include "/Engine/Private/SceneTextureParameters.ush"
+#include "/Engine/Private/RayTracing/RayTracingCommon.ush"
+#include "/Engine/Private/RayTracing/RayTracingDeferredShadingCommon.ush"
+#include "/Engine/Private/RayTracing/RayTracingHitGroupCommon.ush"
+#include "/Engine/Private/RayTracing/RayTracingDirectionalLight.ush"
+#include "/Engine/Private/RayTracing/RayTracingRectLight.ush"
+#include "/Engine/Private/RayTracing/RayTracingSphereLight.ush"
+#include "/Engine/Private/RayTracing/RayTracingSpotLight.ush"
+#include "/Engine/Private/RayTracing/RayTracingPointLight.ush"
+#include "/Engine/Private/RayTracing/RayTracingLightingCommon.ush"
+#include "/Engine/Private/ReflectionEnvironmentShared.ush"
+#include "/Engine/Private/Montecarlo.ush"
+#include "/Engine/Private/HeightFogCommon.ush"
+#include "/Engine/Private/SobolRandom.ush"
+
+// START RGS PARAMS
+RaytracingAccelerationStructure TLAS;
+
+uint        FrameRandomSeed;
+
+float3      CameraPos;
+float4x4    CameraMatrix;
+
+float       DDGIVolume_PreExposure;
+uint        DDGIVolume_ShouldUsePreExposure;
+
+float3              Sky_Color;
+TextureCube<float4> Sky_Texture;
+SamplerState        Sky_TextureSampler;
+
+RWTexture2D<float4> RadianceOutput;
+
+// END RGS PARAMS
+
+float3 GetEnvironmentalRadiance(in float3 direction)
+{
+    return Sky_Color * TextureCubeSampleLevel(Sky_Texture, Sky_TextureSampler, direction, 0).rgb;
+}
+
+// This should match the logic of ProbeUpdateRGS above, for best results.
+// It isn't sampling DDGI volumes though so is only direct lighting.
+RAY_TRACING_ENTRY_RAYGEN(ProbeViewRGS)
+{
+    uint2 DispatchIndex = DispatchRaysIndex().xy;
+
+    // This is to make the radiance be in a viewable range
+    float radianceMultiplier = DDGIVolume_ShouldUsePreExposure ? DDGIVolume_PreExposure : 1.0f;
+
+    RayDesc Ray;
+    Ray.Origin = CameraPos;
+    float3 rayTarget = float3(float2(DispatchIndex.xy) / float2(DispatchRaysDimensions().xy) * 2.0f - 1.0f, 1.0f);
+    rayTarget.y *= -1.0f;
+    float3 rayDir = mul(float4(normalize(rayTarget), 0.0f), CameraMatrix).xyz;
+    Ray.Direction = rayDir;
+    Ray.TMin = 0.f;
+    Ray.TMax = 10000.0f;
+
+    const int ReflectedShadowsType = 1; // = hard shadows.  make configurable?
+    const uint RefractionRayFlags = 0;
+    const uint RefractionInstanceInclusionMask = RAY_TRACING_MASK_ALL;
+    const bool bRefractionRayTraceSkyLightContribution = false;
+    const bool bRefractionDecoupleSampleGeneration = true;
+    const bool bRefractionEnableSkyLightContribution = true;
+    const bool ShouldDoDirectLighting = true;
+    const bool ShouldDoEmissiveAndIndirectLighting = true;
+    float3 PathVertexRadiance = float3(0, 0, 0);
+    FRayCone RayCone = (FRayCone)0;
+    float MaxNormalBias = 0.01f;
+
+    // Trace
+    uint linear_rand = DispatchIndex.x + DispatchIndex.y * 9973;
+    RandomSequence RandSequence;
+    RandomSequence_Initialize(RandSequence, linear_rand, FrameRandomSeed);
+    uint2 PixelCoord = DispatchRaysIndex().xy;
+
+    FMaterialClosestHitPayload Payload;
+    //Payload.SetEnableSkyLightContribution();
+
+    Payload = TraceRayAndAccumulateResults(
+        Ray,
+        TLAS,
+        RefractionRayFlags,
+        RefractionInstanceInclusionMask,
+        RandSequence,
+        PixelCoord,
+        MaxNormalBias,
+        ReflectedShadowsType,
+        ShouldDoDirectLighting,
+        ShouldDoEmissiveAndIndirectLighting,
+        bRefractionRayTraceSkyLightContribution,
+        bRefractionDecoupleSampleGeneration,
+        RayCone,
+        bRefractionEnableSkyLightContribution,
+        PathVertexRadiance);
+
+    float4 result = float4(PathVertexRadiance.xyz, Payload.HitT);
+
+    // show ray miss / hit / back face hit
+    #if VOLUME_DEBUG_VIEW == 1
+    {
+        if (Payload.IsMiss())
+        {
+            RadianceOutput[DispatchIndex.xy] = float4(0.0f, 0.0f, 100.0f, 1e27f);
+        }
+        else
+        {
+            if (Payload.IsFrontFace() || Payload.ShadingModelID == SHADINGMODELID_TWOSIDED_FOLIAGE)
+                RadianceOutput[DispatchIndex.xy] = float4(0.0f, 100.0f, 0.0f, Payload.HitT);
+            else
+                RadianceOutput[DispatchIndex.xy] = float4(100.0f, 0.0f, 0.0f, Payload.HitT);
+        }
+        return;
+    }
+    #endif
+
+    // Ray miss. Set hit distance to a large value and exit early.
+    if (Payload.IsMiss())
+    {
+        result.rgb += GetEnvironmentalRadiance(Ray.Direction);
+        result.rgb *= radianceMultiplier;
+
+        result.w = 1e27f;
+        RadianceOutput[DispatchIndex.xy] = result;
+        return;
+    }
+
+    // Hit a surface backface. Set the radiance to black and exit early.
+    if (!Payload.IsFrontFace() && Payload.ShadingModelID != SHADINGMODELID_TWOSIDED_FOLIAGE)
+    {
+        // Shorten the hit distance on a backface hit by 20%
+        // Make distance negative to encode backface for the probe position preprocess.
+        RadianceOutput[DispatchIndex.xy] = float4(0.f, 0.f, 0.f, -Payload.HitT * 0.2f);
+        return;
+    }
+
+    RadianceOutput[DispatchIndex.xy] = float4(PathVertexRadiance.xyz * radianceMultiplier, Payload.HitT);
+}
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/Common.ush b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/Common.ush
new file mode 100644
index 00000000000..4ebc9339243
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/Common.ush
@@ -0,0 +1,97 @@
+/*
+* Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#ifndef RTXGI_COMMON_HLSL
+#define RTXGI_COMMON_HLSL
+
+static const float RTXGI_PI = 3.1415926535897932f;
+static const float RTXGI_2PI = 6.2831853071795864f;
+
+//------------------------------------------------------------------------
+// Math Helpers
+//------------------------------------------------------------------------
+
+/**
+* Finds the largest component of the vector.
+*/
+float RTXGIMaxComponent(float3 a)
+{
+    return max(a.x, max(a.y, a.z));
+}
+
+/**
+* Returns either -1 or 1 based on the sign of the input value.
+* If the input is zero, 1 is returned.
+*/
+float RTXGISignNotZero(float v)
+{
+    return (v >= 0.f) ? 1.f : -1.f;
+}
+
+/**
+* 2-component version of RTXGISignNotZero.
+*/
+float2 RTXGISignNotZero(float2 v)
+{
+    return float2(RTXGISignNotZero(v.x), RTXGISignNotZero(v.y));
+}
+
+/**
+* Return the given float value as an unsigned integer within the given numerical scale.
+*/
+uint RTXGIFloatToUint(float v, float scale)
+{
+    return (uint)floor(v * scale + 0.5f);
+}
+
+/**
+* Pack a float3 into a 32-bit unsigned integer.
+* All channels use 10 bits and 2 bits are unused.
+* Compliment of RTXGIUintToFloat3().
+*/
+uint RTXGIFloat3ToUint(float3 input)
+{
+    return (RTXGIFloatToUint(input.r, 1023.f)) | (RTXGIFloatToUint(input.g, 1023.f) << 10) | (RTXGIFloatToUint(input.b, 1023.f) << 20);
+}
+
+/**
+* Unpack a packed 32-bit unsigned integer to a float3.
+* Compliment of RTXGIFloat3ToUint().
+*/
+float3 RTXGIUintToFloat3(uint input)
+{
+    float3 unpacked;
+    unpacked.x = (float)(input & 0x000003FF) / 1023.f;
+    unpacked.y = (float)((input >> 10) & 0x000003FF) / 1023.f;
+    unpacked.z = (float)((input >> 20) & 0x000003FF) / 1023.f;
+    return unpacked;
+}
+
+/**
+* Rotate vector v with quaternion q.
+*/
+float3 RTXGIQuaternionRotate(float3 v, float4 q)
+{
+    float3 b = q.xyz;
+    float b2 = dot(b, b);
+    return (v * (q.w * q.w - b2) + b * (dot(v, b) * 2.f) + cross(b, v) * (q.w * 2.f));
+}
+
+/**
+* Quaternion conjugate.
+* For unit quaternions, conjugate equals inverse.
+* Use this to create a quaternion that rotates in the opposite direction.
+*/
+float4 RTXGIQuaternionConjugate(float4 q)
+{
+    return float4(-q.xyz, q.w);
+}
+
+#endif /* RTXGI_COMMON_HLSL */
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/DDGIVolumeDefines.ush b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/DDGIVolumeDefines.ush
new file mode 100644
index 00000000000..da4d07575d1
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/DDGIVolumeDefines.ush
@@ -0,0 +1,96 @@
+/*
+* Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#ifndef RTXGI_DDGI_VOLUME_DEFINES_H
+#define RTXGI_DDGI_VOLUME_DEFINES_H
+
+// --- Resources -------------------------------------
+
+#ifndef RTXGI_DDGI_SDK_MANAGED_RESOURCES
+#define RTXGI_DDGI_SDK_MANAGED_RESOURCES 0
+#endif
+
+// low bit depth irradiance will set this to 0 for shaders, high bit depth will set it to 1.
+/*
+#ifndef RTXGI_DDGI_DEBUG_FORMAT_RADIANCE
+#define RTXGI_DDGI_DEBUG_FORMAT_RADIANCE 0
+#endif
+
+#ifndef RTXGI_DDGI_DEBUG_FORMAT_IRRADIANCE
+#define RTXGI_DDGI_DEBUG_FORMAT_IRRADIANCE 0
+#endif
+
+#ifndef RTXGI_DDGI_DEBUG_FORMAT_DISTANCE
+#define RTXGI_DDGI_DEBUG_FORMAT_DISTANCE 0
+#endif
+*/
+
+#ifndef RTXGI_DDGI_DEBUG_FORMAT_OFFSETS
+#define RTXGI_DDGI_DEBUG_FORMAT_OFFSETS 0
+#endif
+
+// --- Probe Update ----------------------------------
+
+#ifndef RTXGI_DDGI_BLENDING_USE_SHARED_MEMORY
+#define RTXGI_DDGI_BLENDING_USE_SHARED_MEMORY 1
+#endif
+
+#ifndef RTXGI_DDGI_DEBUG_PROBE_INDEXING
+#define RTXGI_DDGI_DEBUG_PROBE_INDEXING 0
+#endif
+
+#ifndef RTXGI_DDGI_DEBUG_OCTAHEDRAL_INDEXING
+#define RTXGI_DDGI_DEBUG_OCTAHEDRAL_INDEXING 0
+#endif
+
+#ifndef RTXGI_DDGI_DEBUG_BORDER_COPY_INDEXING
+#define RTXGI_DDGI_DEBUG_BORDER_COPY_INDEXING 0
+#endif
+
+// --- Indirect Lighting -----------------------------
+
+#ifndef RTXGI_DDGI_COMPUTE_IRRADIANCE
+#define RTXGI_DDGI_COMPUTE_IRRADIANCE 1
+#endif
+
+#ifndef RTXGI_DDGI_COMPUTE_IRRADIANCE_RECURSIVE
+#define RTXGI_DDGI_COMPUTE_IRRADIANCE_RECURSIVE 1
+#endif
+
+// --- Probe Relocation -------------------------
+
+// a per volume setting, so a shader permutation
+/*
+#ifndef RTXGI_DDGI_PROBE_RELOCATION
+#define RTXGI_DDGI_PROBE_RELOCATION 0
+#endif
+*/
+
+// --- Probe Classification -------------------------
+
+// always on, but defined to be 1 in code
+/*
+#ifndef RTXGI_DDGI_PROBE_STATE_CLASSIFIER
+#define RTXGI_DDGI_PROBE_STATE_CLASSIFIER 0
+#endif
+*/
+
+// --- Probe Movement (Early Access) --------------------------------
+
+// a per volume setting, so a shader permutation
+/*
+#ifndef RTXGI_DDGI_PROBE_SCROLL
+#define RTXGI_DDGI_PROBE_SCROLL 1
+#endif
+*/
+
+// ---------------------------------------------------
+
+#endif /* RTXGI_DDGI_VOLUME_DEFINES_H */
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/Irradiance.ush b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/Irradiance.ush
new file mode 100644
index 00000000000..03814601f5a
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/Irradiance.ush
@@ -0,0 +1,230 @@
+/*
+* Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#ifndef RTXGI_DDGI_IRRADIANCE_HLSL
+#define RTXGI_DDGI_IRRADIANCE_HLSL
+
+// These are turned on/off together in the plugin settings. Turned on if the lighting values are too large to be stored (like in extended radiance mode)
+#define RTXGI_DDGI_DEBUG_FORMAT_IRRADIANCE RTXGI_DDGI_DEBUG_FORMAT_RADIANCE
+
+#include "ProbeCommon.ush"
+
+struct DDGIVolumeResources
+{
+    Texture2D<float4> probeIrradianceSRV;
+    Texture2D<float4> probeDistanceSRV;
+    SamplerState bilinearSampler;
+#if RTXGI_DDGI_PROBE_RELOCATION
+    RWTexture2D<float4> probeOffsets;
+#endif
+#if RTXGI_DDGI_PROBE_STATE_CLASSIFIER
+    Texture2D<uint> probeStates;
+#endif
+};
+
+/**
+* Computes the surfaceBias parameter used by DDGIGetVolumeIrradiance().
+* The surfaceNormal and cameraDirection arguments are expected to be normalized.
+*/
+float3 DDGIGetSurfaceBias(float3 surfaceNormal, float3 cameraDirection, DDGIVolumeDescGPU DDGIVolume)
+{
+    return (surfaceNormal * DDGIVolume.normalBias) + (-cameraDirection * DDGIVolume.viewBias);
+}
+
+/**
+* Computes a blending weight for the given volume for blending between multiple volumes.
+* Return value of 1.0 means full contribution from this volume while 0.0 means no contribution.
+*/
+float DDGIGetVolumeBlendWeight(float3 worldPosition, DDGIVolumeDescGPU volume)
+{
+    // Start fully weighted
+    float volumeBlendWeight = 1.f;
+
+    float3 position = worldPosition - volume.origin;
+    position = RTXGIQuaternionRotate(position, RTXGIQuaternionConjugate(volume.rotation));
+
+    // Shift from [-n/2, n/2] to [0, n]
+    position += (volume.probeGridSpacing * (volume.probeGridCounts - 1)) * 0.5f;
+    float3 probeCoords = (position / volume.probeGridSpacing);
+
+    // Map numbers over the max to the range 0 to 1 for blending
+    float3 overProbeMax = (volume.probeGridCounts - 1.f) - probeCoords;
+
+    // Use the geometric mean across all axes for weight
+    volumeBlendWeight *= clamp(probeCoords.x, 0.f, 1.f);
+    volumeBlendWeight *= clamp(probeCoords.y, 0.f, 1.f);
+    volumeBlendWeight *= clamp(probeCoords.z, 0.f, 1.f);
+    volumeBlendWeight *= clamp(overProbeMax.x, 0.f, 1.f);
+    volumeBlendWeight *= clamp(overProbeMax.y, 0.f, 1.f);
+    volumeBlendWeight *= clamp(overProbeMax.z, 0.f, 1.f);
+
+    return volumeBlendWeight;
+}
+
+/**
+* Samples irradiance from the given volume's probes using information about the surface, sampling direction, and volume.
+*/
+float3 DDGIGetVolumeIrradiance(
+    float3 worldPosition,
+    float3 surfaceBias,
+    float3 direction,
+    DDGIVolumeDescGPU volume,
+    DDGIVolumeResources resources)
+{
+    float3 irradiance = float3(0.f, 0.f, 0.f);
+    float  accumulatedWeights = 0.f;
+
+    // Bias the world space position
+    float3 biasedWorldPosition = (worldPosition + surfaceBias);
+
+    // Get the 3D grid coordinates of the base probe (near the biased world position)
+    int3   baseProbeCoords = DDGIGetBaseProbeGridCoords(biasedWorldPosition, volume.origin, volume.rotation, volume.probeGridCounts, volume.probeGridSpacing);
+
+    // Get the world space position of the base probe
+    float3 baseProbeWorldPosition = DDGIGetProbeWorldPosition(baseProbeCoords, volume.origin, volume.rotation, volume.probeGridCounts, volume.probeGridSpacing);
+
+    // Clamp the distance between the given point and the base probe's world position (on each axis) to [0, 1]
+    float3 distanceVolumeSpace = RTXGIQuaternionRotate(biasedWorldPosition - baseProbeWorldPosition, RTXGIQuaternionConjugate(volume.rotation));
+    float3 alpha = clamp((distanceVolumeSpace / volume.probeGridSpacing), float3(0.f, 0.f, 0.f), float3(1.f, 1.f, 1.f));
+
+    // Iterate over the 8 closest probes and accumulate their contributions
+    for(int probeIndex = 0; probeIndex < 8; probeIndex++)
+    {
+        // Compute the offset to the adjacent probe in grid coordinates by
+        // sourcing the offsets from the bits of the loop index: x = bit 0, y = bit 1, z = bit 2
+        int3 adjacentProbeOffset = int3(probeIndex, probeIndex >> 1, probeIndex >> 2) & int3(1, 1, 1);
+
+        // Get the 3D grid coordinates of the adjacent probe by adding the offset to the base probe
+        // Clamp to the grid boundaries
+        int3 adjacentProbeCoords = clamp(baseProbeCoords + adjacentProbeOffset, int3(0, 0, 0), volume.probeGridCounts - int3(1, 1, 1));
+
+        // Get the adjacent probe's world position
+#if RTXGI_DDGI_PROBE_RELOCATION
+#if RTXGI_DDGI_PROBE_SCROLL
+        float3 adjacentProbeWorldPosition = DDGIGetProbeWorldPositionWithOffset(adjacentProbeCoords, volume.origin, volume.rotation, volume.probeGridCounts, volume.probeGridSpacing, volume.probeScrollOffsets, resources.probeOffsets);
+#else
+        float3 adjacentProbeWorldPosition = DDGIGetProbeWorldPositionWithOffset(adjacentProbeCoords, volume.origin, volume.rotation, volume.probeGridCounts, volume.probeGridSpacing, resources.probeOffsets);
+#endif
+#else
+        float3 adjacentProbeWorldPosition = DDGIGetProbeWorldPosition(adjacentProbeCoords, volume.origin, volume.rotation, volume.probeGridCounts, volume.probeGridSpacing);
+#endif
+
+        // Get the adjacent probe's index (used for texture lookups)
+        int adjacentProbeIndex = DDGIGetProbeIndex(adjacentProbeCoords, volume.probeGridCounts);
+
+#if RTXGI_DDGI_PROBE_STATE_CLASSIFIER
+        {
+            #if RTXGI_DDGI_PROBE_SCROLL
+                int probeIndex = DDGIGetProbeIndexOffset(adjacentProbeIndex, volume.probeGridCounts, volume.probeScrollOffsets);
+            #else
+                int probeIndex = adjacentProbeIndex;
+            #endif
+
+            // If the probe is marked as inactive, don't allow it to contribute to indirect lighting
+            int2 texelPosition = DDGIGetProbeTexelPosition(probeIndex, volume.probeGridCounts);
+            int  probeState = resources.probeStates.Load(int3(texelPosition, 0));
+            if(probeState == PROBE_STATE_INACTIVE) continue;
+        }
+#endif
+
+        // Compute the distance and direction from the (biased and non-biased) shading point and the adjacent probe
+        float3 worldPosToAdjProbe = normalize(adjacentProbeWorldPosition - worldPosition);
+        float3 biasedPosToAdjProbe = normalize(adjacentProbeWorldPosition - biasedWorldPosition);
+        float  biasedPosToAdjProbeDist = length(adjacentProbeWorldPosition - biasedWorldPosition);
+
+        // Compute trilinear weights based on the distance to each adjacent probe
+        // to smoothly transition between probes. adjacentProbeOffset is binary, so we're
+        // using a 1-alpha when adjacentProbeOffset = 0 and alpha when adjacentProbeOffset = 1.
+        float3 trilinear = max(0.001f, lerp(1.f - alpha, alpha, adjacentProbeOffset));
+        float  trilinearWeight = (trilinear.x * trilinear.y * trilinear.z);
+        float  weight = 1.f;
+
+        // A naive soft backface weight would ignore a probe when
+        // it is behind the surface. That's good for walls, but for
+        // small details inside of a room, the normals on the details
+        // might rule out all of the probes that have mutual visibility
+        // to the point. We instead use a "wrap shading" test. The small
+        // offset at the end reduces the "going to zero" impact.
+        float wrapShading = (dot(worldPosToAdjProbe, direction) + 1.f) * 0.5f;
+        weight *= (wrapShading * wrapShading) + 0.2f;
+
+        // Compute the texture coordinates of this adjacent probe and sample the probe's filtered distance
+        float2 octantCoords = DDGIGetOctahedralCoordinates(-biasedPosToAdjProbe);
+#if RTXGI_DDGI_PROBE_SCROLL
+        float2 probeTextureCoords = DDGIGetProbeUV(adjacentProbeIndex, octantCoords, volume.probeGridCounts, volume.probeNumDistanceTexels, volume.probeScrollOffsets);
+#else
+        float2 probeTextureCoords = DDGIGetProbeUV(adjacentProbeIndex, octantCoords, volume.probeGridCounts, volume.probeNumDistanceTexels);
+#endif
+        float2 filteredDistance = 2.f * resources.probeDistanceSRV.SampleLevel(resources.bilinearSampler, probeTextureCoords, 0).rg;
+
+        float meanDistanceToSurface = filteredDistance.x;
+        float variance = abs((filteredDistance.x * filteredDistance.x) - filteredDistance.y);
+
+        float chebyshevWeight = 1.f;
+        if(biasedPosToAdjProbeDist > meanDistanceToSurface) // In "shadow"
+        {
+            // v must be greater than 0, which is guaranteed by the if condition above.
+            float v = biasedPosToAdjProbeDist - meanDistanceToSurface;
+            chebyshevWeight = variance / (variance + (v * v));
+
+            // Increase the contrast in the weight
+            chebyshevWeight = max((chebyshevWeight * chebyshevWeight * chebyshevWeight), 0.f);
+        }
+
+        // Avoid visibility weights ever going all the way to zero because
+        // when *no* probe has visibility we need a fallback value
+        weight *= max(0.05f, chebyshevWeight);
+
+        // Avoid a weight of zero
+        weight = max(0.000001f, weight);
+
+        // A small amount of light is visible due to logarithmic perception, so
+        // crush tiny weights but keep the curve continuous
+        const float crushThreshold = 0.2f;
+        if (weight < crushThreshold)
+        {
+            weight *= (weight * weight) * (1.f / (crushThreshold * crushThreshold));
+        }
+
+        // Apply the trilinear weights
+        weight *= trilinearWeight;
+
+        // Sample the probe irradiance
+        octantCoords = DDGIGetOctahedralCoordinates(direction);
+#if RTXGI_DDGI_PROBE_SCROLL
+        probeTextureCoords = DDGIGetProbeUV(adjacentProbeIndex, octantCoords, volume.probeGridCounts, volume.probeNumIrradianceTexels, volume.probeScrollOffsets);
+#else
+        probeTextureCoords = DDGIGetProbeUV(adjacentProbeIndex, octantCoords, volume.probeGridCounts, volume.probeNumIrradianceTexels);
+#endif
+        float3 probeIrradiance = resources.probeIrradianceSRV.SampleLevel(resources.bilinearSampler, probeTextureCoords, 0).rgb;
+
+        // Decode the tone curve, but leave a gamma = 2 curve to approximate sRGB blending
+        float3 exponent = volume.probeIrradianceEncodingGamma * 0.5f;
+        probeIrradiance = pow(probeIrradiance, exponent);
+
+        // Accumulate the weighted irradiance
+        irradiance += (weight * probeIrradiance);
+        accumulatedWeights += weight;
+    }
+
+    if(accumulatedWeights == 0.f) return float3(0.f, 0.f, 0.f);
+
+    irradiance *= (1.f / accumulatedWeights);   // Normalize by the accumulated weights
+    irradiance *= irradiance;                   // Go back to linear irradiance
+    irradiance *= RTXGI_2PI;                    // Multiply by the area of the integration domain (hemisphere) to complete the Monte Carlo Estimator equation
+
+#if !RTXGI_DDGI_DEBUG_FORMAT_IRRADIANCE
+    irradiance *= 1.0989f;                      // Adjust for energy loss due to reduced precision in the R10G10B10A2 irradiance texture format
+#endif
+
+    return irradiance;
+}
+
+#endif /* RTXGI_DDGI_IRRADIANCE_HLSL */
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/ProbeBlendingCS.usf b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/ProbeBlendingCS.usf
new file mode 100644
index 00000000000..eb08dc5d515
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/ProbeBlendingCS.usf
@@ -0,0 +1,364 @@
+/*
+* Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+// These are turned on/off together in the plugin settings. Turned on if the lighting values are too large to be stored (like in extended radiance mode)
+#define RTXGI_DDGI_DEBUG_FORMAT_IRRADIANCE RTXGI_DDGI_DEBUG_FORMAT_RADIANCE
+
+#include "/Engine/Private/Common.ush"
+
+// This needs to match EDDGIRaysPerProbe in DDGIVolumeComponent.h
+#if RAYS_PER_PROBE_ENUM == 0
+    #define RAYS_PER_PROBE 144
+#elif RAYS_PER_PROBE_ENUM == 1
+    #define RAYS_PER_PROBE 288
+#elif RAYS_PER_PROBE_ENUM == 2
+    #define RAYS_PER_PROBE 432
+#elif RAYS_PER_PROBE_ENUM == 3
+    #define RAYS_PER_PROBE 576
+#elif RAYS_PER_PROBE_ENUM == 4
+    #define RAYS_PER_PROBE 720
+#elif RAYS_PER_PROBE_ENUM == 5
+    #define RAYS_PER_PROBE 864
+#elif RAYS_PER_PROBE_ENUM == 6
+    #define RAYS_PER_PROBE 1008
+#endif
+
+// Below is Adapted from ProbeBlendingCS.hlsl in the SDK aiming for minimal changes to help future merges.
+
+struct DDGIVolumeDescGPU_Local
+{
+    int3        probeGridCounts;
+    int         numRaysPerProbe;
+    float4x4    probeRayRotationTransform;
+    float3      probeGridSpacing;
+    float       probeDistanceExponent;
+    float       probeInverseIrradianceEncodingGamma;
+    float       probeHysteresis;
+    float       probeChangeThreshold;
+    float       probeBrightnessThreshold;
+    int3        probeScrollOffsets;
+};
+
+#include "ProbeCommon.ush"
+
+// Note: PROBE_NUM_TEXELS must be passed in as a define at shader compilation time
+// See Harness.cpp::CompileShaders() in the Test Harness application
+//#define PROBE_NUM_TEXELS [6|14]
+
+int3        DDGIVolume_probeGridCounts;
+int         DDGIVolume_numRaysPerProbe;
+float4x4    DDGIVolume_probeRayRotationTransform;
+float3      DDGIVolume_probeGridSpacing;
+float       DDGIVolume_probeDistanceExponent;
+float       DDGIVolume_probeInverseIrradianceEncodingGamma;
+float       DDGIVolume_probeHysteresis;
+float       DDGIVolume_probeChangeThreshold;
+float       DDGIVolume_probeBrightnessThreshold;
+int3        DDGIVolume_probeScrollOffsets;
+int         DDGIVolume_ProbeIndexStart;
+int         DDGIVolume_ProbeIndexCount;
+
+// Probe ray traced radiance and hit distance
+RWTexture2D<float4> DDGIProbeRTRadianceUAV;
+
+// Probe irradiance or filtered distance
+RWTexture2D<float4> DDGIProbeUAV;
+RWTexture2D<float4> DebugOutput;
+
+#if RTXGI_DDGI_PROBE_STATE_CLASSIFIER
+// Probe states
+RWTexture2D<uint>   DDGIProbeStates;
+#endif
+
+#if RTXGI_DDGI_BLENDING_USE_SHARED_MEMORY
+// Note: When using shared memory, RAYS_PER_PROBE must be passed in as a define at shader compilation time
+// See Harness.cpp::CompileShaders() in the Test Harness application
+// #define RAYS_PER_PROBE 144
+
+// Shared Memory (example for default settings):
+// Radiance (float3) x 144 rays/probe = 432 floats (~1.7 KB)
+// Distance (float) x 144 rays/probe = 144 floats (~0.56 KB)
+// Ray Directions (float3 x 144 rays/probe) = 432 floats (~1.7 KB)
+//
+// Max shared memory usage = ~3.96 KB (~1.7 KB radiance + ~0.56 KB distance + ~1.7 KB directions)
+
+// Example usage:
+// Irradiance thread groups as 6 x 6 = 36 threads
+//     Group threads load 144 ray radiance & distance values / 36 threads = 4 ray radiance & distance values / thread
+//     Group threads compute 144 ray directions / 36 threads = 4 directions / thread
+// Distance thread groups are 14 x 14 = 196 threads
+//     Group threads load 144 ray distances / 196 threads = ~0.73 ray distance values / thread
+//     Group threads compute 144 ray directions / 196 threads = ~0.73 ray directions / thread
+
+#if RTXGI_DDGI_BLEND_RADIANCE
+groupshared float3 RTRadiance[RAYS_PER_PROBE];
+#endif
+groupshared float  RTDistance[RAYS_PER_PROBE];
+groupshared float3 RayDirection[RAYS_PER_PROBE];
+#endif
+
+[numthreads(PROBE_NUM_TEXELS, PROBE_NUM_TEXELS, 1)]
+void DDGIProbeBlendingCS(uint3 DispatchThreadID : SV_DispatchThreadID, uint GroupIndex : SV_GroupIndex)
+{
+    DDGIVolumeDescGPU_Local DDGIVolume;
+    DDGIVolume.probeGridCounts = DDGIVolume_probeGridCounts;
+    DDGIVolume.numRaysPerProbe = DDGIVolume_numRaysPerProbe;
+    DDGIVolume.probeRayRotationTransform = DDGIVolume_probeRayRotationTransform;
+    DDGIVolume.probeGridSpacing = DDGIVolume_probeGridSpacing;
+    DDGIVolume.probeDistanceExponent = DDGIVolume_probeDistanceExponent;
+    DDGIVolume.probeInverseIrradianceEncodingGamma = DDGIVolume_probeInverseIrradianceEncodingGamma;
+    DDGIVolume.probeHysteresis = DDGIVolume_probeHysteresis;
+    DDGIVolume.probeChangeThreshold = DDGIVolume_probeChangeThreshold;
+    DDGIVolume.probeBrightnessThreshold = DDGIVolume_probeBrightnessThreshold;
+    DDGIVolume.probeScrollOffsets = DDGIVolume_probeScrollOffsets;
+
+    float4 result = float4(0.f, 0.f, 0.f, 0.f);
+
+    // Find the index of the probe that this thread maps to (for reading the RT radiance buffer)
+    int probeIndex = DDGIGetProbeIndex(DispatchThreadID.xy, DDGIVolume.probeGridCounts, PROBE_NUM_TEXELS);
+    bool exitEarly = probeIndex < 0;
+
+    // Handle round robin updating.
+    // If this probe is outside of the window for updating, bail out.
+    {
+        int numProbes = DDGIVolume_probeGridCounts.x * DDGIVolume_probeGridCounts.y * DDGIVolume_probeGridCounts.z;
+        int probeRRIndex = (probeIndex < DDGIVolume_ProbeIndexStart) ? probeIndex + numProbes : probeIndex;
+        if (probeRRIndex >= DDGIVolume_ProbeIndexStart + DDGIVolume_ProbeIndexCount)
+            exitEarly = true;
+    }
+
+     // we have to do it this way so the GroupMemoryBarrierWithGroupSync() call isn't conditional when UE compiles this shader.
+    float3 probeRayDirection = float3(1.0f, 0.0f, 0.0f);
+    uint2 probeTexCoords = uint2(0, 0);
+    while (!exitEarly)
+    {
+#if RTXGI_DDGI_PROBE_SCROLL
+        int storageProbeIndex = DDGIGetProbeIndexOffset(probeIndex, DDGIVolume.probeGridCounts, DDGIVolume.probeScrollOffsets);
+        // Transform the probe index into probe texel coordinates
+        // Offset 1 texel on X and Y to account for the 1 texel probe border
+        uint2 intraProbeTexelOffset = DispatchThreadID.xy % uint2(PROBE_NUM_TEXELS, PROBE_NUM_TEXELS);
+        probeTexCoords = DDGIGetThreadBaseCoords(storageProbeIndex, DDGIVolume.probeGridCounts, PROBE_NUM_TEXELS) + intraProbeTexelOffset;
+        probeTexCoords.xy = probeTexCoords.xy + uint2(1, 1) + (probeTexCoords.xy / PROBE_NUM_TEXELS) * 2;
+#else
+        int storageProbeIndex = probeIndex;
+        // Transform the thread dispatch index into probe texel coordinates
+        // Offset 1 texel on X and Y to account for the 1 texel probe border
+        probeTexCoords = DispatchThreadID.xy + uint2(1, 1);
+        probeTexCoords.xy += (DispatchThreadID.xy / PROBE_NUM_TEXELS) * 2;
+#endif
+
+#if RTXGI_DDGI_PROBE_STATE_CLASSIFIER
+        int2 texelPosition = DDGIGetProbeTexelPosition(storageProbeIndex, DDGIVolume.probeGridCounts);
+        int  probeState = DDGIProbeStates[texelPosition];
+        if (probeState == PROBE_STATE_INACTIVE)
+        {
+            exitEarly = true;
+            break; // If the probe is inactive, do not blend (it didn't shoot rays to get new radiance values)
+        }
+#endif /* RTXGI_DDGI_PROBE_STATE_CLASSIFIER */
+
+#if RTXGI_DDGI_BLEND_RADIANCE && RTXGI_DDGI_DEBUG_PROBE_INDEXING && RTXGI_DDGI_DEBUG_FORMAT_IRRADIANCE
+        // Visualize the probe index
+        DDGIProbeUAV[0][probeTexCoords] = float4(probeIndex, 0, 0, 1);
+        return;
+#endif
+
+        float2 probeOctantUV = float2(0.f, 0.f);
+
+#if RTXGI_DDGI_BLEND_RADIANCE && RTXGI_DDGI_DEBUG_OCTAHEDRAL_INDEXING
+        probeOctantUV = DDGIGetNormalizedOctahedralCoordinates(int2(DispatchThreadID.xy), PROBE_NUM_TEXELS);
+        if (all(abs(probeOctantUV) <= 1.f))
+        {
+            float3 probeDirection = DDGIGetOctahedralDirection(probeOctantUV);
+            probeDirection = (abs(probeDirection) >= 0.001f) * sign(probeDirection);    // Robustness for when the octant size is not a power of 2.
+            result = float4((probeDirection * 0.5f) + 0.5f, 1.f);
+        }
+        DDGIProbeUAV[0][probeTexCoords] = result;
+        return;
+#endif
+
+        // Get the probe ray direction associated with this thread
+        probeOctantUV = DDGIGetNormalizedOctahedralCoordinates(int2(DispatchThreadID.xy), PROBE_NUM_TEXELS);
+        probeRayDirection = DDGIGetOctahedralDirection(probeOctantUV);
+
+#if RTXGI_DDGI_BLENDING_USE_SHARED_MEMORY
+        // Cooperatively load the ray traced radiance and hit distance values into shared memory
+        // Cooperatively compute the probe ray directions
+        int totalIterations = int(ceil(float(RAYS_PER_PROBE) / float(PROBE_NUM_TEXELS * PROBE_NUM_TEXELS)));
+        for (int iteration = 0; iteration < totalIterations; iteration++)
+        {
+            int rayIndex = (GroupIndex * totalIterations) + iteration;
+            if (rayIndex >= RAYS_PER_PROBE) break;
+
+#if RTXGI_DDGI_BLEND_RADIANCE
+#if RTXGI_DDGI_DEBUG_FORMAT_RADIANCE
+            RTRadiance[rayIndex] = DDGIProbeRTRadianceUAV[int2(rayIndex, probeIndex)].rgb;
+#else
+            RTRadiance[rayIndex] = RTXGIUintToFloat3(asuint(DDGIProbeRTRadianceUAV[int2(rayIndex, probeIndex)].r));
+#endif
+#endif
+
+#if RTXGI_DDGI_DEBUG_FORMAT_RADIANCE
+            RTDistance[rayIndex] = DDGIProbeRTRadianceUAV[int2(rayIndex, probeIndex)].a;
+#else
+            RTDistance[rayIndex] = DDGIProbeRTRadianceUAV[int2(rayIndex, probeIndex)].g;
+#endif
+
+            RayDirection[rayIndex] = DDGIGetProbeRayDirection(rayIndex, DDGIVolume.numRaysPerProbe, DDGIVolume.probeRayRotationTransform);
+        }
+#endif /* RTXGI_DDGI_BLENDING_USE_SHARED_MEMORY */
+        break;
+    }
+
+#if RTXGI_DDGI_BLENDING_USE_SHARED_MEMORY
+    // Wait for all threads in the group to finish shared memory operations
+    GroupMemoryBarrierWithGroupSync();
+#endif /* RTXGI_DDGI_BLENDING_USE_SHARED_MEMORY */
+
+    if (probeIndex < 0 || exitEarly)
+    {
+        return; // Probe doesn't exist, or we want to exit for other reasons
+    }
+
+#if RTXGI_DDGI_BLEND_RADIANCE
+    // Backface hits are ignored when blending radiance
+    // Allow a maximum of 10% of the rays to hit backfaces. If that limit is exceeded, don't blend anything into this probe.
+    uint backfaces = 0;
+    uint maxBackfaces = DDGIVolume.numRaysPerProbe * 0.1f;
+#endif
+
+    int rayIndex = 0;
+#if RTXGI_DDGI_PROBE_RELOCATION || RTXGI_DDGI_PROBE_STATE_CLASSIFIER
+    rayIndex = RTXGI_DDGI_NUM_FIXED_RAYS;
+#endif
+
+    // Blend radiance or distance values from each ray to compute irradiance or fitered distance
+    for ( /*rayIndex*/; rayIndex < DDGIVolume.numRaysPerProbe; rayIndex++)
+    {
+        // Get the direction for this probe ray
+#if RTXGI_DDGI_BLENDING_USE_SHARED_MEMORY
+        float3 rayDirection = RayDirection[rayIndex];
+#else
+        float3 rayDirection = DDGIGetProbeRayDirection(rayIndex, DDGIVolume.numRaysPerProbe, DDGIVolume.probeRayRotationTransform);
+#endif
+
+        // Find the weight of the contribution for this ray
+        // Weight is based on the cosine of the angle between the ray direction and the direction of the probe octant's texel
+        float weight = max(0.f, dot(probeRayDirection, rayDirection));
+
+        // The indices of the probe ray in the radiance buffer
+        int2 probeRayIndex = int2(rayIndex, probeIndex);
+
+#if RTXGI_DDGI_BLEND_RADIANCE
+        // Load the ray traced radiance and hit distance
+#if RTXGI_DDGI_BLENDING_USE_SHARED_MEMORY
+        float3 probeRayRadiance = RTRadiance[rayIndex];
+        float  probeRayDistance = RTDistance[rayIndex];
+#else
+#if RTXGI_DDGI_DEBUG_FORMAT_RADIANCE
+        float3 probeRayRadiance = DDGIProbeRTRadianceUAV[probeRayIndex].rgb;
+        float  probeRayDistance = DDGIProbeRTRadianceUAV[probeRayIndex].a;
+#else
+        float3 probeRayRadiance = RTXGIUintToFloat3(asuint(DDGIProbeRTRadianceUAV[int2(rayIndex, probeIndex)].r));
+        float  probeRayDistance = DDGIProbeRTRadianceUAV[probeRayIndex].g;
+#endif
+#endif
+
+        // Backface hit, don't blend this sample
+        if (probeRayDistance < 0.f)
+        {
+            backfaces++;
+            if (backfaces >= maxBackfaces) return;
+            continue;
+        }
+
+        // Blend the ray's radiance
+        result += float4(probeRayRadiance * weight, weight);
+
+#else /* !RTXGI_DDGI_BLEND_RADIANCE */
+
+        // Initialize the probe hit distance to three quarters of the distance of the grid cell diagonal
+        float probeMaxRayDistance = length(DDGIVolume.probeGridSpacing) * 0.75f;
+
+        // Increase or decrease the filtered distance value's "sharpness"
+        weight = pow(weight, DDGIVolume.probeDistanceExponent);
+
+        // Load the ray traced distance
+#if RTXGI_DDGI_BLENDING_USE_SHARED_MEMORY
+        float probeRayDistance = min(abs(RTDistance[rayIndex]), probeMaxRayDistance);
+#else
+        // HitT is negative on backface hits for the probe relocation, so take the absolute value
+#if RTXGI_DDGI_DEBUG_FORMAT_RADIANCE
+        float probeRayDistance = min(abs(DDGIProbeRTRadianceUAV[probeRayIndex].a), probeMaxRayDistance);
+#else
+        float probeRayDistance = min(abs(DDGIProbeRTRadianceUAV[probeRayIndex].g), probeMaxRayDistance);
+#endif
+#endif
+
+        // Filter the ray distance
+        result += float4(probeRayDistance * weight, (probeRayDistance * probeRayDistance) * weight, 0.f, weight);
+#endif
+    }
+
+    // Normalize the blended irradiance (or filtered distance), if the combined weight is not close to zero.
+    // To match the Monte Carlo Estimator for Irradiance, we should divide by N. Instead, we are dividing by
+    // N * sum(cos(theta)) (the sum of the weights) to reduce variance.
+    // To account for this, we must mulitply in a factor of 1/2.
+    const float epsilon = 1e-9f * float(DDGIVolume.numRaysPerProbe);
+    result.rgb *= 1.f / max(2.f * result.a, epsilon);
+
+    float  hysteresis = DDGIVolume.probeHysteresis;
+    float3 previous = DDGIProbeUAV[probeTexCoords].rgb;
+
+#if RTXGI_DDGI_BLEND_RADIANCE
+    // Tone-mapping gamma adjustment
+    result.rgb = pow(result.rgb, DDGIVolume.probeInverseIrradianceEncodingGamma);
+
+    if (RTXGIMaxComponent(previous.rgb - result.rgb) > DDGIVolume.probeChangeThreshold)
+    {
+        // Lower the hysteresis when a large lighting change is detected
+        hysteresis = max(0.f, hysteresis - 0.15f);
+    }
+
+    float3 delta = (result.rgb - previous.rgb);
+    if (length(delta) > DDGIVolume.probeBrightnessThreshold)
+    {
+        // Clamp the maximum change in irradiance when a large brightness change is detected
+        result.rgb = previous.rgb + (delta * 0.75f);
+    }
+
+    // Interpolate the new blended irradiance with the existing irradiance in the probe.
+    // A high hysteresis value emphasizes the existing probe irradiance.
+    //
+    // When using lower bit depth formats for irradiance, the difference between lerped values
+    // may be smaller than what the texture format can represent. This can stop progress towards
+    // the target value when going from high to low values. When darkening, step at least the minimum
+    // value the texture format can represent to ensure the target value is reached. The threshold value
+    // for 10-bit/channel formats is always used (even for 32-bit/channel formats) to speed up light to
+    // dark convergence.
+    static const float c_threshold = 1.f / 1024.f;
+    float3 lerpDelta = (1.f - hysteresis) * delta;
+    if (RTXGIMaxComponent(result.rgb) < RTXGIMaxComponent(previous.rgb))
+    {
+        lerpDelta = min(max(c_threshold, abs(lerpDelta)), abs(delta)) * sign(lerpDelta);
+    }
+    result = float4(previous.rgb + lerpDelta, 1.f);
+#else
+    // Interpolate the new filtered distance with the existing filtered distance in the probe.
+    // A high hysteresis value emphasizes the existing probe filtered distance.
+    result = float4(lerp(result.rgb, previous.rgb, hysteresis), 1.f);
+#endif
+
+    DDGIProbeUAV[probeTexCoords] = result;
+
+    #if DDGIIrradianceBlendDebug != 0 || DDGIDistanceBlendDebug != 0
+    DebugOutput[probeTexCoords] = result;
+    #endif
+}
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/ProbeBorderUpdateCS.usf b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/ProbeBorderUpdateCS.usf
new file mode 100644
index 00000000000..0d05be5597c
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/ProbeBorderUpdateCS.usf
@@ -0,0 +1,129 @@
+/*
+* Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+// These are turned on/off together in the plugin settings. Turned on if the lighting values are too large to be stored (like in extended radiance mode)
+#define RTXGI_DDGI_DEBUG_FORMAT_IRRADIANCE RTXGI_DDGI_DEBUG_FORMAT_RADIANCE
+
+#include "/Engine/Private/Common.ush"
+
+// Below is Adapted from ProbeBorderUpdateCS.hlsl in the SDK aiming for minimal changes to help future merges.
+
+#include "../DDGIVolumeDefines.ush"
+//#include "../DDGIVolumeDescGPU.ush"
+
+uint    ProbeNumIrradianceOrDistanceTexels;
+
+// Probe irradiance or filtered distance
+RWTexture2D<float4> DDGIProbeUAV;
+
+[numthreads(8, 8, 1)]
+void DDGIProbeBorderRowUpdateCS(uint3 DispatchThreadID : SV_DispatchThreadID)
+{
+    uint probeSideLength = (ProbeNumIrradianceOrDistanceTexels + 2);
+    uint probeSideLengthMinusOne = (probeSideLength - 1);
+
+    // Map thread index to border row texel coordinates
+    uint2 threadCoordinates = DispatchThreadID.xy;
+    threadCoordinates.y *= probeSideLength;
+
+    // Ignore the corner texels
+    int mod = (DispatchThreadID.x % probeSideLength);
+    if (mod == 0 || mod == int(probeSideLengthMinusOne))
+    {
+        return;
+    }
+
+    // Compute the interior texel coordinates to copy (top row)
+    uint probeStart = uint(threadCoordinates.x / probeSideLength) * probeSideLength;
+    uint offset = probeSideLengthMinusOne - (threadCoordinates.x % probeSideLength);
+
+    uint2 copyCoordinates = uint2(probeStart + offset, (threadCoordinates.y + 1));
+
+#if RTXGI_DDGI_DEBUG_BORDER_COPY_INDEXING && RTXGI_DDGI_DEBUG_FORMAT_IRRADIANCE
+    DDGIProbeUAV[threadCoordinates] = float4(threadCoordinates, copyCoordinates);
+    threadCoordinates.y += probeSideLengthMinusOne;
+    copyCoordinates = uint2(probeStart + offset, threadCoordinates.y - 1);
+    DDGIProbeUAV[threadCoordinates] = float4(threadCoordinates, copyCoordinates);
+    return;
+#endif
+
+    // Top row
+    DDGIProbeUAV[threadCoordinates] = DDGIProbeUAV[copyCoordinates];
+
+    // Compute the interior texel coordinate to copy (bottom row)
+    threadCoordinates.y += probeSideLengthMinusOne;
+    copyCoordinates = uint2(probeStart + offset, threadCoordinates.y - 1);
+
+    // Bottom row
+    DDGIProbeUAV[threadCoordinates] = DDGIProbeUAV[copyCoordinates];
+}
+
+[numthreads(8, 8, 1)]
+void DDGIProbeBorderColumnUpdateCS(uint3 DispatchThreadID : SV_DispatchThreadID)
+{
+    uint probeSideLength = (ProbeNumIrradianceOrDistanceTexels + 2);
+    uint probeSideLengthMinusOne = (probeSideLength - 1);
+
+    // Map thread index to border row texel coordinates
+    uint2 threadCoordinates = DispatchThreadID.xy;
+    threadCoordinates.x *= probeSideLength;
+
+    uint2 copyCoordinates = uint2(0, 0);
+
+    // Handle the corner texels
+    int mod = (threadCoordinates.y % probeSideLength);
+    if (mod == 0 || mod == int(probeSideLengthMinusOne))
+    {
+        // Left corner
+        copyCoordinates.x = threadCoordinates.x + ProbeNumIrradianceOrDistanceTexels;
+        copyCoordinates.y = threadCoordinates.y - sign(mod - 1) * ProbeNumIrradianceOrDistanceTexels;
+
+#if RTXGI_DDGI_DEBUG_BORDER_COPY_INDEXING && RTXGI_DDGI_DEBUG_FORMAT_IRRADIANCE
+        DDGIProbeUAV[threadCoordinates] = float4(threadCoordinates, copyCoordinates);
+#else
+        DDGIProbeUAV[threadCoordinates] = DDGIProbeUAV[copyCoordinates];
+#endif
+
+        // Right corner
+        threadCoordinates.x += probeSideLengthMinusOne;
+        copyCoordinates.x = threadCoordinates.x - ProbeNumIrradianceOrDistanceTexels;
+
+#if RTXGI_DDGI_DEBUG_BORDER_COPY_INDEXING & RTXGI_DDGI_DEBUG_FORMAT_IRRADIANCE
+        DDGIProbeUAV[threadCoordinates] = float4(threadCoordinates, copyCoordinates);
+#else
+        DDGIProbeUAV[threadCoordinates] = DDGIProbeUAV[copyCoordinates];
+#endif
+        return;
+    }
+
+    // Compute the interior texel coordinates to copy (left column)
+    uint probeStart = uint(threadCoordinates.y / probeSideLength) * probeSideLength;
+    uint offset = probeSideLengthMinusOne - (threadCoordinates.y % probeSideLength);
+
+    copyCoordinates = uint2(threadCoordinates.x + 1, probeStart + offset);
+
+#if RTXGI_DDGI_DEBUG_BORDER_COPY_INDEXING && RTXGI_DDGI_DEBUG_FORMAT_IRRADIANCE
+    DDGIProbeUAV[threadCoordinates] = float4(threadCoordinates, copyCoordinates);
+    threadCoordinates.x += probeSideLengthMinusOne;
+    copyCoordinates = uint2(threadCoordinates.x - 1, probeStart + offset);
+    DDGIProbeUAV[threadCoordinates] = float4(threadCoordinates, copyCoordinates);
+    return;
+#endif
+
+    // Left column
+    DDGIProbeUAV[threadCoordinates] = DDGIProbeUAV[copyCoordinates];
+
+    // Compute the interior texel coordinate to copy (right column)
+    threadCoordinates.x += probeSideLengthMinusOne;
+    copyCoordinates = uint2(threadCoordinates.x - 1, probeStart + offset);
+
+    // Right column
+    DDGIProbeUAV[threadCoordinates] = DDGIProbeUAV[copyCoordinates];
+}
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/ProbeCommon.ush b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/ProbeCommon.ush
new file mode 100644
index 00000000000..b76329e94b4
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/ProbeCommon.ush
@@ -0,0 +1,548 @@
+/*
+* Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#ifndef RTXGI_DDGI_PROBE_COMMON_HLSL
+#define RTXGI_DDGI_PROBE_COMMON_HLSL
+
+#include "../Common.ush"
+#include "../../SDKDefines.ush"
+#include "../DDGIVolumeDefines.ush"
+//#include "../DDGIVolumeDescGPU.ush"
+
+#if RTXGI_DDGI_PROBE_RELOCATION || RTXGI_DDGI_PROBE_STATE_CLASSIFIER
+// The number of fixed rays that are used for probe relocation and classification.
+// These rays do not vary to produce temporally stable results during relocation and classification.
+#define RTXGI_DDGI_NUM_FIXED_RAYS 32
+#endif
+
+//------------------------------------------------------------------------
+// Probe Indexing Helpers
+//------------------------------------------------------------------------
+
+/**
+* Gets the number of probes on a horizontal plane in the active coordinate system.
+*/
+int DDGIGetProbesPerPlane(int3 probeGridCounts)
+{
+#if RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT || RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT
+    return (probeGridCounts.x * probeGridCounts.z);
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT_Z_UP || RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT_Z_UP
+    return (probeGridCounts.x * probeGridCounts.y);
+#endif
+}
+
+/**
+* Get the index of the horizontal plane that the thread coordinates map to in the active coordinate system.
+*/
+int DDGIGetPlaneIndex(uint2 threadCoords, int3 probeGridCounts, int probeNumTexels)
+{
+#if RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT || RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT || RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT_Z_UP
+    return int(threadCoords.x / (probeGridCounts.x * probeNumTexels));
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT_Z_UP
+    return int(threadCoords.x / (probeGridCounts.y * probeNumTexels));
+#endif
+}
+
+/**
+* Gets the index of a probe within a given horizontal plane in the active coordinate system.
+*/
+int DDGIGetProbeIndexInPlane(uint2 threadCoords, int planeIndex, int3 probeGridCounts, int probeNumTexels)
+{
+#if RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT || RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT || RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT_Z_UP
+    return int(threadCoords.x / probeNumTexels) - (planeIndex * probeGridCounts.x) + (probeGridCounts.x * int(threadCoords.y / probeNumTexels));
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT_Z_UP
+    return int(threadCoords.x / probeNumTexels) - (planeIndex * probeGridCounts.y) + (probeGridCounts.y * int(threadCoords.y / probeNumTexels));
+#endif
+}
+
+//------------------------------------------------------------------------
+// Octahedral Paramerization
+//------------------------------------------------------------------------
+
+/**
+* Compute the offset and state texel position for the given probeIndex.
+*/
+int2 DDGIGetProbeTexelPosition(int probeIndex, int3 probeGridCounts)
+{
+    // Compute the probe index for this thread
+#if RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT || RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT
+    return int2(probeIndex % (probeGridCounts.x * probeGridCounts.y), probeIndex / (probeGridCounts.x * probeGridCounts.y));
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT_Z_UP
+    return int2(probeIndex % (probeGridCounts.y * probeGridCounts.z), probeIndex / (probeGridCounts.y * probeGridCounts.z));
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT_Z_UP
+    return int2(probeIndex % (probeGridCounts.x * probeGridCounts.z), probeIndex / (probeGridCounts.x * probeGridCounts.z));
+#endif
+}
+
+/**
+* Computes the normalized texture coordinates of the given probe,
+* using the probe index, octant coordinates, probe grid counts,
+* and the number of texels used by a probe.
+*/
+#if RTXGI_DDGI_PROBE_SCROLL
+float2 DDGIGetProbeUV(uint probeIndex, float2 octantCoordinates, int3 probeGridCounts, int numTexels, int3 probeScrollOffsets)
+#else
+float2 DDGIGetProbeUV(uint probeIndex, float2 octantCoordinates, int3 probeGridCounts, int numTexels)
+#endif
+{
+    int probesPerPlane = DDGIGetProbesPerPlane(probeGridCounts);
+    int planeIndex = int(probeIndex / probesPerPlane);
+
+    float probeInteriorTexels = float(numTexels);
+    float probeTexels = (probeInteriorTexels + 2.f);
+
+#if RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT || RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT
+    int gridSpaceX = (probeIndex % probeGridCounts.x);
+    int gridSpaceY = (probeIndex / probeGridCounts.x);
+#if RTXGI_DDGI_PROBE_SCROLL
+    gridSpaceX = (gridSpaceX + probeScrollOffsets.x) % probeGridCounts.x;
+    gridSpaceY = (gridSpaceY + probeScrollOffsets.z) % probeGridCounts.z;
+    planeIndex = (planeIndex + probeScrollOffsets.y) % probeGridCounts.y;
+#endif
+    int x = gridSpaceX + (planeIndex * probeGridCounts.x);
+    int y = gridSpaceY % probeGridCounts.z;
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT_Z_UP
+    int gridSpaceX = (probeIndex % probeGridCounts.y);
+    int gridSpaceY = (probeIndex / probeGridCounts.y);
+#if RTXGI_DDGI_PROBE_SCROLL
+    gridSpaceX = (gridSpaceX + probeScrollOffsets.y) % probeGridCounts.y;
+    gridSpaceY = (gridSpaceY + probeScrollOffsets.x) % probeGridCounts.x;
+    planeIndex = (planeIndex + probeScrollOffsets.z) % probeGridCounts.z;
+#endif
+    int x = gridSpaceX + (planeIndex * probeGridCounts.y);
+    int y = gridSpaceY % probeGridCounts.x;
+#elif  RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT_Z_UP
+    int gridSpaceX = (probeIndex % probeGridCounts.x);
+    int gridSpaceY = (probeIndex / probeGridCounts.x);
+#if RTXGI_DDGI_PROBE_SCROLL
+    gridSpaceX = (gridSpaceX + probeScrollOffsets.x) % probeGridCounts.x;
+    gridSpaceY = (gridSpaceY + probeScrollOffsets.y) % probeGridCounts.y;
+    planeIndex = (planeIndex + probeScrollOffsets.z) % probeGridCounts.z;
+#endif
+    int x = gridSpaceX + (planeIndex * probeGridCounts.x);
+    int y = gridSpaceY % probeGridCounts.y;
+#endif
+
+#if RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT || RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT
+    float textureWidth = probeTexels * (probeGridCounts.x * probeGridCounts.y);
+    float textureHeight = probeTexels * probeGridCounts.z;
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT_Z_UP
+    float textureWidth = probeTexels * (probeGridCounts.y * probeGridCounts.z);
+    float textureHeight = probeTexels * probeGridCounts.x;
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT_Z_UP
+    float textureWidth = probeTexels * (probeGridCounts.x * probeGridCounts.z);
+    float textureHeight = probeTexels * probeGridCounts.y;
+#endif
+
+    float2 uv = float2(x * probeTexels, y * probeTexels) + (probeTexels * 0.5f);
+    uv += octantCoordinates.xy * (probeInteriorTexels * 0.5f);
+    uv /= float2(textureWidth, textureHeight);
+    return uv;
+}
+
+/**
+* Computes normalized octahedral coordinates for the given thread/pixel coordinates.
+* Maps the top left texel to (-1,-1).
+*/
+float2 DDGIGetNormalizedOctahedralCoordinates(int2 threadCoords, int numTexels)
+{
+    // Map thread coordinates to a normalized octahedral space
+    float2 octahedralTexelCoord = float2(threadCoords.x % numTexels, threadCoords.y % numTexels);
+
+    // Move to the center of a texel
+    octahedralTexelCoord.xy += 0.5f;
+
+    // Normalize
+    octahedralTexelCoord.xy /= float(numTexels);
+
+    // Shift to [-1, 1);
+    octahedralTexelCoord *= 2.f;
+    octahedralTexelCoord -= float2(1.f, 1.f);
+
+    return octahedralTexelCoord;
+}
+
+/**
+* Computes the normalized octahedral direction that corresponds to the
+* given normalized coordinates on the [-1, 1] square.
+* The opposite of DDGIGetOctahedralCoordinates().
+*/
+float3 DDGIGetOctahedralDirection(float2 coords)
+{
+    float3 direction = float3(coords.x, coords.y, 1.f - abs(coords.x) - abs(coords.y));
+    if (direction.z < 0.f)
+    {
+        direction.xy = (1.f - abs(direction.yx)) * RTXGISignNotZero(direction.xy);
+    }
+    return normalize(direction);
+}
+
+/**
+* Computes the octant coordinates in the normalized [-1, 1] square, for the given a unit direction vector.
+* The opposite of DDGIGetOctahedralDirection().
+*/
+float2 DDGIGetOctahedralCoordinates(float3 direction)
+{
+    float l1norm = abs(direction.x) + abs(direction.y) + abs(direction.z);
+    float2 uv = direction.xy * (1.f / l1norm);
+    if (direction.z < 0.f)
+    {
+        uv = (1.f - abs(uv.yx)) * RTXGISignNotZero(uv.xy);
+    }
+    return uv;
+}
+
+//------------------------------------------------------------------------
+// Probe Ray Direction
+//------------------------------------------------------------------------
+
+/*
+* Computes a low discrepancy spherically distributed direction on the unit sphere,
+* for the given index in a set of samples. Each direction is unique in
+* the set, but the set of directions is always the same.
+*/
+float3 DDGISphericalFibonacci(float index, float numSamples)
+{
+    const float b = (sqrt(5.f) * 0.5f + 0.5f) - 1.f;
+    float phi = RTXGI_2PI * frac(index * b);
+    float cosTheta = 1.f - (2.f * index + 1.f) * (1.f / numSamples);
+    float sinTheta = sqrt(saturate(1.f - (cosTheta * cosTheta)));
+
+    return float3((cos(phi) * sinTheta), (sin(phi) * sinTheta), cosTheta);
+}
+
+/**
+* Computes a ray direction for the given ray index.
+* Generate a spherically distributed normalized ray direction, then apply the given rotation transformation.
+*/
+float3 DDGIGetProbeRayDirection(int rayIndex, int numRaysPerProbe, float4x4 rotationTransform)
+{
+#if RTXGI_DDGI_PROBE_RELOCATION || RTXGI_DDGI_PROBE_STATE_CLASSIFIER
+    bool useFixedRays = rayIndex < RTXGI_DDGI_NUM_FIXED_RAYS;
+    int  adjustedRayIndex = useFixedRays ? rayIndex : rayIndex - RTXGI_DDGI_NUM_FIXED_RAYS;
+    int  adjustedNumRays = useFixedRays ? min(RTXGI_DDGI_NUM_FIXED_RAYS, numRaysPerProbe) : numRaysPerProbe - RTXGI_DDGI_NUM_FIXED_RAYS;
+
+    float3 direction = DDGISphericalFibonacci(adjustedRayIndex, adjustedNumRays);
+    if (useFixedRays)
+    {
+        // Don't rotate the fixed rays so that relocation/classification is temporally stable
+        return normalize(direction);
+    }
+#else
+    float3 direction = DDGISphericalFibonacci(rayIndex, numRaysPerProbe);
+#endif
+    return normalize(mul(float4(direction, 0.f), rotationTransform).xyz);
+}
+
+//------------------------------------------------------------------------
+// Probe Indexing
+//------------------------------------------------------------------------
+
+/**
+* Computes the probe index from 2D texture coordinates and probe counts.
+*/
+int DDGIGetProbeIndex(int2 texcoord, int3 probeGridCounts)
+{
+    // Compute the probe index for this thread
+#if RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT || RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT
+    return texcoord.x + (texcoord.y * (probeGridCounts.x * probeGridCounts.y));
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT_Z_UP
+    return texcoord.x + (texcoord.y * (probeGridCounts.y * probeGridCounts.z));
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT_Z_UP
+    return texcoord.x + (texcoord.y * (probeGridCounts.x * probeGridCounts.z));
+#endif
+}
+
+/**
+* Computes the probe index from 3D grid coordinates and probe counts.
+* The opposite of DDGIGetProbeCoords().
+*/
+int DDGIGetProbeIndex(int3 probeCoords, int3 probeGridCounts)
+{
+#if RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT || RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT
+    return probeCoords.x + (probeGridCounts.x * probeCoords.z) + (probeGridCounts.x * probeGridCounts.z) * probeCoords.y;
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT_Z_UP
+    return probeCoords.y + (probeGridCounts.y * probeCoords.x) + (probeGridCounts.y * probeGridCounts.x) * probeCoords.z;
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT_Z_UP
+    return probeCoords.x + (probeGridCounts.x * probeCoords.y) + (probeGridCounts.x * probeGridCounts.y) * probeCoords.z;
+#endif
+}
+
+/**
+* Computes the probe index from the given thread coordinates of the irradiance and distance textures
+* the number of probes in the volume, and the number of texels per probe.
+*/
+int DDGIGetProbeIndex(uint2 threadCoords, int3 probeGridCounts, int probeNumTexels)
+{
+    int probesPerPlane = DDGIGetProbesPerPlane(probeGridCounts);
+    int planeIndex = DDGIGetPlaneIndex(threadCoords, probeGridCounts, probeNumTexels);
+    int probeIndexInPlane = DDGIGetProbeIndexInPlane(threadCoords, planeIndex, probeGridCounts, probeNumTexels);
+
+    return (planeIndex * probesPerPlane) + probeIndexInPlane;
+}
+
+/**
+* Reverses the above DDGIGetProbeIndex(threadCoords, probeGridCounts, probeNumTexels)
+*/
+uint2 DDGIGetThreadBaseCoords(int probeIndex, int3 probeGridCounts, int probeNumTexels)
+{
+    int probesPerPlane = DDGIGetProbesPerPlane(probeGridCounts);
+    int planeIndex = probeIndex / probesPerPlane;
+    int probeIndexInPlane = probeIndex % probesPerPlane;
+
+    // Get the top left texel for a given probe
+#if RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT || RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT || RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT_Z_UP
+    int planeWidthInProbes = probeGridCounts.x;
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT_Z_UP
+    int planeWidthInProbes = probeGridCounts.y;
+#endif
+
+    int2 probeCoordInPlane = int2(probeIndexInPlane % planeWidthInProbes, probeIndexInPlane / planeWidthInProbes);
+    int  baseCoordX = (planeWidthInProbes * planeIndex + probeCoordInPlane.x) * probeNumTexels;
+    int  baseCoordY = probeCoordInPlane.y * probeNumTexels;
+    return uint2(baseCoordX, baseCoordY);
+}
+
+/**
+* Computes the 3D grid coordinates for the probe at the given probe index.
+* The opposite of DDGIGetProbeIndex().
+*/
+int3 DDGIGetProbeCoords(int probeIndex, int3 probeGridCounts)
+{
+    int3 probeCoords;
+
+#if RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT || RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT
+    probeCoords.x = probeIndex % probeGridCounts.x;
+    probeCoords.y = probeIndex / (probeGridCounts.x * probeGridCounts.z);
+    probeCoords.z = (probeIndex / probeGridCounts.x) % probeGridCounts.z;
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT_Z_UP
+    probeCoords.x = (probeIndex / probeGridCounts.y) % probeGridCounts.x;
+    probeCoords.y = probeIndex % probeGridCounts.y;
+    probeCoords.z = probeIndex / (probeGridCounts.x * probeGridCounts.y);
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT_Z_UP
+    probeCoords.x = probeIndex % probeGridCounts.x;
+    probeCoords.y = (probeIndex / probeGridCounts.x) % probeGridCounts.y;
+    probeCoords.z = probeIndex / (probeGridCounts.y * probeGridCounts.x);
+#endif
+
+    return probeCoords;
+}
+
+/**
+* Computes the 3D grid coordinates of the base probe (i.e. floor of xyz) of the 8-probe
+* cube that surrounds the given world space position. The other seven probes are offset
+* by 0 or 1 in grid space along each axis.
+*/
+int3 DDGIGetBaseProbeGridCoords(float3 worldPosition, float3 origin, float4 rotation, int3 probeGridCounts, float3 probeGridSpacing)
+{
+    float3 position = worldPosition - origin;
+    position = RTXGIQuaternionRotate(position, RTXGIQuaternionConjugate(rotation));
+
+    // Shift from [-n/2, n/2] to [0, n]
+    position += (probeGridSpacing * (probeGridCounts - 1)) * 0.5f;
+
+    int3 probeCoords = int3(position / probeGridSpacing);
+
+    // Clamp to [0, probeGridCounts - 1]
+    // Snaps positions outside of grid to the grid edge
+    probeCoords = clamp(probeCoords, int3(0, 0, 0), (probeGridCounts - int3(1, 1, 1)));
+
+    return probeCoords;
+}
+
+/**
+* Computes the world space position of a probe at the given 3D grid coordinates.
+*/
+float3 DDGIGetProbeWorldPosition(int3 probeCoords, float3 origin, float4 rotation, int3 probeGridCounts, float3 probeGridSpacing)
+{
+    // Multiply the grid coordinates by the grid spacing
+    float3 probeGridWorldPosition = (probeCoords * probeGridSpacing);
+
+    // Shift the grid by half of each axis extent to center the volume about its origin
+    float3 probeGridShift = (probeGridSpacing * (probeGridCounts - 1)) * 0.5f;
+
+    // Compute the probe's world position
+    float3 probeWorldPosition = probeGridWorldPosition - probeGridShift;
+    probeWorldPosition = RTXGIQuaternionRotate(probeWorldPosition, rotation);
+    probeWorldPosition += origin;
+    return probeWorldPosition;
+}
+
+/*
+* Computes the world space position of the probe at the given probe index (without the probe offsets).
+*/
+float3 DDGIGetProbeWorldPosition(int probeIndex, float3 origin, float4 rotation, int3 probeGridCounts, float3 probeGridSpacing)
+{
+    float3 probeCoords = DDGIGetProbeCoords(probeIndex, probeGridCounts);
+    return DDGIGetProbeWorldPosition(probeCoords, origin, rotation, probeGridCounts, probeGridSpacing);
+}
+
+//------------------------------------------------------------------------
+// Probe Relocation
+//------------------------------------------------------------------------
+
+#if RTXGI_DDGI_PROBE_RELOCATION
+
+/*
+* Reads the probe offset and transforms it into a world space offset.
+*/
+float3 DDGIDecodeProbeOffset(int2 probeOffsetTexcoord, float3 probeGridSpacing, RWTexture2D<float4> probeOffsets)
+{
+    return probeOffsets[probeOffsetTexcoord].xyz * probeGridSpacing;
+}
+float3 DDGIDecodeProbeOffset(int2 probeOffsetTexcoord, float3 probeGridSpacing, Texture2D<float4> probeOffsets)
+{
+    return probeOffsets.Load(int3(probeOffsetTexcoord, 0)).xyz * probeGridSpacing;
+}
+
+/*
+* Normalizes the world space offset and writes it to the probe offset texture.
+* Probe Position Preprocess effectively limits this range to [0.f, 0.45f).
+*/
+void DDGIEncodeProbeOffset(int2 probeOffsetTexcoord, float3 probeGridSpacing, float3 wsOffset, RWTexture2D<float4> probeOffsets)
+{
+    probeOffsets[probeOffsetTexcoord] = float4(wsOffset / probeGridSpacing, 0.0f);
+}
+
+/*
+* Computes the world space position of a probe at the given probe index, including the probe's offset value.
+*/
+float3 DDGIGetProbeWorldPositionWithOffset(int probeIndex, float3 origin, float4 rotation, int3 probeGridCounts, float3 probeGridSpacing, RWTexture2D<float4> probeOffsets)
+{
+#if RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT || RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT
+    int textureWidth = (probeGridCounts.x * probeGridCounts.y);
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT_Z_UP
+    int textureWidth = (probeGridCounts.y * probeGridCounts.z);
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT_Z_UP
+    int textureWidth = (probeGridCounts.x * probeGridCounts.z);
+#endif
+
+    // Find the texture coords of the probe in the offsets texture
+    int2 offsetTexcoords = int2(probeIndex % textureWidth, probeIndex / textureWidth);
+    return DDGIDecodeProbeOffset(offsetTexcoords, probeGridSpacing, probeOffsets) + DDGIGetProbeWorldPosition(probeIndex, origin, rotation, probeGridCounts, probeGridSpacing);
+}
+
+/*
+* Computes the world space position of a probe at the given probe index, including the probe's offset value.
+* Uses a Texture2D instead of a RWTexture2D.
+*/
+float3 DDGIGetProbeWorldPositionWithOffset(int probeIndex, float3 origin, float4 rotation, int3 probeGridCounts, float3 probeGridSpacing, Texture2D<float4> probeOffsets)
+{
+#if RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT || RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT
+    int textureWidth = (probeGridCounts.x * probeGridCounts.y);
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT_Z_UP
+    int textureWidth = (probeGridCounts.y * probeGridCounts.z);
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT_Z_UP
+    int textureWidth = (probeGridCounts.x * probeGridCounts.z);
+#endif
+
+    // Find the texture coords of the probe in the offsets texture
+    int2 offsetTexcoords = int2(probeIndex % textureWidth, probeIndex / textureWidth);
+    return DDGIDecodeProbeOffset(offsetTexcoords, probeGridSpacing, probeOffsets) + DDGIGetProbeWorldPosition(probeIndex, origin, rotation, probeGridCounts, probeGridSpacing);
+}
+
+/**
+* Compute the world space position from the 3D grid coordinates, including the probe's offset value.
+*/
+float3 DDGIGetProbeWorldPositionWithOffset(int3 probeCoords, float3 origin, float4 rotation, int3 probeGridCounts, float3 probeGridSpacing, RWTexture2D<float4> probeOffsets)
+{
+    int probeIndex = DDGIGetProbeIndex(probeCoords, probeGridCounts);
+    return DDGIGetProbeWorldPositionWithOffset(probeIndex, origin, rotation, probeGridCounts, probeGridSpacing, probeOffsets);
+}
+
+#endif /* RTXGI_DDGI_PROBE_RELOCATION */
+
+//------------------------------------------------------------------------
+// Probe State Classification
+//------------------------------------------------------------------------
+
+#if RTXGI_DDGI_PROBE_STATE_CLASSIFIER
+
+#define PROBE_STATE_ACTIVE      0   // probe shoots rays and may be sampled by a front facing surface or another probe (recursive irradiance)
+#define PROBE_STATE_INACTIVE    1   // probe doesn't need to shoot rays, it isn't near a front facing surface or another active probe
+
+#endif /* RTXGI_DDGI_PROBE_STATE_CLASSIFIER */
+
+//------------------------------------------------------------------------
+// Volume Scrolling Movement
+//------------------------------------------------------------------------
+
+#if RTXGI_DDGI_PROBE_SCROLL
+
+/**
+* Gets the index of a probe that is offset from a base probe
+*/
+int DDGIGetProbeIndexOffset(int baseProbeIndex, int3 probeGridCounts, int3 probeScrollOffsets)
+{
+    int3 probeGridCoord = DDGIGetProbeCoords(baseProbeIndex, probeGridCounts);
+    int3 offsetProbeGridCoord = (probeGridCoord + probeScrollOffsets) % probeGridCounts;
+    int  offsetProbeIndex = DDGIGetProbeIndex(offsetProbeGridCoord, probeGridCounts);
+    return offsetProbeIndex;
+}
+
+#if RTXGI_DDGI_PROBE_RELOCATION
+// Modified versions of the GetProbeWorldPositionWithOffset functions that account for probeScrollOffsets
+
+/*
+* Computes the world space position of a probe at the given probe index, including the probe's offset value.
+*/
+float3 DDGIGetProbeWorldPositionWithOffset(int probeIndex, float3 origin, float4 rotation, int3 probeGridCounts, float3 probeGridSpacing, int3 probeScrollOffsets, RWTexture2D<float4> probeOffsets)
+{
+#if RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT || RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT
+    int textureWidth = (probeGridCounts.x * probeGridCounts.y);
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT_Z_UP
+    int textureWidth = (probeGridCounts.y * probeGridCounts.z);
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT_Z_UP
+    int textureWidth = (probeGridCounts.x * probeGridCounts.z);
+#endif
+
+    // Find the texture coords of the probe in the offsets texture
+    int storageProbeIndex = DDGIGetProbeIndexOffset(probeIndex, probeGridCounts, probeScrollOffsets);
+    int2 offsetTexcoords = int2(storageProbeIndex % textureWidth, storageProbeIndex / textureWidth);
+    // the key observation here is that the probe offset lookup needs to compensate for the scroll offset, but GetProbeWorldPosition should use the original probeIndex
+    // this requirement prevents us from just passing in a compensated probeIndex to the normalGetProbeWorldPositionWithOffset function
+    return DDGIDecodeProbeOffset(offsetTexcoords, probeGridSpacing, probeOffsets) + DDGIGetProbeWorldPosition(probeIndex, origin, rotation, probeGridCounts, probeGridSpacing);
+}
+
+/*
+* Computes the world space position of a probe at the given probe index, including the probe's offset value.
+* Uses a Texture2D instead of a RWTexture2D
+*/
+float3 DDGIGetProbeWorldPositionWithOffset(int probeIndex, float3 origin, float4 rotation, int3 probeGridCounts, float3 probeGridSpacing, int3 probeScrollOffsets, Texture2D<float4> probeOffsets)
+{
+#if RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT || RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT
+    int textureWidth = (probeGridCounts.x * probeGridCounts.y);
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_LEFT_Z_UP
+    int textureWidth = (probeGridCounts.y * probeGridCounts.z);
+#elif RTXGI_COORDINATE_SYSTEM == RTXGI_COORDINATE_SYSTEM_RIGHT_Z_UP
+    int textureWidth = (probeGridCounts.x * probeGridCounts.z);
+#endif
+
+    // Find the texture coords of the probe in the offsets texture
+    int storageProbeIndex = DDGIGetProbeIndexOffset(probeIndex, probeGridCounts, probeScrollOffsets);
+    int2 offsetTexcoords = int2(storageProbeIndex % textureWidth, storageProbeIndex / textureWidth);
+    // the key observation here is that the probe offset lookup needs to compensate for the scroll offset, but GetProbeWorldPosition should use the original probeIndex
+    // this requirement prevents us from just passing in a compensated probeIndex to the normalGetProbeWorldPositionWithOffset function
+    return DDGIDecodeProbeOffset(offsetTexcoords, probeGridSpacing, probeOffsets) + DDGIGetProbeWorldPosition(probeIndex, origin, rotation, probeGridCounts, probeGridSpacing);
+}
+
+/**
+* Compute the world space position from the 3D grid coordinates, including the probe's offset value.
+*/
+float3 DDGIGetProbeWorldPositionWithOffset(int3 probeCoords, float3 origin, float4 rotation, int3 probeGridCounts, float3 probeGridSpacing, int3 probeScrollOffsets, RWTexture2D<float4> probeOffsets)
+{
+    int probeIndex = DDGIGetProbeIndex(probeCoords, probeGridCounts);
+    return DDGIGetProbeWorldPositionWithOffset(probeIndex, origin, rotation, probeGridCounts, probeGridSpacing, probeScrollOffsets, probeOffsets);
+}
+#endif
+
+#endif /* RTXGI_DDGI_PROBE_SCROLL */
+
+#endif /* RTXGI_DDGI_PROBE_COMMON_HLSL */
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/ProbeRelocationCS.usf b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/ProbeRelocationCS.usf
new file mode 100644
index 00000000000..7718d8e9981
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/ProbeRelocationCS.usf
@@ -0,0 +1,159 @@
+/*
+* Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#include "/Engine/Private/Common.ush"
+
+// Below is Adapted from ProbeBorderUpdateCS.hlsl in the SDK aiming for minimal changes to help future merges.
+
+#include "ProbeCommon.ush"
+
+float    ProbeDistanceScale;
+float3   DDGIVolume_probeGridSpacing;
+int3     DDGIVolume_probeGridCounts;
+int      DDGIVolume_numRaysPerProbe;
+float    DDGIVolume_probeBackfaceThreshold;
+float4x4 DDGIVolume_probeRayRotationTransform;
+float    DDGIVolume_probeMinFrontfaceDistance;
+int3     DDGIVolume_probeScrollOffsets;
+int      DDGIVolume_ProbeIndexStart;
+int      DDGIVolume_ProbeIndexCount;
+
+RWTexture2D<float4> DDGIProbeRTRadianceUAV;
+RWTexture2D<float4> DDGIProbeOffsets;
+
+[numthreads(8, 4, 1)]
+void DDGIProbeRelocationCS(uint3 DispatchThreadID : SV_DispatchThreadID, uint GroupIndex : SV_GroupIndex)
+{
+    // Compute the probe index for this thread
+    int probeIndex = DDGIGetProbeIndex(DispatchThreadID.xy, DDGIVolume_probeGridCounts);
+
+    // Early out if the thread maps past the number of probes
+    int numProbes = DDGIVolume_probeGridCounts.x * DDGIVolume_probeGridCounts.y * DDGIVolume_probeGridCounts.z;
+    if (probeIndex >= numProbes)
+    {
+        return;
+    }
+
+    // Handle round robin updating.
+    // If this probe is outside of the window for updating, bail out.
+    {
+        int numProbes = DDGIVolume_probeGridCounts.x * DDGIVolume_probeGridCounts.y * DDGIVolume_probeGridCounts.z;
+        int probeRRIndex = (probeIndex < DDGIVolume_ProbeIndexStart) ? probeIndex + numProbes : probeIndex;
+        if (probeRRIndex >= DDGIVolume_ProbeIndexStart + DDGIVolume_ProbeIndexCount)
+            return;
+    }
+
+#if RTXGI_DDGI_PROBE_SCROLL
+    int storageProbeIndex = DDGIGetProbeIndexOffset(probeIndex, DDGIVolume_probeGridCounts, DDGIVolume_probeScrollOffsets);
+#else
+    int storageProbeIndex = probeIndex;
+#endif
+    uint2 offsetTexelPosition = DDGIGetProbeTexelPosition(storageProbeIndex, DDGIVolume_probeGridCounts);
+
+    // Get the current world position offset
+    float3 currentOffset = DDGIDecodeProbeOffset(offsetTexelPosition, DDGIVolume_probeGridSpacing, DDGIProbeOffsets);
+
+    // Initialize
+    int   closestBackfaceIndex = -1;
+    int   closestFrontfaceIndex = -1;
+    int   farthestFrontfaceIndex = -1;
+    float closestBackfaceDistance = 1e27f;
+    float closestFrontfaceDistance = 1e27f;
+    float farthestFrontfaceDistance = 0.f;
+    float backfaceCount = 0.f;
+
+    // Get the number of ray samples to inspect
+    int numRays = min(DDGIVolume_numRaysPerProbe, RTXGI_DDGI_NUM_FIXED_RAYS);
+
+    // Iterate over the rays cast for this probe to find the number of backfaces and closest/farthest distances to the probe
+    for (int rayIndex = 0; rayIndex < numRays; rayIndex++)
+    {
+        int2 rayTexCoord = int2(rayIndex, probeIndex);
+
+        // Load the hit distance from the ray cast
+#if RTXGI_DDGI_DEBUG_FORMAT_RADIANCE
+        float hitDistance = DDGIProbeRTRadianceUAV[rayTexCoord].a;
+#else
+        float hitDistance = DDGIProbeRTRadianceUAV[rayTexCoord].g;
+#endif
+
+        // Found a backface
+        if (hitDistance < 0.f)
+        {
+            backfaceCount++;
+
+            // Negate the hit distance on a backface hit and scale back to the full distance
+            hitDistance = hitDistance * -5.f;
+            if (hitDistance < closestBackfaceDistance)
+            {
+                // Make up for the shortening of backfaces
+                closestBackfaceDistance = hitDistance;
+                closestBackfaceIndex = rayIndex;
+            }
+        }
+        else if (hitDistance > 0.f)
+        {
+            // Found a frontface
+            if (hitDistance < closestFrontfaceDistance)
+            {
+                closestFrontfaceDistance = hitDistance;
+                closestFrontfaceIndex = rayIndex;
+            }
+            else if (hitDistance > farthestFrontfaceDistance)
+            {
+                farthestFrontfaceDistance = hitDistance;
+                farthestFrontfaceIndex = rayIndex;
+            }
+        }
+    }
+
+    float3 fullOffset = float3(1e27f, 1e27f, 1e27f);
+
+    if (closestBackfaceIndex != -1 && (float(backfaceCount) / numRays) > DDGIVolume_probeBackfaceThreshold)
+    {
+        // If there is a close backface AND more than 25% of the hit geometry are backfacing, assume the probe is inside geometry
+        float3 closestBackfaceDirection = closestBackfaceDistance * normalize(DDGIGetProbeRayDirection(closestBackfaceIndex, DDGIVolume_numRaysPerProbe, DDGIVolume_probeRayRotationTransform));
+        fullOffset = currentOffset + closestBackfaceDirection * (ProbeDistanceScale + 1.f);
+    }
+    else if (closestFrontfaceDistance < DDGIVolume_probeMinFrontfaceDistance)
+    {
+        // Don't move the probe if moving towards the farthest frontface will also bring us closer to the nearest frontface
+        float3 closestFrontfaceDirection = normalize(DDGIGetProbeRayDirection(closestFrontfaceIndex, DDGIVolume_numRaysPerProbe, DDGIVolume_probeRayRotationTransform));
+        float3 farthestFrontfaceDirection = normalize(DDGIGetProbeRayDirection(farthestFrontfaceIndex, DDGIVolume_numRaysPerProbe, DDGIVolume_probeRayRotationTransform));
+
+        if (dot(closestFrontfaceDirection, farthestFrontfaceDirection) <= 0.f)
+        {
+            // Ensures the probe never moves through the farthest frontface
+            farthestFrontfaceDistance *= min(farthestFrontfaceDistance, 1.f);
+
+            // ProbeDistanceScale decreases from 1.f - 0.f for backface movement
+            // It can go to 0 to ensure some movement away from close surfaces
+            fullOffset = currentOffset + farthestFrontfaceDirection * ProbeDistanceScale;
+        }
+    }
+    else if (closestFrontfaceDistance > DDGIVolume_probeMinFrontfaceDistance + ProbeDistanceScale)
+    {
+        // Probe isn't near anything, try to move it back towards zero offset
+        float moveBackMargin = min(closestFrontfaceDistance - DDGIVolume_probeMinFrontfaceDistance, length(currentOffset));
+        float3 moveBackDirection = normalize(-currentOffset);
+        fullOffset = currentOffset + (moveBackMargin * moveBackDirection);
+    }
+
+    // Absolute maximum distance that probe could be moved should satisfy ellipsoid equation:
+    // x^2 / probeGridSpacing.x^2 + y^2 / probeGridSpacing.y^2 + z^2 / probeGridSpacing.z^2 < (0.5)^2
+    // Clamp to less than maximum distance to avoid degenerate cases
+    float3 normalizedOffset = fullOffset / DDGIVolume_probeGridSpacing;
+    if (dot(normalizedOffset, normalizedOffset) < 0.2025f) // 0.45 * 0.45 == 0.2025
+    {
+        currentOffset = fullOffset;
+    }
+
+    DDGIEncodeProbeOffset(offsetTexelPosition.xy, DDGIVolume_probeGridSpacing, currentOffset, DDGIProbeOffsets);
+}
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/ProbeStateClassifierCS.usf b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/ProbeStateClassifierCS.usf
new file mode 100644
index 00000000000..c712e55db0d
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDK/ddgi/ProbeStateClassifierCS.usf
@@ -0,0 +1,105 @@
+/*
+* Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#include "/Engine/Private/Common.ush"
+
+// Below is Adapted from ProbeStateClassifierCS.hlsl in the SDK aiming for minimal changes to help future merges.
+
+#include "ProbeCommon.ush"
+
+RWTexture2D<float4> DDGIProbeRTRadianceUAV;
+RWTexture2D<uint> DDGIProbeStates;
+
+float3   DDGIVolume_probeGridSpacing;
+int3     DDGIVolume_probeGridCounts;
+int      DDGIVolume_numRaysPerProbe;
+float    DDGIVolume_probeBackfaceThreshold;
+int3     DDGIVolume_probeScrollOffsets;
+int      DDGIVolume_ProbeIndexStart;
+int      DDGIVolume_ProbeIndexCount;
+
+[numthreads(8, 4, 1)]
+void DDGIProbeStateClassifierCS(uint3 DispatchThreadID : SV_DispatchThreadID, uint GroupIndex : SV_GroupIndex)
+{
+    // Compute the probe index for this thread
+    int probeIndex = DDGIGetProbeIndex(DispatchThreadID.xy, DDGIVolume_probeGridCounts);
+
+    // Early out if the thread maps past the number of probes
+    int numTotalProbes = DDGIVolume_probeGridCounts.x * DDGIVolume_probeGridCounts.y * DDGIVolume_probeGridCounts.z;
+    if (probeIndex >= numTotalProbes)
+    {
+        return;
+    }
+
+    // Handle round robin updating.
+    // If this probe is outside of the window for updating, bail out.
+    {
+        int numProbes = DDGIVolume_probeGridCounts.x * DDGIVolume_probeGridCounts.y * DDGIVolume_probeGridCounts.z;
+        int probeRRIndex = (probeIndex < DDGIVolume_ProbeIndexStart) ? probeIndex + numProbes : probeIndex;
+        if (probeRRIndex >= DDGIVolume_ProbeIndexStart + DDGIVolume_ProbeIndexCount)
+            return;
+    }
+
+#if RTXGI_DDGI_PROBE_SCROLL
+    int storageProbeIndex = DDGIGetProbeIndexOffset(probeIndex, DDGIVolume_probeGridCounts, DDGIVolume_probeScrollOffsets);
+#else
+    int storageProbeIndex = probeIndex;
+#endif
+    uint2 offsetTexelPosition = DDGIGetProbeTexelPosition(storageProbeIndex, DDGIVolume_probeGridCounts);
+
+    // Compute the bounds used to check for surrounding geometry
+    float3 geometryBounds = DDGIVolume_probeGridSpacing;
+
+    // Conservatively increase the geometry search area
+    geometryBounds *= 2.f;
+
+#if RTXGI_DDGI_PROBE_RELOCATION
+    // A conservative bound that assumes the maximum offset value for this probe
+    geometryBounds *= 1.45f;
+#endif
+
+    float closestFrontfaceDistance = 1e27f;
+    int   backfaceCount = 0;
+
+    // Get the number of ray samples to inspect
+    int numRays = min(DDGIVolume_numRaysPerProbe, RTXGI_DDGI_NUM_FIXED_RAYS);
+
+    // Iterate over the rays cast for this probe
+    for (int rayIndex = 0; rayIndex < numRays; rayIndex++)
+    {
+        int2 rayTexCoord = int2(rayIndex, probeIndex);
+
+        // Load the hit distance from the ray cast
+#if RTXGI_DDGI_DEBUG_FORMAT_RADIANCE
+        float hitDistance = DDGIProbeRTRadianceUAV[rayTexCoord].a;
+#else
+        float hitDistance = DDGIProbeRTRadianceUAV[rayTexCoord].g;
+#endif
+
+        // Don't include backface hit distances
+        if (hitDistance < 0.f)
+        {
+            backfaceCount++;
+            continue;
+        }
+
+        // Store the closest front face hit distance
+        closestFrontfaceDistance = min(closestFrontfaceDistance, hitDistance);
+    }
+
+    // If this probe is near geometry, wake it up if the backface percentage is above probeBackfaceThreshold
+    if (all(closestFrontfaceDistance <= geometryBounds) && (float(backfaceCount) / numRays < DDGIVolume_probeBackfaceThreshold))
+    {
+        DDGIProbeStates[offsetTexelPosition] = PROBE_STATE_ACTIVE;
+        return;
+    }
+
+    DDGIProbeStates[offsetTexelPosition] = PROBE_STATE_INACTIVE;
+}
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDKDefines.ush b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDKDefines.ush
new file mode 100644
index 00000000000..208cad10686
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/SDKDefines.ush
@@ -0,0 +1,31 @@
+/*
+* Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#ifndef RTXGI_DEFINES_H
+#define RTXGI_DEFINES_H
+
+#ifndef RTXGI_NAME_D3D_OBJECTS
+#define RTXGI_NAME_D3D_OBJECTS 1
+#endif
+
+#ifndef RTXGI_PERF_MARKERS
+#define RTXGI_PERF_MARKERS 1
+#endif
+
+#define RTXGI_COORDINATE_SYSTEM_LEFT 0
+#define RTXGI_COORDINATE_SYSTEM_LEFT_Z_UP 1
+#define RTXGI_COORDINATE_SYSTEM_RIGHT 2
+#define RTXGI_COORDINATE_SYSTEM_RIGHT_Z_UP 3
+
+#ifndef RTXGI_COORDINATE_SYSTEM
+#define RTXGI_COORDINATE_SYSTEM RTXGI_COORDINATE_SYSTEM_LEFT_Z_UP
+#endif
+
+#endif /* RTXGI_DEFINES_H */
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/VisualizeDDGIProbes.usf b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/VisualizeDDGIProbes.usf
new file mode 100644
index 00000000000..35e69bc8bca
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Shaders/Private/VisualizeDDGIProbes.usf
@@ -0,0 +1,152 @@
+/*
+* Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+// These are turned on/off together in the plugin settings. Turned on if the lighting values are too large to be stored (like in extended radiance mode)
+#define RTXGI_DDGI_DEBUG_FORMAT_IRRADIANCE RTXGI_DDGI_DEBUG_FORMAT_RADIANCE
+
+#include "/Engine/Public/Platform.ush"
+
+#include "/Plugin/RTXGI/Private/SDK/ddgi/ProbeCommon.ush"
+
+Texture2D<float4> ProbeIrradianceTexture;
+Texture2D<float4> ProbeDistanceTexture;
+Texture2D<float4> ProbeOffsets;
+RWTexture2D<uint> ProbeStates;
+SamplerState ProbeSampler;
+
+int Mode;
+float ProbeRadius;
+float DepthScale;
+int VolumeProbeNumIrradianceTexels;
+int VolumeProbeNumDistanceTexels;
+float VolumeProbeIrradianceEncodingGamma;
+float3 VolumePosition;
+float4 VolumeRotation;
+float3 VolumeProbeGridSpacing;
+int3   VolumeProbeGridCounts;
+float4x4 WorldToClip;
+float3 CameraPosition;
+float PreExposure;
+uint ShouldUsePreExposure;
+int3 VolumeProbeScrollOffsets;
+float IrradianceScalar;
+
+struct FVisualizeDDGIProbesVSToPS
+{
+    nointerpolation float3 ProbeOrigin : TEXCOORD0;
+    nointerpolation uint InstanceId : TEXCOORD1;
+    float4 WorldPosition : TEXCOORD2;
+};
+
+void VisualizeDDGIProbesVS(
+    in float4 InPosition : ATTRIBUTE0,
+    uint InstanceId : SV_InstanceID,
+    out FVisualizeDDGIProbesVSToPS Output,
+    out float4 OutPosition : SV_POSITION
+)
+{
+#if RTXGI_DDGI_PROBE_RELOCATION
+    #if RTXGI_DDGI_PROBE_SCROLL
+        float3 Translation = DDGIGetProbeWorldPositionWithOffset(InstanceId, VolumePosition, VolumeRotation, VolumeProbeGridCounts, VolumeProbeGridSpacing, VolumeProbeScrollOffsets, ProbeOffsets);
+    #else
+        float3 Translation = DDGIGetProbeWorldPositionWithOffset(InstanceId, VolumePosition, VolumeRotation, VolumeProbeGridCounts, VolumeProbeGridSpacing, ProbeOffsets);
+    #endif
+#else
+    float3 Translation = DDGIGetProbeWorldPosition(InstanceId, VolumePosition, VolumeRotation, VolumeProbeGridCounts, VolumeProbeGridSpacing);
+#endif
+
+    float4x4 Transform = {	ProbeRadius, 0.f, 0.f, 0.f,
+                            0.f, ProbeRadius, 0.f, 0.f,
+                            0.f, 0.f, ProbeRadius, 0.f,
+                            Translation.x, Translation.y, Translation.z, 1.f};
+
+    Output.ProbeOrigin = Translation;
+    Output.InstanceId = InstanceId;
+    Output.WorldPosition = float4(InPosition.xyz, 1.f);
+    Output.WorldPosition = mul(Output.WorldPosition, Transform);
+
+    OutPosition = mul(Output.WorldPosition, WorldToClip);
+}
+
+void VisualizeDDGIProbesPS(
+    in FVisualizeDDGIProbesVSToPS Input,
+    out float4 OutColor : SV_Target0)
+{
+    // Compute UVs based on ProbeID and direction of the fragment on the sphere
+    float3 WorldPos = Input.WorldPosition.xyz;
+    float3 Direction = normalize(Input.WorldPosition.xyz - Input.ProbeOrigin);
+    float2 OctantCoordinates = DDGIGetOctahedralCoordinates(Direction);
+
+    float3 Output = float3(0.0f, 0.0f, 0.0f);
+
+    #if RTXGI_DDGI_PROBE_SCROLL
+        float2 ProbeUVDistance = DDGIGetProbeUV(Input.InstanceId, OctantCoordinates, VolumeProbeGridCounts, VolumeProbeNumDistanceTexels, VolumeProbeScrollOffsets);
+        float2 ProbeUVIrradiance = DDGIGetProbeUV(Input.InstanceId, OctantCoordinates, VolumeProbeGridCounts, VolumeProbeNumIrradianceTexels, VolumeProbeScrollOffsets);
+    #else
+        float2 ProbeUVDistance = DDGIGetProbeUV(Input.InstanceId, OctantCoordinates, VolumeProbeGridCounts, VolumeProbeNumDistanceTexels);
+        float2 ProbeUVIrradiance = DDGIGetProbeUV(Input.InstanceId, OctantCoordinates, VolumeProbeGridCounts, VolumeProbeNumIrradianceTexels);
+    #endif
+
+    if (Mode == 1)
+    {
+        // Decode the tone curve
+        Output = ProbeIrradianceTexture.SampleLevel(ProbeSampler, ProbeUVIrradiance, 0).rgb;
+        Output = pow(Output.rgb, VolumeProbeIrradianceEncodingGamma * 0.5f);
+
+        // Go back to linear irradiance
+        Output *= Output;
+
+        // Multiply by the area of the integration domain (2PI) to complete the irradiance estimate. Divide by PI to normalize for the display.
+        Output *= 2.f;
+
+        #if !RTXGI_DDGI_DEBUG_FORMAT_IRRADIANCE
+            Output *= 1.0989f;    // Adjust for energy loss due to reduced precision in the R10G10B10A2 irradiance texture format
+        #endif
+
+        Output /= IrradianceScalar;
+    }
+    else if(Mode == 2)
+    {
+        float Distance = ProbeDistanceTexture.SampleLevel(ProbeSampler, ProbeUVDistance, 0).r;
+        Output = float3(Distance / DepthScale, Distance / DepthScale, Distance / DepthScale);
+    }
+    else if(Mode == 3)
+    {
+        float Distance = ProbeDistanceTexture.SampleLevel(ProbeSampler, ProbeUVDistance, 0).g;
+        Output = float3(Distance / DepthScale, Distance / DepthScale, Distance / DepthScale);
+    }
+    else
+    {
+        discard;
+    }
+
+    Output *= ShouldUsePreExposure ? PreExposure : 1.0f;
+
+#if RTXGI_DDGI_PROBE_STATE_CLASSIFIER
+    {
+        #if RTXGI_DDGI_PROBE_SCROLL
+            int probeIndex = DDGIGetProbeIndexOffset(Input.InstanceId, VolumeProbeGridCounts, VolumeProbeScrollOffsets);
+        #else
+            int probeIndex = Input.InstanceId;
+        #endif
+
+        int2 texelPosition = DDGIGetProbeTexelPosition(probeIndex, VolumeProbeGridCounts);
+        int  probeState = ProbeStates[texelPosition];
+        if(probeState == PROBE_STATE_INACTIVE)
+        {
+            float3 SurfaceToCamera = normalize(CameraPosition - Input.WorldPosition);
+            if (dot(SurfaceToCamera, Direction) < 0.5f)
+                Output = float3(1.0f, 0.0f, 0.0f);
+        }
+    }
+#endif
+
+    OutColor = float4(Output, 1.f);
+}
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Private/DDGIBlueprintLibrary.cpp b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Private/DDGIBlueprintLibrary.cpp
new file mode 100644
index 00000000000..f2fa08c59bb
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Private/DDGIBlueprintLibrary.cpp
@@ -0,0 +1,42 @@
+/*
+* Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#include "DDGIBlueprintLibrary.h"
+#include "DDGIVolumeComponent.h"
+#include "RenderingThread.h"
+
+UDDGIBlueprintLibrary::UDDGIBlueprintLibrary(const FObjectInitializer& ObjectInitializer)
+    : Super(ObjectInitializer){}
+
+void UDDGIBlueprintLibrary::ClearProbeData(const UDDGIVolumeComponent* DDGIVolumeComponent)
+{
+    FDDGIVolumeSceneProxy* DDGIProxy = DDGIVolumeComponent->SceneProxy;
+
+    ENQUEUE_RENDER_COMMAND(DDGIClearProbeData)(
+        [DDGIProxy, DDGIVolumeComponent](FRHICommandListImmediate& RHICmdList)
+        {
+            DDGIVolumeComponent->SceneProxy->ResetTextures_RenderThread(RHICmdList);
+        }
+    );
+}
+
+void UDDGIBlueprintLibrary::DisableVolume(
+    UDDGIVolumeComponent* DDGIVolumeComponent
+)
+{
+    DDGIVolumeComponent->EnableVolumeComponent(false);
+}
+
+void UDDGIBlueprintLibrary::EnableVolume(
+    UDDGIVolumeComponent* DDGIVolumeComponent
+)
+{
+    DDGIVolumeComponent->EnableVolumeComponent(true);
+}
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Private/DDGIVolume.cpp b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Private/DDGIVolume.cpp
new file mode 100644
index 00000000000..984c5e11aca
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Private/DDGIVolume.cpp
@@ -0,0 +1,72 @@
+/*
+* Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#include "DDGIVolume.h"
+#include "DDGIVolumeComponent.h"
+#include "Components/BoxComponent.h"
+#include "Components/BillboardComponent.h"
+#include "Engine/CollisionProfile.h"
+#include "UObject/ConstructorHelpers.h"
+
+ADDGIVolume::ADDGIVolume(const FObjectInitializer& ObjectInitializer)
+    : Super(ObjectInitializer)
+{
+    DDGIVolumeComponent = CreateDefaultSubobject<UDDGIVolumeComponent>(TEXT("DDGI"));
+    DDGIVolumeComponent->bHiddenInGame = false;
+    RootComponent = DDGIVolumeComponent;
+
+#if WITH_EDITORONLY_DATA
+    BoxComponent = CreateDefaultSubobject<UBoxComponent>(TEXT("Volume"));
+    SpriteComponent = CreateEditorOnlyDefaultSubobject<UBillboardComponent>(TEXT("Sprite"));
+    if (!IsRunningCommandlet())
+    {
+        if(BoxComponent != nullptr)
+        {
+            BoxComponent->SetBoxExtent(FVector{ 100.0f, 100.0f, 100.0f });
+            BoxComponent->bHiddenInGame = true;
+            BoxComponent->SetCollisionProfileName(UCollisionProfile::NoCollision_ProfileName);
+            BoxComponent->SetupAttachment(RootComponent);
+        }
+
+        if(SpriteComponent != nullptr)
+        {
+            static ConstructorHelpers::FObjectFinderOptional<UTexture2D> DecalTexture(TEXT("/Engine/EditorResources/EmptyActor"));
+
+            SpriteComponent->Sprite = DecalTexture.Get();
+            SpriteComponent->SetRelativeScale3D_Direct(FVector(0.5f, 0.5f, 0.5f));
+            SpriteComponent->bHiddenInGame = true;
+            SpriteComponent->SetUsingAbsoluteScale(true);
+            SpriteComponent->SetCollisionProfileName(UCollisionProfile::NoCollision_ProfileName);
+            SpriteComponent->bIsScreenSizeScaled = true;
+
+            SpriteComponent->SetupAttachment(RootComponent);
+        }
+    }
+#endif // WITH_EDITORONLY_DATA
+
+#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+    PrimaryActorTick.bCanEverTick = true;
+    PrimaryActorTick.bStartWithTickEnabled = true;
+#endif
+}
+
+#if WITH_EDITOR
+void ADDGIVolume::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
+{
+    Super::PostEditChangeProperty(PropertyChangedEvent);
+    DDGIVolumeComponent->UpdateRenderThreadData();
+}
+
+void ADDGIVolume::PostEditMove(bool bFinished)
+{
+    Super::PostEditMove(bFinished);
+    DDGIVolumeComponent->UpdateRenderThreadData();
+}
+#endif
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Private/DDGIVolumeComponent.cpp b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Private/DDGIVolumeComponent.cpp
new file mode 100644
index 00000000000..2997e3c3ecd
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Private/DDGIVolumeComponent.cpp
@@ -0,0 +1,1060 @@
+/*
+* Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#include "DDGIVolumeComponent.h"
+#include "DDGIVolume.h"
+#include "DDGIVolumeUpdate.h"
+
+#include "RTXGIPluginSettings.h"
+
+// UE4 Public Interfaces
+#include "ConvexVolume.h"
+#include "RenderGraphBuilder.h"
+#include "ShaderParameterStruct.h"
+#include "ShaderParameterUtils.h"
+#include "SystemTextures.h"
+
+// UE4 Private Interfaces
+#include "PostProcess/SceneRenderTargets.h"
+#include "SceneRendering.h"
+#include "DeferredShadingRenderer.h"
+#include "ScenePrivate.h"
+
+DECLARE_GPU_STAT_NAMED(RTXGI_Update, TEXT("RTXGI Update"));
+DECLARE_GPU_STAT_NAMED(RTXGI_ApplyLighting, TEXT("RTXGI Apply Lighting"));
+
+static TAutoConsoleVariable<bool> CVarUseDDGI(
+    TEXT("r.RTXGI.DDGI"),
+    true,
+    TEXT("If false, this will disable the lighting contribution and functionality of DDGI volumes.\n"),
+    ECVF_RenderThreadSafe);
+
+BEGIN_SHADER_PARAMETER_STRUCT(FVolumeData, )
+    SHADER_PARAMETER_TEXTURE(Texture2D, ProbeIrradiance)
+    SHADER_PARAMETER_TEXTURE(Texture2D, ProbeDistance)
+    SHADER_PARAMETER_UAV(RWTexture2D<float4>, ProbeOffsets)
+    SHADER_PARAMETER_TEXTURE(Texture2D<uint>, ProbeStates)
+    SHADER_PARAMETER(FVector, Position)
+    SHADER_PARAMETER(FVector4, Rotation)
+    SHADER_PARAMETER(FVector, Radius)
+    SHADER_PARAMETER(FVector, ProbeGridSpacing)
+    SHADER_PARAMETER(FIntVector, ProbeGridCounts)
+    SHADER_PARAMETER(FIntVector, ProbeScrollOffsets)
+    SHADER_PARAMETER(uint32, LightingChannelMask)
+    SHADER_PARAMETER(int, ProbeNumIrradianceTexels)
+    SHADER_PARAMETER(int, ProbeNumDistanceTexels)
+    SHADER_PARAMETER(float, ProbeIrradianceEncodingGamma)
+    SHADER_PARAMETER(float, NormalBias)
+    SHADER_PARAMETER(float, ViewBias)
+    SHADER_PARAMETER(float, BlendDistance)
+    SHADER_PARAMETER(float, BlendDistanceBlack)
+    SHADER_PARAMETER(float, ApplyLighting)
+    SHADER_PARAMETER(float, IrradianceScalar)
+END_SHADER_PARAMETER_STRUCT()
+
+BEGIN_SHADER_PARAMETER_STRUCT(FApplyLightingDeferredShaderParameters, )
+    SHADER_PARAMETER_RDG_TEXTURE(Texture2D, Normals)
+    SHADER_PARAMETER_RDG_TEXTURE(Texture2D, Depth)
+    SHADER_PARAMETER_RDG_TEXTURE(Texture2D, BaseColor)
+    SHADER_PARAMETER_RDG_TEXTURE(Texture2D, Metallic)
+    SHADER_PARAMETER_RDG_TEXTURE(Texture2D, LightingChannelsTexture)
+    SHADER_PARAMETER(FMatrix, ScreenToTranslatedWorld)
+    SHADER_PARAMETER(FVector, WorldCameraOrigin)
+    SHADER_PARAMETER(float, PreExposure)
+    SHADER_PARAMETER(FVector4, InvDeviceZToWorldZTransform)
+    SHADER_PARAMETER(int32, ShouldUsePreExposure)
+    SHADER_PARAMETER(int32, NumVolumes)
+    // Volumes are sorted from densest probes to least dense probes
+    SHADER_PARAMETER_STRUCT_ARRAY(FVolumeData, DDGIVolume, [FDDGIVolumeSceneProxy::FComponentData::c_RTXGI_DDGI_MAX_SHADING_VOLUMES])
+    SHADER_PARAMETER_SAMPLER(SamplerState, LinearClampSampler)
+    RENDER_TARGET_BINDING_SLOTS()
+END_SHADER_PARAMETER_STRUCT()
+
+class FApplyLightingDeferredShaderVS : public FGlobalShader
+{
+public:
+    DECLARE_GLOBAL_SHADER(FApplyLightingDeferredShaderVS);
+    SHADER_USE_PARAMETER_STRUCT(FApplyLightingDeferredShaderVS, FGlobalShader);
+
+    using FParameters = FApplyLightingDeferredShaderParameters;
+
+    class FEnableRelocation : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_RELOCATION");
+    class FEnableScrolling : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_SCROLL");
+
+    using FPermutationDomain = TShaderPermutationDomain<FEnableRelocation, FEnableScrolling>;
+
+    static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)
+    {
+        FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);
+
+        FString volumeMacroList;
+        for (int i = 0; i < FDDGIVolumeSceneProxy::FComponentData::c_RTXGI_DDGI_MAX_SHADING_VOLUMES; ++i)
+            volumeMacroList += FString::Printf(TEXT(" VOLUME_ENTRY(%i)"), i);
+        OutEnvironment.SetDefine(TEXT("VOLUME_LIST"), volumeMacroList.GetCharArray().GetData());
+
+        OutEnvironment.SetDefine(TEXT("RTXGI_DDGI_PROBE_STATE_CLASSIFIER"), FDDGIVolumeSceneProxy::FComponentData::c_RTXGI_DDGI_PROBE_STATE_CLASSIFIER ? 1 : 0);
+
+        // needed for a typed UAV load. This already assumes we are raytracing, so should be fine.
+        OutEnvironment.CompilerFlags.Add(CFLAG_AllowTypedUAVLoads);
+    }
+
+    static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters& Parameters)
+    {
+        return IsFeatureLevelSupported(Parameters.Platform, ERHIFeatureLevel::SM5);
+    }
+};
+
+class FApplyLightingDeferredShaderPS : public FGlobalShader
+{
+public:
+    DECLARE_GLOBAL_SHADER(FApplyLightingDeferredShaderPS);
+    SHADER_USE_PARAMETER_STRUCT(FApplyLightingDeferredShaderPS, FGlobalShader);
+
+    using FParameters = FApplyLightingDeferredShaderParameters;
+
+    class FLightingChannelsDim : SHADER_PERMUTATION_BOOL("USE_LIGHTING_CHANNELS");
+    class FEnableRelocation : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_RELOCATION");
+    class FEnableScrolling : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_SCROLL");
+    class FDebugFormatRadiance : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_DEBUG_FORMAT_RADIANCE");
+
+    using FPermutationDomain = TShaderPermutationDomain<FLightingChannelsDim, FEnableRelocation, FEnableScrolling, FDebugFormatRadiance>;
+
+    static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)
+    {
+        FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);
+
+        FString volumeMacroList;
+        for (int i = 0; i < FDDGIVolumeSceneProxy::FComponentData::c_RTXGI_DDGI_MAX_SHADING_VOLUMES; ++i)
+            volumeMacroList += FString::Printf(TEXT(" VOLUME_ENTRY(%i)"), i);
+        OutEnvironment.SetDefine(TEXT("VOLUME_LIST"), volumeMacroList.GetCharArray().GetData());
+
+        OutEnvironment.SetDefine(TEXT("RTXGI_DDGI_PROBE_STATE_CLASSIFIER"), FDDGIVolumeSceneProxy::FComponentData::c_RTXGI_DDGI_PROBE_STATE_CLASSIFIER ? 1 : 0);
+
+        // needed for a typed UAV load. This already assumes we are raytracing, so should be fine.
+        OutEnvironment.CompilerFlags.Add(CFLAG_AllowTypedUAVLoads);
+    }
+
+    static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters& Parameters)
+    {
+        return IsFeatureLevelSupported(Parameters.Platform, ERHIFeatureLevel::SM5);
+    }
+};
+
+IMPLEMENT_GLOBAL_SHADER(FApplyLightingDeferredShaderVS, "/Plugin/RTXGI/Private/ApplyLightingDeferred.usf", "MainVS", SF_Vertex);
+IMPLEMENT_GLOBAL_SHADER(FApplyLightingDeferredShaderPS, "/Plugin/RTXGI/Private/ApplyLightingDeferred.usf", "MainPS", SF_Pixel);
+
+// Delegate Handles
+FDelegateHandle FDDGIVolumeSceneProxy::RenderDiffuseIndirectVisualizationsHandle;
+FDelegateHandle FDDGIVolumeSceneProxy::RenderDiffuseIndirectLightHandle;
+
+TSet<FDDGIVolumeSceneProxy*> FDDGIVolumeSceneProxy::AllProxiesReadyForRender_RenderThread;
+TMap<const FSceneInterface*, float> FDDGIVolumeSceneProxy::SceneRoundRobinValue;
+
+bool FDDGIVolumeSceneProxy::IntersectsViewFrustum(const FViewInfo& View)
+{
+    // Get the volume position and scale
+    FVector ProxyPosition = ComponentData.Origin;
+    FQuat   ProxyRotation = ComponentData.Transform.GetRotation();
+    FVector ProxyScale = ComponentData.Transform.GetScale3D();
+    FVector ProxyExtent = ProxyScale * 100.0f;
+
+    if (ProxyRotation.IsIdentity())
+    {
+        // This volume is not rotated, test it against the view frustum
+        // Skip this volume if it doesn't intersect the view frustum
+        return View.ViewFrustum.IntersectBox(ProxyPosition, ProxyExtent);
+    }
+    else
+    {
+        // TODO: optimize CPU performance for many volumes (100s to 1000s)
+
+        // This volume is rotated, transform the view frustum so the volume's
+        // oriented bounding box becomes an axis-aligned bounding box.
+        FConvexVolume TransformedViewFrustum;
+        FMatrix FrustumTransform = FTranslationMatrix::Make(-ProxyPosition)
+            * FRotationMatrix::Make(ProxyRotation)
+            * FTranslationMatrix::Make(ProxyPosition);
+
+        // Based on SetupViewFrustum()
+        if (View.SceneViewInitOptions.OverrideFarClippingPlaneDistance > 0.0f)
+        {
+            FVector PlaneBasePoint = FrustumTransform.TransformPosition(View.ViewMatrices.GetViewOrigin() + View.GetViewDirection() * View.SceneViewInitOptions.OverrideFarClippingPlaneDistance);
+            FVector PlaneNormal = FrustumTransform.TransformVector(View.GetViewDirection());
+
+            const FPlane FarPlane(PlaneBasePoint, PlaneNormal);
+            // Derive the view frustum from the view projection matrix, overriding the far plane
+            GetViewFrustumBounds(TransformedViewFrustum, FrustumTransform * View.ViewMatrices.GetViewProjectionMatrix(), FarPlane, true, false);
+        }
+        else
+        {
+            // Derive the view frustum from the view projection matrix.
+            GetViewFrustumBounds(TransformedViewFrustum, FrustumTransform * View.ViewMatrices.GetViewProjectionMatrix(), false);
+        }
+
+        // Test the transformed view frustum against the volume
+        // Skip this volume if it doesn't intersect the view frustum
+        return TransformedViewFrustum.IntersectBox(ProxyPosition, ProxyExtent);
+    }
+}
+
+void FDDGIVolumeSceneProxy::OnIrradianceOrDistanceBitsChange()
+{
+    EDDGIIrradianceBits IrradianceBits = GetDefault<URTXGIPluginSettings>()->IrradianceBits;
+    EDDGIDistanceBits DistanceBits = GetDefault<URTXGIPluginSettings>()->DistanceBits;
+
+    // tell all the proxies about the change
+    ENQUEUE_RENDER_COMMAND(DDGIOnIrradianceBitsChange)(
+        [IrradianceBits, DistanceBits](FRHICommandListImmediate& RHICmdList)
+        {
+            for (FDDGIVolumeSceneProxy* DDGIProxy : AllProxiesReadyForRender_RenderThread)
+            {
+                DDGIProxy->ReallocateSurfaces_RenderThread(RHICmdList, IrradianceBits, DistanceBits);
+                DDGIProxy->ResetTextures_RenderThread(RHICmdList);
+            }
+        }
+    );
+}
+
+void FDDGIVolumeSceneProxy::ReallocateSurfaces_RenderThread(FRHICommandListImmediate& RHICmdList, EDDGIIrradianceBits IrradianceBits, EDDGIDistanceBits DistanceBits)
+{
+    FIntPoint ProxyDims = ComponentData.Get2DProbeCount();
+
+    // Irradiance
+    {
+        int numTexels = FDDGIVolumeSceneProxy::FComponentData::c_NumTexelsIrradiance;
+        FIntPoint ProxyTexDims = ProxyDims * (numTexels + 2);
+        FRHIResourceCreateInfo createInfo(TEXT("DDGIIrradiance"));
+        ProbesIrradianceTex = RHICreateTexture2D(ProxyTexDims.X, ProxyTexDims.Y, (IrradianceBits == EDDGIIrradianceBits::n32 ) ? FDDGIVolumeSceneProxy::FComponentData::c_pixelFormatIrradianceHighBitDepth : FDDGIVolumeSceneProxy::FComponentData::c_pixelFormatIrradianceLowBitDepth, 1, 1, TexCreate_ShaderResource | TexCreate_UAV, createInfo);
+        ProbesIrradianceUAV = RHICreateUnorderedAccessView(ProbesIrradianceTex, 0);
+    }
+
+    // Distance
+    {
+        int numTexels = FDDGIVolumeSceneProxy::FComponentData::c_NumTexelsDistance;
+        FIntPoint ProxyTexDims = ProxyDims * (numTexels + 2);
+        FRHIResourceCreateInfo createInfo(TEXT("DDGIDistance"));
+        ProbesDistanceTex = RHICreateTexture2D(ProxyTexDims.X, ProxyTexDims.Y, (DistanceBits == EDDGIDistanceBits::n32) ? FDDGIVolumeSceneProxy::FComponentData::c_pixelFormatDistanceHighBitDepth : FDDGIVolumeSceneProxy::FComponentData::c_pixelFormatDistanceLowBitDepth, 1, 1, TexCreate_ShaderResource | TexCreate_UAV, createInfo);
+        ProbesDistanceUAV = RHICreateUnorderedAccessView(ProbesDistanceTex, 0);
+    }
+
+    // Offsets - only pay the cost of this resource if this volume is actually doing relocation
+    if (ComponentData.EnableProbeRelocation)
+    {
+        FRHIResourceCreateInfo createInfo(TEXT("DDGIOffsets"));
+        ProbesOffsetsTex = RHICreateTexture2D(ProxyDims.X, ProxyDims.Y, FDDGIVolumeSceneProxy::FComponentData::c_pixelFormatOffsets, 1, 1, TexCreate_ShaderResource | TexCreate_UAV, createInfo);
+        ProbesOffsetsUAV = RHICreateUnorderedAccessView(ProbesOffsetsTex, 0);
+    }
+    else
+    {
+        ProbesOffsetsTex = nullptr;
+        ProbesOffsetsUAV = nullptr;
+    }
+
+    // probe classifications
+    if (FDDGIVolumeSceneProxy::FComponentData::c_RTXGI_DDGI_PROBE_STATE_CLASSIFIER)
+    {
+        FRHIResourceCreateInfo createInfo(TEXT("DDGIStates"));
+        ProbesStatesTex = RHICreateTexture2D(ProxyDims.X, ProxyDims.Y, FDDGIVolumeSceneProxy::FComponentData::c_pixelFormatStates, 1, 1, TexCreate_ShaderResource | TexCreate_UAV, createInfo);
+        ProbesStatesUAV = RHICreateUnorderedAccessView(ProbesStatesTex, 0);
+    }
+    else
+    {
+        ProbesStatesTex = nullptr;
+        ProbesStatesUAV = nullptr;
+    }
+}
+
+void FDDGIVolumeSceneProxy::ResetTextures_RenderThread(FRHICommandListImmediate& RHICmdList)
+{
+    // reset textures to pristine initial state
+    RHICmdList.ClearUAVFloat(ProbesIrradianceUAV, FVector4{ 0.0f, 0.0f, 0.0f, 0.0f });
+    RHICmdList.ClearUAVFloat(ProbesDistanceUAV, FVector4{ 0.0f, 0.0f, 0.0f, 0.0f });
+
+    if (ProbesOffsetsUAV)
+        RHICmdList.ClearUAVFloat(ProbesOffsetsUAV, FVector4{ 0.0f, 0.0f, 0.0f, 0.0f });
+
+    if (ProbesStatesUAV)
+        RHICmdList.ClearUAVUint(ProbesStatesUAV, FUintVector4{ 0, 0, 0, 0 });
+}
+
+void FDDGIVolumeSceneProxy::RenderDiffuseIndirectLight_RenderThread(
+    const FScene& Scene,
+    const FViewInfo& View,
+    FRDGBuilder& GraphBuilder,
+    FGlobalIlluminationExperimentalPluginResources& Resources)
+{
+    // Early out if DDGI is disabled
+    if (!CVarUseDDGI.GetValueOnRenderThread()) return;
+
+    // Update DDGIVolumes when rendering a main view and when ray tracing is available.
+    // Other views can use DDGIVolumes for lighting, but don't need to update the volumes.
+    // This is especially true for situations like bIsSceneCapture, when bSceneCaptureUsesRayTracing is false, and it can make incorrect probe update results.
+    if (!View.bIsSceneCapture && !View.bIsReflectionCapture && !View.bIsPlanarReflection)
+    {
+        RDG_GPU_STAT_SCOPE(GraphBuilder, RTXGI_Update);
+        RDG_EVENT_SCOPE(GraphBuilder, "RTXGI Update");
+        DDGIVolumeUpdate::DDGIUpdatePerFrame_RenderThread(Scene, View, GraphBuilder);
+    }
+
+    {
+        RDG_GPU_STAT_SCOPE(GraphBuilder, RTXGI_ApplyLighting);
+        RDG_EVENT_SCOPE(GraphBuilder, "RTXGI Apply Lighting");
+
+        // DDGIVolume and useful metadata
+        struct FProxyEntry
+        {
+            FVector Position;
+            FQuat Rotation;
+            FVector Scale;
+            float Density;
+            uint32 lightingChannelMask;
+            const FDDGIVolumeSceneProxy* proxy;
+        };
+
+        // Find all the volumes that intersect the view frustum
+        TArray<FProxyEntry> volumes;
+        for (FDDGIVolumeSceneProxy* volumeProxy : AllProxiesReadyForRender_RenderThread)
+        {
+            // Skip this volume if it belongs to another scene
+            if (volumeProxy->OwningScene != &Scene) continue;
+
+            // Skip this volume if it is not enabled
+            if (!volumeProxy->ComponentData.EnableVolume) continue;
+
+            // Skip this volume if it doesn't intersect the view frustum
+            if (!volumeProxy->IntersectsViewFrustum(View)) continue;
+
+            // Get the volume position, rotation, and scale
+            FVector ProxyPosition = volumeProxy->ComponentData.Origin;
+            FQuat   ProxyRotation = volumeProxy->ComponentData.Transform.GetRotation();
+            FVector ProxyScale = volumeProxy->ComponentData.Transform.GetScale3D();
+
+            float ProxyDensity = float(volumeProxy->ComponentData.ProbeCounts.X * volumeProxy->ComponentData.ProbeCounts.Y * volumeProxy->ComponentData.ProbeCounts.Z) / (ProxyScale.X * ProxyScale.Y * ProxyScale.Z);
+            uint32 ProxyLightingChannelMask =
+                (volumeProxy->ComponentData.LightingChannels.bChannel0 ? 1 : 0) |
+                (volumeProxy->ComponentData.LightingChannels.bChannel1 ? 2 : 0) |
+                (volumeProxy->ComponentData.LightingChannels.bChannel2 ? 4 : 0);
+
+            // Add the current volume to the list of in-frustum volumes
+            volumes.Add(FProxyEntry{ ProxyPosition, ProxyRotation, ProxyScale, ProxyDensity, ProxyLightingChannelMask, volumeProxy });
+        }
+
+        // Early out if no volumes contribute light to the current view
+        if (volumes.Num() == 0) return;
+
+        // TODO: manage in-frustum volumes in a more sophisticated way
+        // Support a large number of volumes by culling volumes based on spatial data, projected view area, and/or other heuristics
+
+        // Sort the in-frustum volumes by user specified priority
+        Algo::Sort(volumes, [](const FProxyEntry& A, const FProxyEntry& B)
+        {
+            if (A.proxy->ComponentData.LightingPriority < B.proxy->ComponentData.LightingPriority) return true;
+            if ((A.proxy->ComponentData.LightingPriority == B.proxy->ComponentData.LightingPriority) && (A.Density > B.Density)) return true;
+            return false;
+        });
+
+        // Get the number of relevant in-frustum volumes
+        int32 numVolumes = FMath::Min(volumes.Num(), FDDGIVolumeSceneProxy::FComponentData::c_RTXGI_DDGI_MAX_SHADING_VOLUMES);
+
+        // Truncate the in-frustum volumes list to the maximum number of volumes supported
+        volumes.SetNum(numVolumes, true);
+
+        // Sort the final volume list by descending probe density
+        Algo::Sort(volumes, [](const FProxyEntry& A, const FProxyEntry& B)
+        {
+            return (A.Density > B.Density);
+        });
+
+        // Register the GBuffer textures with the render graph
+        FRDGTextureRef GBufferATexture = GraphBuilder.RegisterExternalTexture(Resources.GBufferA);
+        FRDGTextureRef GBufferBTexture = GraphBuilder.RegisterExternalTexture(Resources.GBufferB);
+        FRDGTextureRef GBufferCTexture = GraphBuilder.RegisterExternalTexture(Resources.GBufferC);
+        FRDGTextureRef SceneDepthTexture = GraphBuilder.RegisterExternalTexture(Resources.SceneDepthZ);
+        FRDGTextureRef SceneColorTexture = GraphBuilder.RegisterExternalTexture(Resources.SceneColor);
+        if (!View.bUsesLightingChannels) Resources.LightingChannelsTexture = nullptr;
+
+        // Precompute the inverse view-projection transformation matrix
+        FMatrix ScreenToTranslatedWorld = FMatrix(
+            FPlane(1, 0, 0, 0),
+            FPlane(0, 1, 0, 0),
+            FPlane(0, 0, View.ProjectionMatrixUnadjustedForRHI.M[2][2], 1),
+            FPlane(0, 0, View.ProjectionMatrixUnadjustedForRHI.M[3][2], 0))
+            * View.ViewMatrices.GetInvTranslatedViewProjectionMatrix();
+
+        // Loop over the shader permutations to render indirect light from relevant volumes
+        for (int permutationIndex = 0; permutationIndex < 4; ++permutationIndex)
+        {
+            // Render with the current shader permutation if there one (or more) volume that matches the permutation settings
+            bool enableRelocation = (permutationIndex & 1) != 0;
+            bool enableScrolling = (permutationIndex & 2) != 0;
+            bool foundAMatch = false;
+            for (int32 i = 0; i < volumes.Num(); ++i)
+            {
+                foundAMatch = true;
+                foundAMatch = foundAMatch && (enableRelocation == volumes[i].proxy->ComponentData.EnableProbeRelocation);
+                foundAMatch = foundAMatch && (enableScrolling == volumes[i].proxy->ComponentData.EnableProbeScrolling);
+                if (foundAMatch) break;
+            }
+
+            // Skip this shader permutation if there are no volumes that match its feature set
+            if (!foundAMatch) continue;
+
+            // Get the vertex shader permutation
+            FGlobalShaderMap* GlobalShaderMap = GetGlobalShaderMap(ERHIFeatureLevel::SM5);
+            FApplyLightingDeferredShaderVS::FPermutationDomain PermutationVectorVS;
+            PermutationVectorVS.Set<FApplyLightingDeferredShaderVS::FEnableRelocation>(enableRelocation);
+            PermutationVectorVS.Set<FApplyLightingDeferredShaderVS::FEnableScrolling>(enableScrolling);
+            TShaderMapRef<FApplyLightingDeferredShaderVS> VertexShader(GlobalShaderMap, PermutationVectorVS);
+
+            // Get the pixel shader permutation
+            bool highBitCount = (GetDefault<URTXGIPluginSettings>()->IrradianceBits == EDDGIIrradianceBits::n32);
+            FApplyLightingDeferredShaderPS::FPermutationDomain PermutationVectorPS;
+            PermutationVectorPS.Set<FApplyLightingDeferredShaderPS::FLightingChannelsDim>(Resources.LightingChannelsTexture != nullptr);
+            PermutationVectorPS.Set<FApplyLightingDeferredShaderPS::FEnableRelocation>(enableRelocation);
+            PermutationVectorPS.Set<FApplyLightingDeferredShaderPS::FEnableScrolling>(enableScrolling);
+            PermutationVectorPS.Set<FApplyLightingDeferredShaderPS::FDebugFormatRadiance>(highBitCount);
+            TShaderMapRef<FApplyLightingDeferredShaderPS> PixelShader(GlobalShaderMap, PermutationVectorPS);
+
+            // Set the shader parameters
+            FApplyLightingDeferredShaderParameters DefaultPassParameters;
+            FApplyLightingDeferredShaderParameters* PassParameters = GraphBuilder.AllocParameters<FApplyLightingDeferredShaderParameters>();
+            *PassParameters = DefaultPassParameters;
+            PassParameters->Normals = GBufferATexture;
+            PassParameters->Depth = SceneDepthTexture;
+            PassParameters->BaseColor = GBufferCTexture;
+            PassParameters->Metallic = GBufferBTexture;
+            PassParameters->LightingChannelsTexture = Resources.LightingChannelsTexture;
+            PassParameters->ScreenToTranslatedWorld = ScreenToTranslatedWorld;
+            PassParameters->WorldCameraOrigin = View.ViewMatrices.GetViewOrigin();
+            PassParameters->InvDeviceZToWorldZTransform = View.InvDeviceZToWorldZTransform;
+            PassParameters->RenderTargets[0] = FRenderTargetBinding(SceneColorTexture, ERenderTargetLoadAction::ELoad);
+            PassParameters->LinearClampSampler = TStaticSamplerState<SF_Trilinear, AM_Clamp, AM_Clamp, AM_Clamp>::GetRHI();
+            PassParameters->ShouldUsePreExposure = View.Family->EngineShowFlags.Tonemapper;
+            PassParameters->PreExposure = View.PreExposure;
+            PassParameters->NumVolumes = numVolumes;
+
+            // Set the shader parameters for the relevant volumes
+            for (int32 volumeIndex = 0; volumeIndex < numVolumes; ++volumeIndex)
+            {
+                FProxyEntry volume = volumes[volumeIndex];
+                const FDDGIVolumeSceneProxy* volumeProxy = volume.proxy;
+
+                // Set the volume textures
+                PassParameters->DDGIVolume[volumeIndex].ProbeIrradiance = volumeProxy->ProbesIrradianceTex;
+                PassParameters->DDGIVolume[volumeIndex].ProbeDistance = volumeProxy->ProbesDistanceTex;
+                PassParameters->DDGIVolume[volumeIndex].ProbeOffsets = volumeProxy->ProbesOffsetsUAV ? volumeProxy->ProbesOffsetsUAV : GBlackTextureWithUAV->UnorderedAccessViewRHI;
+                PassParameters->DDGIVolume[volumeIndex].ProbeStates = volumeProxy->ProbesStatesTex;
+
+                // Set the volume parameters
+                PassParameters->DDGIVolume[volumeIndex].Position = volumeProxy->ComponentData.Origin;
+                PassParameters->DDGIVolume[volumeIndex].Rotation = FVector4(volume.Rotation.X, volume.Rotation.Y, volume.Rotation.Z, volume.Rotation.W);
+                PassParameters->DDGIVolume[volumeIndex].Radius = volume.Scale * 100.0f;
+                PassParameters->DDGIVolume[volumeIndex].LightingChannelMask = volume.lightingChannelMask;
+
+                FVector volumeSize = volumeProxy->ComponentData.Transform.GetScale3D() * 200.0f;
+                FVector probeGridSpacing;
+                probeGridSpacing.X = volumeSize.X / float(volumeProxy->ComponentData.ProbeCounts.X);
+                probeGridSpacing.Y = volumeSize.Y / float(volumeProxy->ComponentData.ProbeCounts.Y);
+                probeGridSpacing.Z = volumeSize.Z / float(volumeProxy->ComponentData.ProbeCounts.Z);
+
+                PassParameters->DDGIVolume[volumeIndex].ProbeGridSpacing = probeGridSpacing;
+                PassParameters->DDGIVolume[volumeIndex].ProbeGridCounts = volumeProxy->ComponentData.ProbeCounts;
+                PassParameters->DDGIVolume[volumeIndex].ProbeNumIrradianceTexels = FDDGIVolumeSceneProxy::FComponentData::c_NumTexelsIrradiance;
+                PassParameters->DDGIVolume[volumeIndex].ProbeNumDistanceTexels = FDDGIVolumeSceneProxy::FComponentData::c_NumTexelsDistance;
+                PassParameters->DDGIVolume[volumeIndex].ProbeIrradianceEncodingGamma = volumeProxy->ComponentData.ProbeIrradianceEncodingGamma;
+                PassParameters->DDGIVolume[volumeIndex].NormalBias = volumeProxy->ComponentData.NormalBias;
+                PassParameters->DDGIVolume[volumeIndex].ViewBias = volumeProxy->ComponentData.ViewBias;
+                PassParameters->DDGIVolume[volumeIndex].BlendDistance = volumeProxy->ComponentData.BlendDistance;
+                PassParameters->DDGIVolume[volumeIndex].BlendDistanceBlack = volumeProxy->ComponentData.BlendDistanceBlack;
+                PassParameters->DDGIVolume[volumeIndex].ProbeScrollOffsets = volumeProxy->ComponentData.ProbeScrollOffsets;
+
+                // Only apply lighting if this is the pass it should be applied in
+                // The shader needs data for all of the volumes for blending purposes
+                bool applyLighting = true;
+                applyLighting = applyLighting && (enableRelocation == volumeProxy->ComponentData.EnableProbeRelocation);
+                applyLighting = applyLighting && (enableScrolling == volumeProxy->ComponentData.EnableProbeScrolling);
+                PassParameters->DDGIVolume[volumeIndex].ApplyLighting = applyLighting;
+                PassParameters->DDGIVolume[volumeIndex].IrradianceScalar = volumeProxy->ComponentData.IrradianceScalar;
+
+                // Apply the lighting multiplier to artificially lighten or darken the indirect light from the volume
+                PassParameters->DDGIVolume[volumeIndex].IrradianceScalar /= volumeProxy->ComponentData.LightingMultiplier;
+            }
+
+            // When there are fewer relevant volumes than the maximum supported, set the empty volume texture slots to dummy values
+            for (int32 volumeIndex = numVolumes; volumeIndex < FDDGIVolumeSceneProxy::FComponentData::c_RTXGI_DDGI_MAX_SHADING_VOLUMES; ++volumeIndex)
+            {
+                PassParameters->DDGIVolume[volumeIndex].ProbeIrradiance = GSystemTextures.BlackDummy->GetRenderTargetItem().TargetableTexture;
+                PassParameters->DDGIVolume[volumeIndex].ProbeDistance = GSystemTextures.BlackDummy->GetRenderTargetItem().TargetableTexture;
+                PassParameters->DDGIVolume[volumeIndex].ProbeOffsets = GBlackTextureWithUAV->UnorderedAccessViewRHI;
+                PassParameters->DDGIVolume[volumeIndex].ProbeStates = GSystemTextures.BlackDummy->GetRenderTargetItem().TargetableTexture;
+            }
+
+            // Dispatch the fullscreen shader
+            FIntRect ViewRect = View.ViewRect;
+            GraphBuilder.AddPass(
+                Forward<FRDGEventName>(RDG_EVENT_NAME("DDGI Apply Lighting")),
+                PassParameters,
+                ERDGPassFlags::Raster,
+                [PassParameters, GlobalShaderMap, VertexShader, PixelShader, ViewRect](FRHICommandList& RHICmdList)
+                {
+                    RHICmdList.SetViewport(ViewRect.Min.X, ViewRect.Min.Y, 0.0f, ViewRect.Max.X, ViewRect.Max.Y, 1.0f);
+
+                    FGraphicsPipelineStateInitializer GraphicsPSOInit;
+                    RHICmdList.ApplyCachedRenderTargets(GraphicsPSOInit);
+                    GraphicsPSOInit.BlendState = TStaticBlendState<CW_RGB, BO_Add, BF_One, BF_One, BO_Add, BF_One, BF_One>::GetRHI();
+                    GraphicsPSOInit.RasterizerState = TStaticRasterizerState<>::GetRHI();
+                    GraphicsPSOInit.DepthStencilState = TStaticDepthStencilState<false, CF_Always>::GetRHI();
+
+                    GraphicsPSOInit.BoundShaderState.VertexDeclarationRHI = GetVertexDeclarationFVector4();
+                    GraphicsPSOInit.BoundShaderState.VertexShaderRHI = VertexShader.GetVertexShader();
+                    GraphicsPSOInit.BoundShaderState.PixelShaderRHI = PixelShader.GetPixelShader();
+                    GraphicsPSOInit.PrimitiveType = PT_TriangleList;
+
+                    SetGraphicsPipelineState(RHICmdList, GraphicsPSOInit);
+                    RHICmdList.SetStencilRef(0);
+
+                    SetShaderParameters(RHICmdList, VertexShader, VertexShader.GetVertexShader(), *PassParameters);
+                    SetShaderParameters(RHICmdList, PixelShader, PixelShader.GetPixelShader(), *PassParameters);
+
+                    RHICmdList.DrawPrimitive(0, 1, 1);
+                }
+            );
+        }
+    }
+}
+
+UDDGIVolumeComponent::UDDGIVolumeComponent(const FObjectInitializer& ObjectInitializer)
+    : Super(ObjectInitializer)
+{
+    bWantsInitializeComponent = true;
+}
+
+void UDDGIVolumeComponent::InitializeComponent()
+{
+    Super::InitializeComponent();
+
+    UpdateRenderThreadData();
+
+    TransformUpdated.AddLambda(
+        [this](USceneComponent* /*UpdatedComponent*/, EUpdateTransformFlags /*UpdateTransformFlags*/, ETeleportType /*Teleport*/)
+        {
+            UpdateRenderThreadData();
+        }
+    );
+}
+
+// Serialization version for stored DDGIVolume data
+struct RTXGI_API FDDGICustomVersion
+{
+    enum Type
+    {
+        AddingCustomVersion = 1,
+        SaveLoadProbeTextures,     // save pixels and width/height
+        SaveLoadProbeTexturesFmt,  // save texel format since the format can change in the project settings
+    };
+
+    // The GUID for this custom version number
+    const static FGuid GUID;
+
+private:
+    FDDGICustomVersion() {}
+};
+const FGuid FDDGICustomVersion::GUID(0xc12f0537, 0x7346d9c5, 0x336fbba3, 0x738ab145);
+
+// Register the custom version with core
+FCustomVersionRegistration GRegisterCustomVersion(FDDGICustomVersion::GUID, FDDGICustomVersion::SaveLoadProbeTexturesFmt, TEXT("DDGIVolCompVer"));
+
+// Create a CPU accessible GPU texture and copy the provided GPU texture's contents to it
+static FDDGITexturePixels GetTexturePixelsStep1_RenderThread(FRHICommandListImmediate& RHICmdList, FTexture2DRHIRef textureGPU)
+{
+    FDDGITexturePixels ret;
+
+    // Early out if a GPU texture is not provided
+    if (!textureGPU) return ret;
+
+    ret.w = textureGPU->GetSizeX();
+    ret.h = textureGPU->GetSizeY();
+    ret.pixelFormat = (int32)textureGPU->GetFormat();
+
+    // Create the texture
+    FRHIResourceCreateInfo createInfo(TEXT("DDGIGetTexturePixelsSave"));
+    ret.texture = RHICreateTexture2D(
+        textureGPU->GetSizeX(),
+        textureGPU->GetSizeY(),
+        textureGPU->GetFormat(),
+        1,
+        1,
+        TexCreate_ShaderResource | TexCreate_Transient,
+        ERHIAccess::CopyDest,
+        createInfo);
+
+    // Transition the GPU texture to a copy source
+    RHICmdList.Transition(FRHITransitionInfo(textureGPU, ERHIAccess::WritableMask, ERHIAccess::CopySrc));
+
+    // Schedule a copy of the GPU texture to the CPU accessible GPU texture
+    RHICmdList.CopyTexture(textureGPU, ret.texture, FRHICopyTextureInfo{});
+
+    // Transition the GPU texture back to general
+    RHICmdList.Transition(FRHITransitionInfo(textureGPU, ERHIAccess::CopySrc, ERHIAccess::WritableMask));
+
+    return ret;
+}
+
+// Read the CPU accessible GPU texture data into CPU memory
+static void GetTexturePixelsStep2_RenderThread(FRHICommandListImmediate& RHICmdList, FDDGITexturePixels& texturePixels)
+{
+    // Early out if no texture is provided
+    if (!texturePixels.texture) return;
+
+    // Get a pointer to the CPU memory
+    uint8* mappedTextureMemory = (uint8*)RHILockTexture2D(texturePixels.texture, 0, RLM_ReadOnly, texturePixels.stride, false);
+
+    // Copy the texture data to CPU memory
+    texturePixels.pixels.AddZeroed(texturePixels.h * texturePixels.stride);
+    FMemory::Memcpy(&texturePixels.pixels[0], mappedTextureMemory, texturePixels.h * texturePixels.stride);
+
+    RHIUnlockTexture2D(texturePixels.texture, 0, false);
+}
+
+static void SaveFDDGITexturePixels(FArchive& Ar, FDDGITexturePixels& texturePixels, bool saveFormat)
+{
+    check(Ar.IsSaving());
+
+    Ar << texturePixels.w;
+    Ar << texturePixels.h;
+    Ar << texturePixels.stride;
+    Ar << texturePixels.pixels;
+
+    if (saveFormat) Ar << texturePixels.pixelFormat;
+}
+
+static void LoadFDDGITexturePixels(FArchive& Ar, FDDGITexturePixels& texturePixels, EPixelFormat expectedPixelFormat, bool loadFormat)
+{
+    check(Ar.IsLoading());
+
+    // Load the texture data
+    Ar << texturePixels.w;
+    Ar << texturePixels.h;
+    Ar << texturePixels.stride;
+    Ar << texturePixels.pixels;
+
+    if (loadFormat)
+    {
+        Ar << texturePixels.pixelFormat;
+
+        // Early out if the loaded pixel format doesn't match our expected format
+        if (texturePixels.pixelFormat != expectedPixelFormat) return;
+    }
+
+    // Early out if no data was loaded
+    if (texturePixels.w == 0 || texturePixels.h == 0 || texturePixels.stride == 0) return;
+
+    // Create the texture resource
+    FRHIResourceCreateInfo createInfo(TEXT("DDGITextureLoad"));
+    texturePixels.texture = RHICreateTexture2D(
+        texturePixels.w,
+        texturePixels.h,
+        expectedPixelFormat,
+        1,
+        1,
+        TexCreate_ShaderResource | TexCreate_Transient,
+        createInfo);
+
+    // Copy the texture's data to the staging buffer
+    ENQUEUE_RENDER_COMMAND(DDGILoadTex)(
+        [&texturePixels](FRHICommandListImmediate& RHICmdList)
+        {
+            if (texturePixels.pixels.Num() == texturePixels.h * texturePixels.stride)
+            {
+                uint32 destStride;
+                uint8* mappedTextureMemory = (uint8*)RHILockTexture2D(texturePixels.texture, 0, RLM_WriteOnly, destStride, false);
+                if (texturePixels.stride == destStride)
+                {
+                    // Loaded data has the same stride as expected by the runtime
+                    // Copy the entire texture at once
+                    FMemory::Memcpy(mappedTextureMemory, &texturePixels.pixels[0], texturePixels.h * texturePixels.stride);
+                }
+                else
+                {
+                    // Loaded data has a different stride than expected by the runtime
+                    // Texture data was stored with a different API than what is running now (D3D12->VK, VK->D3D12)
+                    // Copy each row of the source data to the texture
+                    const uint8* SourceBuffer = &texturePixels.pixels[0];
+                    for (uint32 Row = 0; Row < texturePixels.h; ++Row)
+                    {
+                        FMemory::Memcpy(mappedTextureMemory, SourceBuffer, FMath::Min(texturePixels.stride, destStride));
+
+                        mappedTextureMemory += destStride;
+                        SourceBuffer += texturePixels.stride;
+                    }
+                }
+                RHIUnlockTexture2D(texturePixels.texture, 0, false);
+            }
+
+            // Only clear the texels when in a game.
+            // Cooking needs this data to write textures to disk on save, after load, when headless etc.
+        #if !WITH_EDITOR
+            texturePixels.pixels.Reset();
+        #endif
+        }
+    );
+}
+
+void UDDGIVolumeComponent::Serialize(FArchive& Ar)
+{
+    Super::Serialize(Ar);
+
+    Ar.UsingCustomVersion(FDDGICustomVersion::GUID);
+    if(Ar.CustomVer(FDDGICustomVersion::GUID) < FDDGICustomVersion::AddingCustomVersion)
+    {
+        if (Ar.IsLoading())
+        {
+            uint32 w, h;
+            TArray<float> pixels;
+            Ar << w;
+            Ar << h;
+            Ar << pixels;
+        }
+    }
+    else if (Ar.CustomVer(FDDGICustomVersion::GUID) >= FDDGICustomVersion::SaveLoadProbeTextures)
+    {
+        // Save and load DDGIVolume texture resources when entering a level
+        // Also applicable when ray tracing is not available (DX11 and Vulkan RHI).
+        bool saveFormat = Ar.CustomVer(FDDGICustomVersion::GUID) >= FDDGICustomVersion::SaveLoadProbeTexturesFmt;
+
+        FDDGIVolumeSceneProxy* proxy = SceneProxy;
+
+        if (Ar.IsSaving())
+        {
+            FDDGITexturePixels Irradiance, Distance, Offsets, States;
+
+            // When we are *not* cooking and ray tracing is available, copy the DDGIVolume probe texture resources
+            // to CPU memory otherwise, write out the DDGIVolume texture resources acquired at load time
+            if (!Ar.IsCooking() && IsRayTracingEnabled() && proxy)
+            {
+                // Copy textures to CPU accessible texture resources
+                ENQUEUE_RENDER_COMMAND(DDGISaveTexStep1)(
+                    [&Irradiance, &Distance, &Offsets, &States, proxy](FRHICommandListImmediate& RHICmdList)
+                    {
+                        Irradiance = GetTexturePixelsStep1_RenderThread(RHICmdList, proxy->ProbesIrradianceTex);
+                        Distance = GetTexturePixelsStep1_RenderThread(RHICmdList, proxy->ProbesDistanceTex);
+                        Offsets = GetTexturePixelsStep1_RenderThread(RHICmdList, proxy->ProbesOffsetsTex);
+                        States = GetTexturePixelsStep1_RenderThread(RHICmdList, proxy->ProbesStatesTex);
+                    }
+                );
+                FlushRenderingCommands();
+
+                // Read the GPU texture data to CPU memory
+                ENQUEUE_RENDER_COMMAND(DDGISaveTexStep2)(
+                    [&Irradiance, &Distance, &Offsets, &States](FRHICommandListImmediate& RHICmdList)
+                    {
+                        GetTexturePixelsStep2_RenderThread(RHICmdList, Irradiance);
+                        GetTexturePixelsStep2_RenderThread(RHICmdList, Distance);
+                        GetTexturePixelsStep2_RenderThread(RHICmdList, Offsets);
+                        GetTexturePixelsStep2_RenderThread(RHICmdList, States);
+                    }
+                );
+                FlushRenderingCommands();
+            }
+            else
+            {
+                Irradiance = LoadContext.Irradiance;
+                Distance = LoadContext.Distance;
+                Offsets = LoadContext.Offsets;
+                States = LoadContext.States;
+            }
+
+            // Write the volume data
+            SaveFDDGITexturePixels(Ar, Irradiance, saveFormat);
+            SaveFDDGITexturePixels(Ar, Distance, saveFormat);
+            SaveFDDGITexturePixels(Ar, Offsets, saveFormat);
+            SaveFDDGITexturePixels(Ar, States, saveFormat);
+        }
+        else if (Ar.IsLoading())
+        {
+            EDDGIIrradianceBits IrradianceBits = GetDefault<URTXGIPluginSettings>()->IrradianceBits;
+            EDDGIDistanceBits DistanceBits = GetDefault<URTXGIPluginSettings>()->DistanceBits;
+            bool loadFormat = Ar.CustomVer(FDDGICustomVersion::GUID) >= FDDGICustomVersion::SaveLoadProbeTexturesFmt;
+
+            // Read the volume texture data in and note that it's ready for load
+            LoadFDDGITexturePixels(Ar, LoadContext.Irradiance, (IrradianceBits == EDDGIIrradianceBits::n32) ? FDDGIVolumeSceneProxy::FComponentData::c_pixelFormatIrradianceHighBitDepth : FDDGIVolumeSceneProxy::FComponentData::c_pixelFormatIrradianceLowBitDepth, loadFormat);
+            LoadFDDGITexturePixels(Ar, LoadContext.Distance, (DistanceBits == EDDGIDistanceBits::n32) ? FDDGIVolumeSceneProxy::FComponentData::c_pixelFormatDistanceHighBitDepth : FDDGIVolumeSceneProxy::FComponentData::c_pixelFormatDistanceLowBitDepth, loadFormat);
+            LoadFDDGITexturePixels(Ar, LoadContext.Offsets, FDDGIVolumeSceneProxy::FComponentData::c_pixelFormatOffsets, loadFormat);
+            LoadFDDGITexturePixels(Ar, LoadContext.States, FDDGIVolumeSceneProxy::FComponentData::c_pixelFormatStates, loadFormat);
+
+            bool& ReadyForLoad = LoadContext.ReadyForLoad;
+            ENQUEUE_RENDER_COMMAND(DDGILoadReady)(
+                [&ReadyForLoad](FRHICommandListImmediate& RHICmdList)
+                {
+                    ReadyForLoad = true;
+                }
+            );
+        }
+    }
+}
+
+void UDDGIVolumeComponent::UpdateRenderThreadData()
+{
+    // Send command to the rendering thread to update the transform and other parameters
+    if (SceneProxy)
+    {
+        // Update the volume component's data
+        FDDGIVolumeSceneProxy::FComponentData ComponentData;
+        ComponentData.RaysPerProbe = RaysPerProbe;
+        ComponentData.ProbeMaxRayDistance = ProbeMaxRayDistance;
+        ComponentData.LightingChannels = LightingChannels;
+        ComponentData.ProbeCounts = ProbeCounts;
+        ComponentData.ProbeDistanceExponent = probeDistanceExponent;
+        ComponentData.ProbeIrradianceEncodingGamma = probeIrradianceEncodingGamma;
+        ComponentData.LightingPriority = LightingPriority;
+        ComponentData.UpdatePriority = UpdatePriority;
+        ComponentData.ProbeHysteresis = ProbeHysteresis;
+        ComponentData.ProbeChangeThreshold = probeChangeThreshold;
+        ComponentData.ProbeBrightnessThreshold = probeBrightnessThreshold;
+        ComponentData.NormalBias = NormalBias;
+        ComponentData.ViewBias = ViewBias;
+        ComponentData.BlendDistance = VolumeBlendDistance;
+        ComponentData.BlendDistanceBlack = VolumeBlendDistanceBlack;
+        ComponentData.ProbeBackfaceThreshold = ProbeBackfaceThreshold;
+        ComponentData.ProbeMinFrontfaceDistance = ProbeMinFrontfaceDistance;
+        ComponentData.EnableProbeRelocation = EnableProbeRelocation;
+        ComponentData.EnableProbeScrolling = EnableProbeScrolling;
+        ComponentData.EnableVolume = EnableVolume;
+        ComponentData.IrradianceScalar = IrradianceScalar;
+        ComponentData.EmissiveMultiplier = EmissiveMultiplier;
+        ComponentData.LightingMultiplier = LightMultiplier;
+        ComponentData.RuntimeStatic = RuntimeStatic;
+        ComponentData.SkyLight = SkyLight;
+
+        if (EnableProbeScrolling)
+        {
+            // Infinite Scrolling Volume
+            // Disable volume transformations and instead move the volume by "scrolling" the probes over an infinite space.
+            // Offset "planes" of probes from one end of the volume to the other (in the direction  of movement).
+            // Useful for computing GI around a moving object, e.g. characters.
+            // NB: scrolling probes can be disruptive when recursive probe sampling is enabled and the volume is small. Sudden changes in scrolled probes will propogate to nearby probes!
+            FVector CurrentOrigin = GetOwner()->GetTransform().GetLocation();
+            FVector MovementDelta = CurrentOrigin - LastOrigin;
+
+            FVector ProbeGridSpacing;
+            FVector VolumeSize = GetOwner()->GetTransform().GetScale3D() * 200.f;
+            ProbeGridSpacing.X = VolumeSize.X / float(ProbeCounts.X);
+            ProbeGridSpacing.Y = VolumeSize.Y / float(ProbeCounts.Y);
+            ProbeGridSpacing.Z = VolumeSize.Z / float(ProbeCounts.Z);
+
+            if(FMath::Abs(MovementDelta.X) >= ProbeGridSpacing.X || FMath::Abs(MovementDelta.Y) >= ProbeGridSpacing.Y || FMath::Abs(MovementDelta.Z) >= ProbeGridSpacing.Z)
+            {
+                auto absFloor = [](float f)
+                {
+                    return f >= 0.f ? int(floor(f)) : int(ceil(f));
+                };
+
+                // Calculate the number of grid cells that have been moved
+                FIntVector Translation;
+                Translation.X = int(absFloor(MovementDelta.X / ProbeGridSpacing.X));
+                Translation.Y = int(absFloor(MovementDelta.Y / ProbeGridSpacing.Y));
+                Translation.Z = int(absFloor(MovementDelta.Z / ProbeGridSpacing.Z));
+
+                // Move the volume origin the number of grid cells * the distance between cells
+                LastOrigin.X += float(Translation.X) * ProbeGridSpacing.X;
+                LastOrigin.Y += float(Translation.Y) * ProbeGridSpacing.Y;
+                LastOrigin.Z += float(Translation.Z) * ProbeGridSpacing.Z;
+
+                // Update the probe scroll offset count
+                ProbeScrollOffset.X += Translation.X;
+                ProbeScrollOffset.Y += Translation.Y;
+                ProbeScrollOffset.X += Translation.Z;
+            }
+
+            // Set the probe scroll offsets
+            ComponentData.ProbeScrollOffsets.X = ((ProbeScrollOffset.X % ProbeCounts.X) + ProbeCounts.X) % ProbeCounts.X;
+            ComponentData.ProbeScrollOffsets.Y = ((ProbeScrollOffset.Y % ProbeCounts.Y) + ProbeCounts.Y) % ProbeCounts.Y;
+            ComponentData.ProbeScrollOffsets.Z = ((ProbeScrollOffset.Z % ProbeCounts.Z) + ProbeCounts.Z) % ProbeCounts.Z;
+
+            // Set the volume origin and scale (rotation not allowed)
+            ComponentData.Origin = LastOrigin;
+            ComponentData.Transform.SetScale3D(GetOwner()->GetTransform().GetScale3D());
+        }
+        else
+        {
+            // Finite moveable volume
+            // Transform the volume to stay aligned with its parent.
+            // Useful for spaces that move, e.g. a ship or train car.
+            ComponentData.Transform = GetOwner()->GetTransform();
+            ComponentData.Origin = LastOrigin = GetOwner()->GetTransform().GetLocation();
+            ComponentData.ProbeScrollOffsets = FIntVector{ 0, 0, 0 };
+        }
+
+        // If the ProbeCounts are too large to make textures, let's not update the render thread data to avoid a crash.
+        // Everything is ok with not getting an update, ever, so this is safe.
+        {
+            volatile uint32 maxTextureSize = GetMax2DTextureDimension();
+
+            // DDGIRadiance
+            if (uint32(ProbeCounts.X * ProbeCounts.Y * ProbeCounts.Z) > maxTextureSize)
+                return;
+
+            FIntPoint ProxyDims = ComponentData.Get2DProbeCount();
+
+            // DDGIIrradiance
+            {
+                int numTexels = FDDGIVolumeSceneProxy::FComponentData::c_NumTexelsIrradiance;
+                FIntPoint ProxyTexDims = ProxyDims * (numTexels + 2);
+                if (uint32(ProxyTexDims.X) > maxTextureSize || uint32(ProxyTexDims.Y) > maxTextureSize)
+                    return;
+            }
+
+            // DDGIDistance
+            {
+                int numTexels = FDDGIVolumeSceneProxy::FComponentData::c_NumTexelsDistance;
+                FIntPoint ProxyTexDims = ProxyDims * (numTexels + 2);
+                if (uint32(ProxyTexDims.X) > maxTextureSize || uint32(ProxyTexDims.Y) > maxTextureSize)
+                    return;
+            }
+        }
+
+        FDDGIVolumeSceneProxy* DDGIProxy = SceneProxy;
+        EDDGIIrradianceBits IrradianceBits = GetDefault<URTXGIPluginSettings>()->IrradianceBits;
+        EDDGIDistanceBits DistanceBits = GetDefault<URTXGIPluginSettings>()->DistanceBits;
+
+        FDDGITextureLoadContext TextureLoadContext = LoadContext;
+        LoadContext.ReadyForLoad = false;
+
+        ENQUEUE_RENDER_COMMAND(UpdateGIVolumeTransformCommand)(
+            [DDGIProxy, ComponentData, TextureLoadContext, IrradianceBits, DistanceBits](FRHICommandListImmediate& RHICmdList)
+            {
+                bool needReallocate =
+                    DDGIProxy->ComponentData.ProbeCounts != ComponentData.ProbeCounts ||
+                    DDGIProxy->ComponentData.RaysPerProbe != ComponentData.RaysPerProbe ||
+                    DDGIProxy->ComponentData.EnableProbeRelocation != ComponentData.EnableProbeRelocation;
+
+                // set the data
+                DDGIProxy->ComponentData = ComponentData;
+
+                // handle state textures ready to load from serialization
+                if (TextureLoadContext.ReadyForLoad)
+                    DDGIProxy->TextureLoadContext = TextureLoadContext;
+
+                if (needReallocate)
+                {
+                    DDGIProxy->ReallocateSurfaces_RenderThread(RHICmdList, IrradianceBits, DistanceBits);
+                    DDGIProxy->ResetTextures_RenderThread(RHICmdList);
+                    FDDGIVolumeSceneProxy::AllProxiesReadyForRender_RenderThread.Add(DDGIProxy);
+                }
+            }
+        );
+    }
+}
+
+void UDDGIVolumeComponent::EnableVolumeComponent(bool enabled)
+{
+    EnableVolume = enabled;
+    UpdateRenderThreadData();
+}
+
+void UDDGIVolumeComponent::Startup()
+{
+#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+	FGlobalIlluminationExperimentalPluginDelegates::FRenderDiffuseIndirectVisualizations& RVDelegate = FGlobalIlluminationExperimentalPluginDelegates::RenderDiffuseIndirectVisualizations();
+    FDDGIVolumeSceneProxy::RenderDiffuseIndirectVisualizationsHandle = RVDelegate.AddStatic(FDDGIVolumeSceneProxy::RenderDiffuseIndirectVisualizations_RenderThread);
+#endif
+
+    FGlobalIlluminationExperimentalPluginDelegates::FRenderDiffuseIndirectLight& RDILDelegate = FGlobalIlluminationExperimentalPluginDelegates::RenderDiffuseIndirectLight();
+    FDDGIVolumeSceneProxy::RenderDiffuseIndirectLightHandle = RDILDelegate.AddStatic(FDDGIVolumeSceneProxy::RenderDiffuseIndirectLight_RenderThread);
+}
+
+void UDDGIVolumeComponent::Shutdown()
+{
+#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+    FGlobalIlluminationExperimentalPluginDelegates::FRenderDiffuseIndirectVisualizations& RVDelegate = FGlobalIlluminationExperimentalPluginDelegates::RenderDiffuseIndirectVisualizations();
+    check(FDDGIVolumeSceneProxy::RenderDiffuseIndirectVisualizationsHandle.IsValid());
+    RVDelegate.Remove(FDDGIVolumeSceneProxy::RenderDiffuseIndirectVisualizationsHandle);
+#endif
+
+    FGlobalIlluminationExperimentalPluginDelegates::FRenderDiffuseIndirectLight& RDILDelegate = FGlobalIlluminationExperimentalPluginDelegates::RenderDiffuseIndirectLight();
+    check(FDDGIVolumeSceneProxy::RenderDiffuseIndirectLightHandle.IsValid());
+    RDILDelegate.Remove(FDDGIVolumeSceneProxy::RenderDiffuseIndirectLightHandle);
+}
+
+bool UDDGIVolumeComponent::Exec(UWorld* InWorld, const TCHAR* Cmd, FOutputDevice& Ar)
+{
+    return ProcessConsoleExec(Cmd, Ar, NULL);
+}
+
+void UDDGIVolumeComponent::DDGIClearVolumes()
+{
+    ENQUEUE_RENDER_COMMAND(DDGIClearVolumesCommand)(
+        [](FRHICommandListImmediate& RHICmdList)
+        {
+            for (FDDGIVolumeSceneProxy* DDGIProxy : FDDGIVolumeSceneProxy::AllProxiesReadyForRender_RenderThread)
+            {
+                DDGIProxy->ResetTextures_RenderThread(RHICmdList);
+            }
+        }
+    );
+}
+
+void UDDGIVolumeComponent::CreateRenderState_Concurrent(FRegisterComponentContext* Context)
+{
+    Super::CreateRenderState_Concurrent(Context);
+    check(SceneProxy == nullptr);
+
+#if WITH_EDITOR
+    if (!GetOwner()->IsTemporarilyHiddenInEditor())
+#endif
+    {
+        SceneProxy = new FDDGIVolumeSceneProxy(GetScene());
+        UpdateRenderThreadData();
+    }
+}
+
+void UDDGIVolumeComponent::DestroyRenderState_Concurrent()
+{
+    Super::DestroyRenderState_Concurrent();
+
+    if (SceneProxy)
+    {
+        FDDGITextureLoadContext& ComponentLoadContext = LoadContext;
+
+        FDDGIVolumeSceneProxy* DDGIProxy = SceneProxy;
+        ENQUEUE_RENDER_COMMAND(DeleteProxy)(
+            [DDGIProxy, &ComponentLoadContext](FRHICommandListImmediate& RHICmdList)
+            {
+                // If the component has textures pending load, nothing to do here. Those are the most authoritative.
+                if (!ComponentLoadContext.ReadyForLoad)
+                {
+                    // If the proxy has textures pending load which haven't been serviced yet, the component should take those
+                    // in case it creates another proxy.
+                    if (DDGIProxy->TextureLoadContext.ReadyForLoad)
+                    {
+                        ComponentLoadContext = DDGIProxy->TextureLoadContext;
+                    }
+                    // otherwise, we should copy the textures from this proxy into textures for the TextureLoadContext
+                    // to make them survive to the next proxy for this component if one is created.
+                    else
+                    {
+                        ComponentLoadContext.ReadyForLoad = true;
+                        ComponentLoadContext.Irradiance = GetTexturePixelsStep1_RenderThread(RHICmdList, DDGIProxy->ProbesIrradianceTex);
+                        ComponentLoadContext.Distance = GetTexturePixelsStep1_RenderThread(RHICmdList, DDGIProxy->ProbesDistanceTex);
+                        ComponentLoadContext.Offsets = GetTexturePixelsStep1_RenderThread(RHICmdList, DDGIProxy->ProbesOffsetsTex);
+                        ComponentLoadContext.States = GetTexturePixelsStep1_RenderThread(RHICmdList, DDGIProxy->ProbesStatesTex);
+                    }
+                }
+
+                delete DDGIProxy;
+            }
+        );
+
+        // wait for the above command to finish, so we know we got the load context if present
+        FlushRenderingCommands();
+
+        SceneProxy = nullptr;
+    }
+}
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Private/DDGIVolumeUpdate.cpp b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Private/DDGIVolumeUpdate.cpp
new file mode 100644
index 00000000000..3c2dc694dc7
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Private/DDGIVolumeUpdate.cpp
@@ -0,0 +1,1350 @@
+/*
+* Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#include "DDGIVolumeUpdate.h"
+
+// UE4 public interfaces
+#include "CoreMinimal.h"
+#include "Engine/TextureRenderTarget2D.h"
+#include "SceneView.h"
+#include "RenderGraph.h"
+#include "RayGenShaderUtils.h"
+#include "ShaderParameterStruct.h"
+#include "GlobalShader.h"
+#include "RTXGIPluginSettings.h"
+
+// UE4 private interfaces
+#include "ReflectionEnvironment.h"
+#include "FogRendering.h"
+#include "SceneRendering.h"
+#include "SceneTextureParameters.h"
+#include "RayTracing/RayTracingLighting.h"
+#include "DeferredShadingRenderer.h"
+#include "ScenePrivate.h"
+
+#include <cmath>
+
+// local includes
+#include "DDGIVolumeComponent.h"
+
+#define LOCTEXT_NAMESPACE "FRTXGIPlugin"
+
+#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+static TAutoConsoleVariable<int> CVarDDGIProbeVis(
+    TEXT("r.RTXGI.DDGIProbeVis"),
+    0,
+    TEXT("If 1, will render what the probes see. If 2, will show misses (blue), hits (green), backfaces (red). \'vis DDGIProbeVis\' to see the output.\n"),
+    ECVF_RenderThreadSafe);
+#endif
+
+// So we have something to give the "AddPass" calls that we add for transitions
+BEGIN_SHADER_PARAMETER_STRUCT(FDummyShaderParameters, )
+    SHADER_PARAMETER(int, Dummy)
+END_SHADER_PARAMETER_STRUCT()
+
+static FMatrix ComputeRandomRotation()
+{
+    // This approach is based on James Arvo's implementation from Graphics Gems 3 (pg 117-120).
+    // Also available at: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.53.1357&rep=rep1&type=pdf
+
+    // Setup a random rotation matrix using 3 uniform RVs
+    float u1 = 2.f * 3.14159265359 * FMath::FRand();
+    float cos1 = std::cosf(u1);
+    float sin1 = std::sinf(u1);
+
+    float u2 = 2.f * 3.14159265359 * FMath::FRand();
+    float cos2 = std::cosf(u2);
+    float sin2 = std::sinf(u2);
+
+    float u3 = FMath::FRand();
+    float sq3 = 2.f * std::sqrtf(u3 * (1.f - u3));
+
+    float s2 = 2.f * u3 * sin2 * sin2 - 1.f;
+    float c2 = 2.f * u3 * cos2 * cos2 - 1.f;
+    float sc = 2.f * u3 * sin2 * cos2;
+
+    // Create the random rotation matrix
+    float _11 = cos1 * c2 - sin1 * sc;
+    float _12 = sin1 * c2 + cos1 * sc;
+    float _13 = sq3 * cos2;
+
+    float _21 = cos1 * sc - sin1 * s2;
+    float _22 = sin1 * sc + cos1 * s2;
+    float _23 = sq3 * sin2;
+
+    float _31 = cos1 * (sq3 * cos2) - sin1 * (sq3 * sin2);
+    float _32 = sin1 * (sq3 * cos2) + cos1 * (sq3 * sin2);
+    float _33 = 1.f - 2.f * u3;
+
+    return FMatrix(
+        FPlane( _11, _12, _13, 0.f ),
+        FPlane(_21, _22, _23, 0.f ),
+        FPlane(_31, _32, _33, 0.f ),
+        FPlane(0.f, 0.f, 0.f, 1.f )
+    );
+}
+
+class FRayTracingRTXGIProbeUpdateRGS : public FGlobalShader
+{
+    DECLARE_GLOBAL_SHADER(FRayTracingRTXGIProbeUpdateRGS)
+    SHADER_USE_ROOT_PARAMETER_STRUCT(FRayTracingRTXGIProbeUpdateRGS, FGlobalShader)
+
+    class FEnableTwoSidedGeometryDim : SHADER_PERMUTATION_BOOL("ENABLE_TWO_SIDED_GEOMETRY"); // If false, it will cull back face triangles. We want this on for probe relocation and to stop light leak.
+    class FEnableMaterialsDim : SHADER_PERMUTATION_BOOL("ENABLE_MATERIALS");                 // If false, forces the geo to opaque (no alpha test). We want this off for speed.
+    class FDecoupleSampleGeneration : SHADER_PERMUTATION_BOOL("DECOUPLE_SAMPLE_GENERATION"); // Something for the skylight. We will turn this off
+    class FEnableRelocation : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_RELOCATION");
+    class FDebugFormatRadiance : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_DEBUG_FORMAT_RADIANCE");
+    class FEnableScrolling : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_SCROLL");
+
+    class FSkyLight : SHADER_PERMUTATION_BOOL("DDGI_SKYLIGHT");
+
+    using FPermutationDomain = TShaderPermutationDomain<FEnableTwoSidedGeometryDim, FEnableMaterialsDim, FDecoupleSampleGeneration, FEnableRelocation, FDebugFormatRadiance, FEnableScrolling, FSkyLight>;
+
+    static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)
+    {
+        FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);
+
+        OutEnvironment.SetDefine(TEXT("RTXGI_DDGI_PROBE_STATE_CLASSIFIER"), FDDGIVolumeSceneProxy::FComponentData::c_RTXGI_DDGI_PROBE_STATE_CLASSIFIER ? 1 : 0);
+
+        // Set to 1 to be able to visualize this in the editor by typing "vis DDGIVolumeUpdateDebug" and later "vis none" to make it go away.
+        // Set to 0 to disable and deadstrip everything related
+        OutEnvironment.SetDefine(TEXT("DDGIVolumeUpdateDebug"), 0);
+    }
+
+    static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters& Parameters)
+    {
+        return ShouldCompileRayTracingShadersForProject(Parameters.Platform);
+    }
+
+    BEGIN_SHADER_PARAMETER_STRUCT(FVolumeData, )
+        SHADER_PARAMETER_TEXTURE(Texture2D, ProbeIrradiance)
+        SHADER_PARAMETER_TEXTURE(Texture2D, ProbeDistance)
+        SHADER_PARAMETER_UAV(RWTexture2D<float4>, ProbeOffsets)
+        SHADER_PARAMETER_TEXTURE(Texture2D<uint>, ProbeStates)
+        SHADER_PARAMETER(FVector, Origin)
+        SHADER_PARAMETER(FVector4, Rotation)
+        SHADER_PARAMETER(FVector, ProbeGridSpacing)
+        SHADER_PARAMETER(float, ProbeMaxRayDistance)
+        SHADER_PARAMETER(FIntVector, ProbeGridCounts)
+        SHADER_PARAMETER(FMatrix, ProbeRayRotationTransform)
+        SHADER_PARAMETER(int, NumRaysPerProbe)
+        SHADER_PARAMETER(FVector, Radius)
+        SHADER_PARAMETER(int, ProbeNumIrradianceTexels)
+        SHADER_PARAMETER(int, ProbeNumDistanceTexels)
+        SHADER_PARAMETER(float, ProbeIrradianceEncodingGamma)
+        SHADER_PARAMETER(float, NormalBias)
+        SHADER_PARAMETER(float, ViewBias)
+        SHADER_PARAMETER(FIntVector, ProbeScrollOffsets)
+        SHADER_PARAMETER_SAMPLER(SamplerState, LinearClampSampler)
+        SHADER_PARAMETER(float, IrradianceScalar)
+        SHADER_PARAMETER(float, EmissiveMultiplier)
+        SHADER_PARAMETER(int, ProbeIndexStart)
+        SHADER_PARAMETER(int, ProbeIndexCount)
+    END_SHADER_PARAMETER_STRUCT()
+
+    BEGIN_SHADER_PARAMETER_STRUCT(FParameters, )
+        SHADER_PARAMETER_SRV(RaytracingAccelerationStructure, TLAS)
+
+        SHADER_PARAMETER(uint32, FrameRandomSeed)
+
+        SHADER_PARAMETER_STRUCT(FVolumeData, DDGIVolume)
+
+        SHADER_PARAMETER(FVector, Sky_Color)
+        SHADER_PARAMETER_TEXTURE(Texture2D, Sky_Texture)
+        SHADER_PARAMETER_SAMPLER(SamplerState, Sky_TextureSampler)
+
+        SHADER_PARAMETER_RDG_TEXTURE_UAV(RWTexture2D<float4>, RadianceOutput)
+        SHADER_PARAMETER_RDG_TEXTURE_UAV(RWTexture2D<float4>, DebugOutput)  // Per unreal RDG presentation, this is deadstripped if the shader doesn't write to it
+
+        // assorted things needed by material resolves, even though some don't make sense outside of screenspace
+        SHADER_PARAMETER_RDG_TEXTURE(Texture2D, SSProfilesTexture)
+        SHADER_PARAMETER_STRUCT_REF(FViewUniformShaderParameters, ViewUniformBuffer)
+        SHADER_PARAMETER_STRUCT_REF(FRaytracingLightDataPacked, LightDataPacked)
+    END_SHADER_PARAMETER_STRUCT()
+};
+
+IMPLEMENT_GLOBAL_SHADER(FRayTracingRTXGIProbeUpdateRGS, "/Plugin/RTXGI/Private/ProbeUpdateRGS.usf", "ProbeUpdateRGS", SF_RayGen);
+
+#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+
+class FRayTracingRTXGIProbeViewRGS : public FGlobalShader
+{
+    DECLARE_GLOBAL_SHADER(FRayTracingRTXGIProbeViewRGS)
+    SHADER_USE_ROOT_PARAMETER_STRUCT(FRayTracingRTXGIProbeViewRGS, FGlobalShader)
+
+    class FEnableTwoSidedGeometryDim : SHADER_PERMUTATION_BOOL("ENABLE_TWO_SIDED_GEOMETRY"); // If false, it will cull back face triangles. We want this on for probe relocation and to stop light leak.
+    class FEnableMaterialsDim : SHADER_PERMUTATION_BOOL("ENABLE_MATERIALS");                 // If false, forces the geo to opaque (no alpha test). We want this off for speed.
+    class FDecoupleSampleGeneration : SHADER_PERMUTATION_BOOL("DECOUPLE_SAMPLE_GENERATION"); // Something for the skylight. We will turn this off
+    class FVolumeDebugView : SHADER_PERMUTATION_INT("VOLUME_DEBUG_VIEW", 2);
+
+    using FPermutationDomain = TShaderPermutationDomain<FEnableTwoSidedGeometryDim, FEnableMaterialsDim, FDecoupleSampleGeneration, FVolumeDebugView>;
+
+    static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)
+    {
+        FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);
+
+        OutEnvironment.SetDefine(TEXT("RTXGI_DDGI_PROBE_STATE_CLASSIFIER"), FDDGIVolumeSceneProxy::FComponentData::c_RTXGI_DDGI_PROBE_STATE_CLASSIFIER ? 1 : 0);
+        OutEnvironment.SetDefine(TEXT("RTXGI_DDGI_PROBE_RELOCATION"), 0);
+    }
+
+    static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters& Parameters)
+    {
+        return ShouldCompileRayTracingShadersForProject(Parameters.Platform);
+    }
+
+    BEGIN_SHADER_PARAMETER_STRUCT(FParameters, )
+        SHADER_PARAMETER_SRV(RaytracingAccelerationStructure, TLAS)
+
+        SHADER_PARAMETER(uint32, FrameRandomSeed)
+
+        SHADER_PARAMETER(FVector, CameraPos)
+        SHADER_PARAMETER(FMatrix, CameraMatrix)
+
+        SHADER_PARAMETER(float, DDGIVolume_PreExposure)
+        SHADER_PARAMETER(int32, DDGIVolume_ShouldUsePreExposure)
+
+        SHADER_PARAMETER(FVector, Sky_Color)
+        SHADER_PARAMETER_TEXTURE(Texture2D, Sky_Texture)
+        SHADER_PARAMETER_SAMPLER(SamplerState, Sky_TextureSampler)
+
+        SHADER_PARAMETER_RDG_TEXTURE_UAV(RWTexture2D<float4>, RadianceOutput)
+
+        // assorted things needed by material resolves, even though some don't make sense outside of screenspace
+        SHADER_PARAMETER_RDG_TEXTURE(Texture2D, SSProfilesTexture)
+        SHADER_PARAMETER_STRUCT_REF(FViewUniformShaderParameters, ViewUniformBuffer)
+        SHADER_PARAMETER_STRUCT_REF(FRaytracingLightDataPacked, LightDataPacked)
+    END_SHADER_PARAMETER_STRUCT()
+};
+
+IMPLEMENT_GLOBAL_SHADER(FRayTracingRTXGIProbeViewRGS, "/Plugin/RTXGI/Private/ProbeViewRGS.usf", "ProbeViewRGS", SF_RayGen);
+
+#endif // #if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+
+class FDDGIIrradianceBlend : public FGlobalShader
+{
+    DECLARE_GLOBAL_SHADER(FDDGIIrradianceBlend)
+    SHADER_USE_PARAMETER_STRUCT(FDDGIIrradianceBlend, FGlobalShader)
+
+    class FRaysPerProbeEnum : SHADER_PERMUTATION_INT("RAYS_PER_PROBE_ENUM", int32(EDDGIRaysPerProbe::Count));
+    class FEnableRelocation : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_RELOCATION");
+    class FDebugFormatRadiance : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_DEBUG_FORMAT_RADIANCE");
+    class FEnableScrolling : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_SCROLL");
+
+    using FPermutationDomain = TShaderPermutationDomain<FRaysPerProbeEnum, FEnableRelocation, FDebugFormatRadiance, FEnableScrolling>;
+
+    static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)
+    {
+        FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);
+
+        OutEnvironment.SetDefine(TEXT("RTXGI_DDGI_PROBE_STATE_CLASSIFIER"), FDDGIVolumeSceneProxy::FComponentData::c_RTXGI_DDGI_PROBE_STATE_CLASSIFIER ? 1 : 0);
+
+        OutEnvironment.SetDefine(TEXT("PROBE_NUM_TEXELS"), FDDGIVolumeSceneProxy::FComponentData::c_NumTexelsIrradiance);
+        OutEnvironment.SetDefine(TEXT("RTXGI_DDGI_BLEND_RADIANCE"), 1);
+
+        // Set to 1 to be able to visualize this in the editor by typing "vis DDGIIrradianceBlendDebug" and later "vis none" to make it go away.
+        // Set to 0 to disable and deadstrip everything related
+        OutEnvironment.SetDefine(TEXT("DDGIIrradianceBlendDebug"), 0);
+
+        // needed for a typed UAV load. This already assumes we are raytracing, so should be fine.
+        OutEnvironment.CompilerFlags.Add(CFLAG_AllowTypedUAVLoads);
+    }
+
+    static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters& Parameters)
+    {
+        return ShouldCompileRayTracingShadersForProject(Parameters.Platform);
+    }
+
+    BEGIN_SHADER_PARAMETER_STRUCT(FParameters, )
+
+        // DDGI volume parameters
+        // {
+            SHADER_PARAMETER(FIntVector, DDGIVolume_probeGridCounts)
+            SHADER_PARAMETER(int, DDGIVolume_numRaysPerProbe)
+            SHADER_PARAMETER(FMatrix, DDGIVolume_probeRayRotationTransform)
+            SHADER_PARAMETER(FVector, DDGIVolume_probeGridSpacing)
+            SHADER_PARAMETER(float, DDGIVolume_probeDistanceExponent)
+            SHADER_PARAMETER(float, DDGIVolume_probeInverseIrradianceEncodingGamma)
+            SHADER_PARAMETER(float, DDGIVolume_probeHysteresis)
+            SHADER_PARAMETER(float, DDGIVolume_probeChangeThreshold)
+            SHADER_PARAMETER(float, DDGIVolume_probeBrightnessThreshold)
+            SHADER_PARAMETER(FIntVector, DDGIVolume_probeScrollOffsets)
+            SHADER_PARAMETER(int, DDGIVolume_ProbeIndexStart)
+            SHADER_PARAMETER(int, DDGIVolume_ProbeIndexCount)
+        // }
+
+        SHADER_PARAMETER_RDG_TEXTURE_UAV(RWTexture2D<float4>, DDGIProbeRTRadianceUAV)
+        SHADER_PARAMETER_UAV(RWTexture2D<uint>, DDGIProbeStates)
+        SHADER_PARAMETER_UAV(RWTexture2D<float4>, DDGIProbeUAV)
+
+        SHADER_PARAMETER_RDG_TEXTURE_UAV(RWTexture2D<float4>, DebugOutput)  // Per unreal RDG presentation, this is deadstripped if the shader doesn't write to it
+
+    END_SHADER_PARAMETER_STRUCT()
+};
+
+IMPLEMENT_GLOBAL_SHADER(FDDGIIrradianceBlend, "/Plugin/RTXGI/Private/SDK/ddgi/ProbeBlendingCS.usf", "DDGIProbeBlendingCS", SF_Compute);
+
+class FDDGIDistanceBlend : public FGlobalShader
+{
+    DECLARE_GLOBAL_SHADER(FDDGIDistanceBlend)
+    SHADER_USE_PARAMETER_STRUCT(FDDGIDistanceBlend, FGlobalShader)
+
+    class FRaysPerProbeEnum : SHADER_PERMUTATION_INT("RAYS_PER_PROBE_ENUM", int32(EDDGIRaysPerProbe::Count));
+    class FEnableRelocation : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_RELOCATION");
+    class FDebugFormatRadiance : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_DEBUG_FORMAT_RADIANCE");
+    class FEnableScrolling : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_SCROLL");
+
+    using FPermutationDomain = TShaderPermutationDomain<FRaysPerProbeEnum, FEnableRelocation, FDebugFormatRadiance, FEnableScrolling>;
+
+    static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)
+    {
+        FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);
+
+        OutEnvironment.SetDefine(TEXT("RTXGI_DDGI_PROBE_STATE_CLASSIFIER"), FDDGIVolumeSceneProxy::FComponentData::c_RTXGI_DDGI_PROBE_STATE_CLASSIFIER ? 1 : 0);
+        OutEnvironment.SetDefine(TEXT("PROBE_NUM_TEXELS"), FDDGIVolumeSceneProxy::FComponentData::c_NumTexelsDistance);
+        OutEnvironment.SetDefine(TEXT("RTXGI_DDGI_BLEND_RADIANCE"), 0);
+
+        // Set to 1 to be able to visualize this in the editor by typing "vis DDGIDistanceBlendDebug" and later "vis none" to make it go away.
+        // Set to 0 to disable and deadstrip everything related
+        OutEnvironment.SetDefine(TEXT("DDGIDistanceBlendDebug"), 0);
+
+        // needed for a typed UAV load. This already assumes we are raytracing, so should be fine.
+        OutEnvironment.CompilerFlags.Add(CFLAG_AllowTypedUAVLoads);
+    }
+
+    static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters& Parameters)
+    {
+        return ShouldCompileRayTracingShadersForProject(Parameters.Platform);
+    }
+
+    BEGIN_SHADER_PARAMETER_STRUCT(FParameters, )
+
+        // DDGI volume parameters
+        // {
+            SHADER_PARAMETER(FIntVector, DDGIVolume_probeGridCounts)
+            SHADER_PARAMETER(int, DDGIVolume_numRaysPerProbe)
+            SHADER_PARAMETER(FMatrix, DDGIVolume_probeRayRotationTransform)
+            SHADER_PARAMETER(FVector, DDGIVolume_probeGridSpacing)
+            SHADER_PARAMETER(float, DDGIVolume_probeDistanceExponent)
+            SHADER_PARAMETER(float, DDGIVolume_probeInverseIrradianceEncodingGamma)
+            SHADER_PARAMETER(float, DDGIVolume_probeHysteresis)
+            SHADER_PARAMETER(float, DDGIVolume_probeChangeThreshold)
+            SHADER_PARAMETER(float, DDGIVolume_probeBrightnessThreshold)
+            SHADER_PARAMETER(FIntVector, DDGIVolume_probeScrollOffsets)
+            SHADER_PARAMETER(int, DDGIVolume_ProbeIndexStart)
+            SHADER_PARAMETER(int, DDGIVolume_ProbeIndexCount)
+        // }
+
+        SHADER_PARAMETER_RDG_TEXTURE_UAV(RWTexture2D<float4>, DDGIProbeRTRadianceUAV)
+        SHADER_PARAMETER_UAV(RWTexture2D<uint>, DDGIProbeStates)
+        SHADER_PARAMETER_UAV(RWTexture2D<float4>, DDGIProbeUAV)
+
+        SHADER_PARAMETER_RDG_TEXTURE_UAV(RWTexture2D<float4>, DebugOutput)  // Per unreal RDG presentation, this is deadstripped if the shader doesn't write to it
+
+    END_SHADER_PARAMETER_STRUCT()
+};
+
+IMPLEMENT_GLOBAL_SHADER(FDDGIDistanceBlend, "/Plugin/RTXGI/Private/SDK/ddgi/ProbeBlendingCS.usf", "DDGIProbeBlendingCS", SF_Compute);
+
+class FDDGIBorderRowUpdate : public FGlobalShader
+{
+    DECLARE_GLOBAL_SHADER(FDDGIBorderRowUpdate)
+    SHADER_USE_PARAMETER_STRUCT(FDDGIBorderRowUpdate, FGlobalShader)
+
+        static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)
+    {
+        FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);
+
+        // needed for a typed UAV load. This already assumes we are raytracing, so should be fine.
+        OutEnvironment.CompilerFlags.Add(CFLAG_AllowTypedUAVLoads);
+    }
+
+    static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters& Parameters)
+    {
+        return ShouldCompileRayTracingShadersForProject(Parameters.Platform);
+    }
+
+    BEGIN_SHADER_PARAMETER_STRUCT(FParameters, )
+        SHADER_PARAMETER(uint32, ProbeNumIrradianceOrDistanceTexels)
+        SHADER_PARAMETER_UAV(RWTexture2D<float4>, DDGIProbeUAV)
+    END_SHADER_PARAMETER_STRUCT()
+};
+
+IMPLEMENT_GLOBAL_SHADER(FDDGIBorderRowUpdate, "/Plugin/RTXGI/Private/SDK/ddgi/ProbeBorderUpdateCS.usf", "DDGIProbeBorderRowUpdateCS", SF_Compute);
+
+class FDDGIBorderColumnUpdate : public FGlobalShader
+{
+    DECLARE_GLOBAL_SHADER(FDDGIBorderColumnUpdate)
+    SHADER_USE_PARAMETER_STRUCT(FDDGIBorderColumnUpdate, FGlobalShader)
+
+        static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)
+    {
+        FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);
+
+        // needed for a typed UAV load. This already assumes we are raytracing, so should be fine.
+        OutEnvironment.CompilerFlags.Add(CFLAG_AllowTypedUAVLoads);
+    }
+
+    static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters& Parameters)
+    {
+        return ShouldCompileRayTracingShadersForProject(Parameters.Platform);
+    }
+
+    BEGIN_SHADER_PARAMETER_STRUCT(FParameters, )
+        SHADER_PARAMETER(uint32, ProbeNumIrradianceOrDistanceTexels)
+        SHADER_PARAMETER_UAV(RWTexture2D<float4>, DDGIProbeUAV)
+    END_SHADER_PARAMETER_STRUCT()
+};
+
+IMPLEMENT_GLOBAL_SHADER(FDDGIBorderColumnUpdate, "/Plugin/RTXGI/Private/SDK/ddgi/ProbeBorderUpdateCS.usf", "DDGIProbeBorderColumnUpdateCS", SF_Compute);
+
+class FDDGIProbesRelocate : public FGlobalShader
+{
+    DECLARE_GLOBAL_SHADER(FDDGIProbesRelocate)
+    SHADER_USE_PARAMETER_STRUCT(FDDGIProbesRelocate, FGlobalShader)
+
+    class FDebugFormatRadiance : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_DEBUG_FORMAT_RADIANCE");
+    class FEnableScrolling : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_SCROLL");
+
+    using FPermutationDomain = TShaderPermutationDomain<FDebugFormatRadiance, FEnableScrolling>;
+
+    static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)
+    {
+        FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);
+
+        OutEnvironment.SetDefine(TEXT("RTXGI_DDGI_PROBE_STATE_CLASSIFIER"), FDDGIVolumeSceneProxy::FComponentData::c_RTXGI_DDGI_PROBE_STATE_CLASSIFIER ? 1 : 0);
+        OutEnvironment.SetDefine(TEXT("RTXGI_DDGI_PROBE_RELOCATION"), 1);
+
+        // needed for a typed UAV load. This already assumes we are raytracing, so should be fine.
+        OutEnvironment.CompilerFlags.Add(CFLAG_AllowTypedUAVLoads);
+    }
+
+    static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters& Parameters)
+    {
+        return ShouldCompileRayTracingShadersForProject(Parameters.Platform);
+    }
+
+    BEGIN_SHADER_PARAMETER_STRUCT(FParameters, )
+        SHADER_PARAMETER(float, ProbeDistanceScale)
+        SHADER_PARAMETER(FVector, DDGIVolume_probeGridSpacing)
+        SHADER_PARAMETER(FIntVector, DDGIVolume_probeGridCounts)
+        SHADER_PARAMETER(int, DDGIVolume_numRaysPerProbe)
+        SHADER_PARAMETER(float, DDGIVolume_probeBackfaceThreshold)
+        SHADER_PARAMETER(FMatrix, DDGIVolume_probeRayRotationTransform)
+        SHADER_PARAMETER(float, DDGIVolume_probeMinFrontfaceDistance)
+        SHADER_PARAMETER(FIntVector, DDGIVolume_ProbeScrollOffsets)
+        SHADER_PARAMETER(int, DDGIVolume_ProbeIndexStart)
+        SHADER_PARAMETER(int, DDGIVolume_ProbeIndexCount)
+
+        SHADER_PARAMETER_RDG_TEXTURE_UAV(RWTexture2D<float4>, DDGIProbeRTRadianceUAV)
+        SHADER_PARAMETER_UAV(RWTexture2D<float4>, DDGIProbeOffsets)
+    END_SHADER_PARAMETER_STRUCT()
+};
+
+IMPLEMENT_GLOBAL_SHADER(FDDGIProbesRelocate, "/Plugin/RTXGI/Private/SDK/ddgi/ProbeRelocationCS.usf", "DDGIProbeRelocationCS", SF_Compute);
+
+class FDDGIProbesClassify : public FGlobalShader
+{
+    DECLARE_GLOBAL_SHADER(FDDGIProbesClassify)
+    SHADER_USE_PARAMETER_STRUCT(FDDGIProbesClassify, FGlobalShader)
+
+    class FEnableRelocation : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_RELOCATION");
+    class FDebugFormatRadiance : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_DEBUG_FORMAT_RADIANCE");
+    class FEnableScrolling : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_SCROLL");
+
+    using FPermutationDomain = TShaderPermutationDomain<FEnableRelocation, FDebugFormatRadiance, FEnableScrolling>;
+
+    static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)
+    {
+        FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);
+
+        OutEnvironment.SetDefine(TEXT("RTXGI_DDGI_PROBE_STATE_CLASSIFIER"), 1);
+
+        // needed for a typed UAV load. This already assumes we are raytracing, so should be fine.
+        OutEnvironment.CompilerFlags.Add(CFLAG_AllowTypedUAVLoads);
+    }
+
+    static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters& Parameters)
+    {
+        return ShouldCompileRayTracingShadersForProject(Parameters.Platform);
+    }
+
+    BEGIN_SHADER_PARAMETER_STRUCT(FParameters, )
+        SHADER_PARAMETER(FVector, DDGIVolume_probeGridSpacing)
+        SHADER_PARAMETER(FIntVector, DDGIVolume_probeGridCounts)
+        SHADER_PARAMETER(int, DDGIVolume_numRaysPerProbe)
+        SHADER_PARAMETER(float, DDGIVolume_probeBackfaceThreshold)
+        SHADER_PARAMETER(FIntVector, DDGIVolume_probeScrollOffsets)
+        SHADER_PARAMETER(int, DDGIVolume_ProbeIndexStart)
+        SHADER_PARAMETER(int, DDGIVolume_ProbeIndexCount)
+
+        SHADER_PARAMETER_RDG_TEXTURE_UAV(RWTexture2D<float4>, DDGIProbeRTRadianceUAV)
+        SHADER_PARAMETER_UAV(RWTexture2D<uint>, DDGIProbeStates)
+    END_SHADER_PARAMETER_STRUCT()
+};
+
+IMPLEMENT_GLOBAL_SHADER(FDDGIProbesClassify, "/Plugin/RTXGI/Private/SDK/ddgi/ProbeStateClassifierCS.usf", "DDGIProbeStateClassifierCS", SF_Compute);
+
+namespace DDGIVolumeUpdate
+{
+    FDelegateHandle AnyRayTracingPassEnabledHandle;
+    FDelegateHandle PrepareRayTracingHandle;
+
+    void DDGIUpdateVolume_RenderThread(const FScene& Scene, const FViewInfo& View, FRDGBuilder& GraphBuilder, FDDGIVolumeSceneProxy* VolProxy);
+
+#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+    void DDGIUpdateVolume_RenderThread_DDGIProbeVis(const FScene& Scene, const FViewInfo& View, FRDGBuilder& GraphBuilder);
+#endif 
+
+    void DDGIUpdateVolume_RenderThread_RTRadiance(const FScene& Scene, const FViewInfo& View, FRDGBuilder& GraphBuilder, FDDGIVolumeSceneProxy* VolProxy, const FMatrix& ProbeRayRotationTransform, FRDGTextureRef ProbesRadianceTex, FRDGTextureUAVRef ProbesRadianceUAV, bool highBitCount);
+    void DDGIUpdateVolume_RenderThread_IrradianceBlend(const FViewInfo& View, FRDGBuilder& GraphBuilder, FDDGIVolumeSceneProxy* VolProxy, const FMatrix& ProbeRayRotationTransform, FRDGTextureUAVRef ProbesRadianceUAV, bool highBitCount);
+    void DDGIUpdateVolume_RenderThread_DistanceBlend(const FViewInfo& View, FRDGBuilder& GraphBuilder, FDDGIVolumeSceneProxy* VolProxy, const FMatrix& ProbeRayRotationTransform, FRDGTextureUAVRef ProbesRadianceUAV, bool highBitCount);
+    void DDGIUpdateVolume_RenderThread_IrradianceBorderUpdate(const FViewInfo& View, FRDGBuilder& GraphBuilder, FDDGIVolumeSceneProxy* VolProxy);
+    void DDGIUpdateVolume_RenderThread_DistanceBorderUpdate(const FViewInfo& View, FRDGBuilder& GraphBuilder, FDDGIVolumeSceneProxy* VolProxy);
+    void DDGIUpdateVolume_RenderThread_RelocateProbes(FRDGBuilder& GraphBuilder, FDDGIVolumeSceneProxy* VolProxy, const FMatrix& ProbeRayRotationTransform, FRDGTextureUAVRef ProbesRadianceUAV, bool highBitCount);
+    void DDGIUpdateVolume_RenderThread_ClassifyProbes(FRDGBuilder& GraphBuilder, FDDGIVolumeSceneProxy* VolProxy, FRDGTextureUAVRef ProbesRadianceUAV, bool highBitCount);
+
+    void PrepareRayTracingShaders(const FViewInfo& View, TArray<FRHIRayTracingShader*>& OutRayGenShaders);
+
+    bool ShouldRenderRayTracingEffect(bool bEffectEnabled)
+    {
+        if (!IsRayTracingEnabled())
+        {
+            return false;
+        }
+
+        static auto CVar = IConsoleManager::Get().FindConsoleVariable(TEXT("r.RayTracing.ForceAllRayTracingEffects"));
+        const int32 OverrideMode = CVar != nullptr ? CVar->GetInt() : -1;
+
+        if (OverrideMode >= 0)
+        {
+            return OverrideMode > 0;
+        }
+        else
+        {
+            return bEffectEnabled;
+        }
+    }
+
+    // ---------------------- IMPLEMENTATION ------------------
+
+    bool ShouldDynamicUpdate(const FViewInfo& View)
+    {
+        return ShouldRenderRayTracingEffect(true) && View.RayTracingScene.RayTracingSceneRHI != nullptr;
+    }
+
+    void Startup()
+    {
+        FGlobalIlluminationExperimentalPluginDelegates::FPrepareRayTracing& PRTDelegate = FGlobalIlluminationExperimentalPluginDelegates::PrepareRayTracing();
+        PrepareRayTracingHandle = PRTDelegate.AddStatic(PrepareRayTracingShaders);
+
+        FGlobalIlluminationExperimentalPluginDelegates::FAnyRayTracingPassEnabled& ARTPEDelegate = FGlobalIlluminationExperimentalPluginDelegates::AnyRayTracingPassEnabled();
+        AnyRayTracingPassEnabledHandle = ARTPEDelegate.AddStatic(
+            [](bool& anyEnabled)
+            {
+                anyEnabled |= true;
+            }
+        );
+    }
+
+    void Shutdown()
+    {
+        FGlobalIlluminationExperimentalPluginDelegates::FPrepareRayTracing& PRTDelegate = FGlobalIlluminationExperimentalPluginDelegates::PrepareRayTracing();
+        check(PrepareRayTracingHandle.IsValid());
+        PRTDelegate.Remove(PrepareRayTracingHandle);
+
+        FGlobalIlluminationExperimentalPluginDelegates::FAnyRayTracingPassEnabled& ARTPEDelegate = FGlobalIlluminationExperimentalPluginDelegates::AnyRayTracingPassEnabled();
+        check(AnyRayTracingPassEnabledHandle.IsValid());
+        ARTPEDelegate.Remove(AnyRayTracingPassEnabledHandle);
+    }
+
+    static void CopyTexture_RenderThread(FRHICommandList& RHICmdList, FTexture2DRHIRef dest, FDDGITexturePixels src)
+    {
+        // Early out if the textures are not compatible
+        if (!dest || !src.texture || dest->GetSizeX() != src.w || dest->GetSizeY() != src.h) return;
+
+        // Transition the source texture to a copy source and destination texture to a copy destination
+        RHICmdList.Transition(FRHITransitionInfo(src.texture, ERHIAccess::WritableMask, ERHIAccess::CopySrc));
+        RHICmdList.Transition(FRHITransitionInfo(dest, ERHIAccess::WritableMask, ERHIAccess::CopyDest));
+
+        RHICmdList.CopyTexture(src.texture, dest, FRHICopyTextureInfo{});
+
+        // Transition the source and destination textures back to general
+        RHICmdList.Transition(FRHITransitionInfo(src.texture, ERHIAccess::CopySrc, ERHIAccess::WritableMask));
+        RHICmdList.Transition(FRHITransitionInfo(dest, ERHIAccess::CopyDest, ERHIAccess::WritableMask));
+    }
+
+    void DDGIUpdatePerFrame_RenderThread(const FScene& Scene, const FViewInfo& View, FRDGBuilder& GraphBuilder)
+    {
+        // ASSUMES RENDERTHREAD
+        check(IsInRenderingThread() || IsInParallelRenderingThread());
+
+#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+        DDGIUpdateVolume_RenderThread_DDGIProbeVis(Scene, View, GraphBuilder);
+#endif
+
+        // Gather the list of volumes to update
+        TArray<FDDGIVolumeSceneProxy*> sceneVolumes;
+        float totalPriority = 0.0f;
+        for (FDDGIVolumeSceneProxy* proxy : FDDGIVolumeSceneProxy::AllProxiesReadyForRender_RenderThread)
+        {
+            // Copy the volume's texture data to the GPU, if loading from disk has finished
+            if (proxy->TextureLoadContext.ReadyForLoad)
+            {
+                GraphBuilder.AddPass(
+                    RDG_EVENT_NAME("DDGI Volume Texture Loading"),
+                    GraphBuilder.AllocParameters<FDummyShaderParameters>(),
+                    ERDGPassFlags::Compute | ERDGPassFlags::NeverCull,
+                    [proxy](FRHICommandList& RHICmdList)
+                    {
+                        if (!proxy->TextureLoadContext.ReadyForLoad) return;
+
+                        CopyTexture_RenderThread(RHICmdList, proxy->ProbesIrradianceTex, proxy->TextureLoadContext.Irradiance);
+                        CopyTexture_RenderThread(RHICmdList, proxy->ProbesDistanceTex, proxy->TextureLoadContext.Distance);
+                        CopyTexture_RenderThread(RHICmdList, proxy->ProbesOffsetsTex, proxy->TextureLoadContext.Offsets);
+                        CopyTexture_RenderThread(RHICmdList, proxy->ProbesStatesTex, proxy->TextureLoadContext.States);
+                        proxy->TextureLoadContext.Clear();
+                    }
+                );
+            }
+
+            // Don't update the volume if it isn't part of the current scene
+            if (proxy->OwningScene != &Scene) continue;
+
+            // Don't update static runtime volumes during gameplay
+            if (View.bIsGameView && proxy->ComponentData.RuntimeStatic) continue;
+
+            // Don't update the volume if it is disabled
+            if (!proxy->ComponentData.EnableVolume) continue;
+
+            sceneVolumes.Add(proxy);
+            totalPriority += proxy->ComponentData.UpdatePriority;
+        }
+
+        // Advance the scene's round robin value by the golden ratio (conjugate) and use that 
+        // as a "random number" to give each volume a fair turn at recieving an update.
+        float& value = FDDGIVolumeSceneProxy::SceneRoundRobinValue.FindOrAdd(&Scene);
+        value += 0.61803398875f;
+        value -= floor(value);
+
+        // Update the relevant volumes with ray tracing
+        float desiredPriority = totalPriority * value;
+        for (int index = 0; index < sceneVolumes.Num(); ++index)
+        {
+            desiredPriority -= sceneVolumes[index]->ComponentData.UpdatePriority;
+            if (desiredPriority <= 0.0f || index == sceneVolumes.Num() - 1)
+            {
+                DDGIUpdateVolume_RenderThread(Scene, View, GraphBuilder, sceneVolumes[index]);
+                break;
+            }
+        }
+    }
+
+    void PrepareRayTracingShaders(const FViewInfo& View, TArray<FRHIRayTracingShader*>& OutRayGenShaders)
+    {
+        const auto FeatureLevel = GMaxRHIFeatureLevel;
+        auto ShaderMap = GetGlobalShaderMap(FeatureLevel);
+
+        for (int i = 0; i < 16; ++i)
+        {
+            FRayTracingRTXGIProbeUpdateRGS::FPermutationDomain PermutationVector;
+            PermutationVector.Set<FRayTracingRTXGIProbeUpdateRGS::FEnableTwoSidedGeometryDim>(true);
+            PermutationVector.Set<FRayTracingRTXGIProbeUpdateRGS::FEnableMaterialsDim>(false);
+            PermutationVector.Set<FRayTracingRTXGIProbeUpdateRGS::FDecoupleSampleGeneration>(false);
+            PermutationVector.Set<FRayTracingRTXGIProbeUpdateRGS::FEnableRelocation>((i & 1) != 0 ? true : false);
+            PermutationVector.Set<FRayTracingRTXGIProbeUpdateRGS::FDebugFormatRadiance>((i & 2) != 0 ? true : false);
+            PermutationVector.Set<FRayTracingRTXGIProbeUpdateRGS::FEnableScrolling>((i & 4) != 0 ? true : false);
+            PermutationVector.Set<FRayTracingRTXGIProbeUpdateRGS::FSkyLight>((i & 8) != 0 ? true : false);
+            TShaderMapRef<FRayTracingRTXGIProbeUpdateRGS> RayGenerationShader(ShaderMap, PermutationVector);
+
+            OutRayGenShaders.Add(RayGenerationShader.GetRayTracingShader());
+        }
+
+        #if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+        {
+            FRayTracingRTXGIProbeViewRGS::FPermutationDomain PermutationVector;
+            PermutationVector.Set<FRayTracingRTXGIProbeViewRGS::FEnableTwoSidedGeometryDim>(true);
+            PermutationVector.Set<FRayTracingRTXGIProbeViewRGS::FEnableMaterialsDim>(false);
+            PermutationVector.Set<FRayTracingRTXGIProbeViewRGS::FDecoupleSampleGeneration>(false);
+            PermutationVector.Set<FRayTracingRTXGIProbeViewRGS::FVolumeDebugView>(0);
+            TShaderMapRef<FRayTracingRTXGIProbeViewRGS> RayGenerationShader(ShaderMap, PermutationVector);
+            OutRayGenShaders.Add(RayGenerationShader.GetRayTracingShader());
+        }
+
+        {
+            FRayTracingRTXGIProbeViewRGS::FPermutationDomain PermutationVector;
+            PermutationVector.Set<FRayTracingRTXGIProbeViewRGS::FEnableTwoSidedGeometryDim>(true);
+            PermutationVector.Set<FRayTracingRTXGIProbeViewRGS::FEnableMaterialsDim>(false);
+            PermutationVector.Set<FRayTracingRTXGIProbeViewRGS::FDecoupleSampleGeneration>(false);
+            PermutationVector.Set<FRayTracingRTXGIProbeViewRGS::FVolumeDebugView>(1);
+            TShaderMapRef<FRayTracingRTXGIProbeViewRGS> RayGenerationShader(ShaderMap, PermutationVector);
+            OutRayGenShaders.Add(RayGenerationShader.GetRayTracingShader());
+        }
+        #endif //!(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+    }
+
+    void DDGIUpdateVolume_RenderThread(const FScene& Scene, const FViewInfo& View, FRDGBuilder& GraphBuilder, FDDGIVolumeSceneProxy* VolProxy)
+    {
+        // Early out if ray tracing is not enabled
+        if (!ShouldDynamicUpdate(View)) return;
+
+        bool highBitCount = (GetDefault<URTXGIPluginSettings>()->IrradianceBits == EDDGIIrradianceBits::n32);
+
+        // ASSUMES RENDERTHREAD
+        check(IsInRenderingThread() || IsInParallelRenderingThread());
+        check(VolProxy);
+
+        FMatrix ProbeRayRotationTransform = ComputeRandomRotation();
+
+        // Create the temporary radiance texture & UAV
+        FRDGTextureRef ProbesRadianceTex;
+        FRDGTextureUAVRef ProbesRadianceUAV;
+        {
+            const FDDGIVolumeSceneProxy::FComponentData& ComponentData = VolProxy->ComponentData;
+            FRDGTextureDesc DDGIDebugOutputDesc = FRDGTextureDesc::Create2D(
+                FIntPoint
+                {
+                    (int32)ComponentData.GetNumRaysPerProbe(),
+                    (int32)ComponentData.ProbeCounts.X * ComponentData.ProbeCounts.Y * ComponentData.ProbeCounts.Z,
+                },
+                // This texture stores both color and distance
+                highBitCount ? FDDGIVolumeSceneProxy::FComponentData::c_pixelFormatRadianceHighBitDepth : FDDGIVolumeSceneProxy::FComponentData::c_pixelFormatRadianceLowBitDepth,
+                FClearValueBinding::None,
+                TexCreate_ShaderResource | TexCreate_UAV
+            );
+
+            ProbesRadianceTex = GraphBuilder.CreateTexture(DDGIDebugOutputDesc, TEXT("DDGIVolumeRadiance"));
+            ProbesRadianceUAV = GraphBuilder.CreateUAV(ProbesRadianceTex);
+        }
+
+        DDGIUpdateVolume_RenderThread_RTRadiance(Scene, View, GraphBuilder, VolProxy, ProbeRayRotationTransform, ProbesRadianceTex, ProbesRadianceUAV, highBitCount);
+        DDGIUpdateVolume_RenderThread_IrradianceBlend(View, GraphBuilder, VolProxy, ProbeRayRotationTransform, ProbesRadianceUAV, highBitCount);
+        DDGIUpdateVolume_RenderThread_DistanceBlend(View, GraphBuilder, VolProxy, ProbeRayRotationTransform, ProbesRadianceUAV, highBitCount);
+        DDGIUpdateVolume_RenderThread_IrradianceBorderUpdate(View, GraphBuilder, VolProxy);
+        DDGIUpdateVolume_RenderThread_DistanceBorderUpdate(View, GraphBuilder, VolProxy);
+
+        if (VolProxy->ComponentData.EnableProbeRelocation)
+        {
+            DDGIUpdateVolume_RenderThread_RelocateProbes(GraphBuilder, VolProxy, ProbeRayRotationTransform, ProbesRadianceUAV, highBitCount);
+        }
+
+        if (FDDGIVolumeSceneProxy::FComponentData::c_RTXGI_DDGI_PROBE_STATE_CLASSIFIER)
+        {
+            DDGIUpdateVolume_RenderThread_ClassifyProbes(GraphBuilder, VolProxy, ProbesRadianceUAV, highBitCount);
+        }
+    }
+
+#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+    void DDGIUpdateVolume_RenderThread_DDGIProbeVis(const FScene& Scene, const FViewInfo& View, FRDGBuilder& GraphBuilder)
+    {
+        // Early out if not visualizing probes
+        int DDGIProbeVis = CVarDDGIProbeVis.GetValueOnRenderThread();
+        if (DDGIProbeVis == 0 || View.RayTracingScene.RayTracingSceneRHI == nullptr) return;
+
+        static const int c_probeVisWidth = 800;
+        static const int c_probeVisHeight = 600;
+
+        // create the texture and uav being rendered to
+        FRDGTextureDesc ProbeVisTex = FRDGTextureDesc::Create2D(
+            FIntPoint(c_probeVisWidth, c_probeVisHeight),
+            EPixelFormat::PF_A32B32G32R32F,
+            FClearValueBinding::None,
+            TexCreate_ShaderResource | TexCreate_UAV
+        );
+        FRDGTextureUAVRef ProbeVisUAV = GraphBuilder.CreateUAV(GraphBuilder.CreateTexture(ProbeVisTex, TEXT("DDGIProbeVis")));
+
+        // get the shader
+        const auto FeatureLevel = GMaxRHIFeatureLevel;
+        auto ShaderMap = GetGlobalShaderMap(FeatureLevel);
+        FRayTracingRTXGIProbeViewRGS::FPermutationDomain PermutationVector;
+        PermutationVector.Set<FRayTracingRTXGIProbeViewRGS::FEnableTwoSidedGeometryDim>(true);
+        PermutationVector.Set<FRayTracingRTXGIProbeViewRGS::FEnableMaterialsDim>(false);
+        PermutationVector.Set<FRayTracingRTXGIProbeViewRGS::FDecoupleSampleGeneration>(false);
+        PermutationVector.Set<FRayTracingRTXGIProbeViewRGS::FVolumeDebugView>(DDGIProbeVis - 1);
+        TShaderMapRef<FRayTracingRTXGIProbeViewRGS> RayGenerationShader(ShaderMap, PermutationVector);
+
+        // fill out shader parameters
+        FRayTracingRTXGIProbeViewRGS::FParameters DefaultPassParameters;
+        FRayTracingRTXGIProbeViewRGS::FParameters* PassParameters = GraphBuilder.AllocParameters<FRayTracingRTXGIProbeViewRGS::FParameters>();
+        *PassParameters = DefaultPassParameters;
+
+        PassParameters->DDGIVolume_PreExposure = View.PreExposure;
+        PassParameters->DDGIVolume_ShouldUsePreExposure = View.Family->EngineShowFlags.Tonemapper;
+
+        PassParameters->CameraPos = View.ViewMatrices.GetViewOrigin();
+        PassParameters->CameraMatrix = View.ViewMatrices.GetViewMatrix().Inverse();
+
+        PassParameters->TLAS = View.RayTracingScene.RayTracingSceneRHI->GetShaderResourceView();
+        check(PassParameters->TLAS);
+        PassParameters->RadianceOutput = ProbeVisUAV;
+        PassParameters->FrameRandomSeed = GFrameNumber;
+
+        // skylight parameters
+        if (Scene.SkyLight && Scene.SkyLight->ProcessedTexture)
+        {
+            PassParameters->Sky_Color = FVector(Scene.SkyLight->GetEffectiveLightColor());
+            PassParameters->Sky_Texture = Scene.SkyLight->ProcessedTexture->TextureRHI;
+            PassParameters->Sky_TextureSampler = Scene.SkyLight->ProcessedTexture->SamplerStateRHI;
+        }
+        else
+        {
+            PassParameters->Sky_Color = FVector(0.0);
+            PassParameters->Sky_Texture = GBlackTextureCube->TextureRHI;
+            PassParameters->Sky_TextureSampler = TStaticSamplerState<SF_Bilinear, AM_Clamp, AM_Clamp, AM_Clamp>::GetRHI();
+        }
+
+        PassParameters->SSProfilesTexture = GraphBuilder.RegisterExternalTexture(View.RayTracingSubSurfaceProfileTexture);
+        PassParameters->ViewUniformBuffer = View.ViewUniformBuffer;
+        PassParameters->LightDataPacked = View.RayTracingLightData.UniformBuffer;
+
+        FIntPoint DispatchSize(c_probeVisWidth, c_probeVisHeight);
+
+        GraphBuilder.AddPass(
+            RDG_EVENT_NAME("DDGI RTRadiance %dx%d", DispatchSize.X, DispatchSize.Y),
+            PassParameters,
+            ERDGPassFlags::Compute,
+            [PassParameters, &View, RayGenerationShader, DispatchSize](FRHICommandList& RHICmdList)
+            {
+                FRayTracingShaderBindingsWriter GlobalResources;
+                SetShaderParameters(GlobalResources, RayGenerationShader, *PassParameters);
+
+                FRHIRayTracingScene* RayTracingSceneRHI = View.RayTracingScene.RayTracingSceneRHI;
+                RHICmdList.RayTraceDispatch(View.RayTracingMaterialPipeline, RayGenerationShader.GetRayTracingShader(), RayTracingSceneRHI, GlobalResources, DispatchSize.X, DispatchSize.Y);
+            }
+        );
+    }
+#endif //!(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+
+    void DDGIUpdateVolume_RenderThread_RTRadiance(const FScene& Scene, const FViewInfo& View, FRDGBuilder& GraphBuilder, FDDGIVolumeSceneProxy* VolProxy, const FMatrix& ProbeRayRotationTransform, FRDGTextureRef ProbesRadianceTex, FRDGTextureUAVRef ProbesRadianceUAV, bool highBitCount)
+    {
+        // Deal with probe ray budgets, and updating probes in a round robin fashion within the volume
+        int ProbeUpdateRayBudget = GetDefault<URTXGIPluginSettings>()->ProbeUpdateRayBudget;
+        if (ProbeUpdateRayBudget == 0)
+        {
+            VolProxy->ProbeIndexStart = 0;
+            VolProxy->ProbeIndexCount = VolProxy->ComponentData.GetProbeCount();
+        }
+        else
+        {
+            int ProbeCount = VolProxy->ComponentData.GetProbeCount();
+            int ProbeUpdateBudget = ProbeUpdateRayBudget / VolProxy->ComponentData.GetNumRaysPerProbe();
+            if (ProbeUpdateBudget < 1)
+                ProbeUpdateBudget = 1;
+            if (ProbeUpdateBudget > ProbeCount)
+                ProbeUpdateBudget = ProbeCount;
+            VolProxy->ProbeIndexStart += ProbeUpdateBudget;
+            VolProxy->ProbeIndexStart = VolProxy->ProbeIndexStart % ProbeCount;
+            VolProxy->ProbeIndexCount = ProbeUpdateBudget;
+        }
+
+        const auto FeatureLevel = GMaxRHIFeatureLevel;
+        auto ShaderMap = GetGlobalShaderMap(FeatureLevel);
+
+        FRayTracingRTXGIProbeUpdateRGS::FPermutationDomain PermutationVector;
+        PermutationVector.Set<FRayTracingRTXGIProbeUpdateRGS::FEnableTwoSidedGeometryDim>(true);
+        PermutationVector.Set<FRayTracingRTXGIProbeUpdateRGS::FEnableMaterialsDim>(false);
+        PermutationVector.Set<FRayTracingRTXGIProbeUpdateRGS::FDecoupleSampleGeneration>(false);
+        PermutationVector.Set<FRayTracingRTXGIProbeUpdateRGS::FEnableRelocation>(VolProxy->ComponentData.EnableProbeRelocation);
+        PermutationVector.Set<FRayTracingRTXGIProbeUpdateRGS::FDebugFormatRadiance>(highBitCount);
+        PermutationVector.Set<FRayTracingRTXGIProbeUpdateRGS::FEnableScrolling>(VolProxy->ComponentData.EnableProbeScrolling);
+        PermutationVector.Set<FRayTracingRTXGIProbeUpdateRGS::FSkyLight>(VolProxy->ComponentData.SkyLight);
+        TShaderMapRef<FRayTracingRTXGIProbeUpdateRGS> RayGenerationShader(ShaderMap, PermutationVector);
+
+        FRayTracingRTXGIProbeUpdateRGS::FParameters DefaultPassParameters;
+        FRayTracingRTXGIProbeUpdateRGS::FParameters* PassParameters = GraphBuilder.AllocParameters<FRayTracingRTXGIProbeUpdateRGS::FParameters>();
+        *PassParameters = DefaultPassParameters;
+
+        PassParameters->TLAS = View.RayTracingScene.RayTracingSceneRHI->GetShaderResourceView();
+        check(PassParameters->TLAS);
+        PassParameters->RadianceOutput = ProbesRadianceUAV;
+        PassParameters->FrameRandomSeed = GFrameNumber;
+
+        // skylight parameters
+        if (Scene.SkyLight && Scene.SkyLight->ProcessedTexture)
+        {
+            PassParameters->Sky_Color = FVector(Scene.SkyLight->GetEffectiveLightColor());
+            PassParameters->Sky_Texture = Scene.SkyLight->ProcessedTexture->TextureRHI;
+            PassParameters->Sky_TextureSampler = Scene.SkyLight->ProcessedTexture->SamplerStateRHI;
+        }
+        else
+        {
+            PassParameters->Sky_Color = FVector(0.0);
+            PassParameters->Sky_Texture = GBlackTextureCube->TextureRHI;
+            PassParameters->Sky_TextureSampler = TStaticSamplerState<SF_Bilinear, AM_Clamp, AM_Clamp, AM_Clamp>::GetRHI();
+        }
+
+        // DDGI Volume Parameters
+        {
+            PassParameters->DDGIVolume.ProbeIrradiance = VolProxy->ProbesIrradianceTex;
+            PassParameters->DDGIVolume.ProbeDistance = VolProxy->ProbesDistanceTex;
+            PassParameters->DDGIVolume.ProbeOffsets = VolProxy->ProbesOffsetsUAV ? VolProxy->ProbesOffsetsUAV : GBlackTextureWithUAV->UnorderedAccessViewRHI;
+            PassParameters->DDGIVolume.ProbeStates = VolProxy->ProbesStatesTex;
+
+            PassParameters->DDGIVolume.Origin = VolProxy->ComponentData.Origin;
+            FQuat rotation = VolProxy->ComponentData.Transform.GetRotation();
+            PassParameters->DDGIVolume.Rotation = FVector4{ rotation.X, rotation.Y, rotation.Z, rotation.W };
+            PassParameters->DDGIVolume.ProbeMaxRayDistance = VolProxy->ComponentData.ProbeMaxRayDistance;
+            PassParameters->DDGIVolume.ProbeGridCounts = VolProxy->ComponentData.ProbeCounts;
+            PassParameters->DDGIVolume.ProbeRayRotationTransform = ProbeRayRotationTransform;
+            PassParameters->DDGIVolume.NumRaysPerProbe = VolProxy->ComponentData.GetNumRaysPerProbe();
+
+            // calculate grid spacing based on size (scale) and probe count
+            // regarding the *200: the scale is the radius so we need to double it. There is also an implict * 100 of the basic box.
+            FVector volumeSize = VolProxy->ComponentData.Transform.GetScale3D() * 200.0f;
+            FVector probeGridSpacing;
+            probeGridSpacing.X = volumeSize.X / float(VolProxy->ComponentData.ProbeCounts.X);
+            probeGridSpacing.Y = volumeSize.Y / float(VolProxy->ComponentData.ProbeCounts.Y);
+            probeGridSpacing.Z = volumeSize.Z / float(VolProxy->ComponentData.ProbeCounts.Z);
+            PassParameters->DDGIVolume.ProbeGridSpacing = probeGridSpacing;
+
+            PassParameters->DDGIVolume.Radius = VolProxy->ComponentData.Transform.GetScale3D() * 100.0f;
+            PassParameters->DDGIVolume.ProbeNumIrradianceTexels = FDDGIVolumeSceneProxy::FComponentData::c_NumTexelsIrradiance;
+            PassParameters->DDGIVolume.ProbeNumDistanceTexels = FDDGIVolumeSceneProxy::FComponentData::c_NumTexelsDistance;
+            PassParameters->DDGIVolume.ProbeIrradianceEncodingGamma = VolProxy->ComponentData.ProbeIrradianceEncodingGamma;
+            PassParameters->DDGIVolume.NormalBias = VolProxy->ComponentData.NormalBias;
+            PassParameters->DDGIVolume.ViewBias = VolProxy->ComponentData.ViewBias;
+            PassParameters->DDGIVolume.ProbeScrollOffsets = VolProxy->ComponentData.ProbeScrollOffsets;
+            PassParameters->DDGIVolume.IrradianceScalar = VolProxy->ComponentData.IrradianceScalar;
+            PassParameters->DDGIVolume.EmissiveMultiplier = VolProxy->ComponentData.EmissiveMultiplier;
+            PassParameters->DDGIVolume.ProbeIndexStart = VolProxy->ProbeIndexStart;
+            PassParameters->DDGIVolume.ProbeIndexCount = VolProxy->ProbeIndexCount;
+            PassParameters->DDGIVolume.LinearClampSampler = TStaticSamplerState<SF_Trilinear, AM_Clamp, AM_Clamp, AM_Clamp>::GetRHI();
+        }
+
+        FRDGTextureDesc DDGIDebugOutputDesc = FRDGTextureDesc::Create2D(
+            ProbesRadianceTex->Desc.Extent,
+            ProbesRadianceTex->Desc.Format,
+            FClearValueBinding::None,
+            TexCreate_ShaderResource | TexCreate_UAV
+        );
+        PassParameters->DebugOutput = GraphBuilder.CreateUAV(GraphBuilder.CreateTexture(DDGIDebugOutputDesc, TEXT("DDGIVolumeUpdateDebug")));
+
+        PassParameters->SSProfilesTexture = GraphBuilder.RegisterExternalTexture(View.RayTracingSubSurfaceProfileTexture);
+        PassParameters->ViewUniformBuffer = View.ViewUniformBuffer;
+        PassParameters->LightDataPacked = View.RayTracingLightData.UniformBuffer;
+
+        FIntPoint DispatchSize = ProbesRadianceTex->Desc.Extent;
+
+        FUnorderedAccessViewRHIRef irradianceUAV = VolProxy->ProbesIrradianceUAV;
+        FUnorderedAccessViewRHIRef distanceUAV = VolProxy->ProbesDistanceUAV;
+
+        GraphBuilder.AddPass(
+            RDG_EVENT_NAME("DDGI RTRadiance %dx%d", DispatchSize.X, DispatchSize.Y),
+            PassParameters,
+            ERDGPassFlags::Compute,
+            [PassParameters, &View, RayGenerationShader, DispatchSize, irradianceUAV, distanceUAV, ProbesRadianceTex](FRHICommandList& RHICmdList)
+            {
+                FRayTracingShaderBindingsWriter GlobalResources;
+                SetShaderParameters(GlobalResources, RayGenerationShader, *PassParameters);
+
+                FRHIRayTracingScene* RayTracingSceneRHI = View.RayTracingScene.RayTracingSceneRHI;
+                RHICmdList.RayTraceDispatch(View.RayTracingMaterialPipeline, RayGenerationShader.GetRayTracingShader(), RayTracingSceneRHI, GlobalResources, DispatchSize.X, DispatchSize.Y);
+
+                // Irradiance and distance are read during the probe update rgs above to give infinite bounce lighting.
+                // They are going to be written next based on these results.
+                RHICmdList.Transition(FRHITransitionInfo(irradianceUAV, ERHIAccess::ERWBarrier, ERHIAccess::ERWBarrier));
+                RHICmdList.Transition(FRHITransitionInfo(distanceUAV, ERHIAccess::ERWBarrier, ERHIAccess::ERWBarrier));
+            }
+        );
+    }
+
+    void DDGIUpdateVolume_RenderThread_IrradianceBlend(const FViewInfo& View, FRDGBuilder& GraphBuilder, FDDGIVolumeSceneProxy* VolProxy, const FMatrix& ProbeRayRotationTransform, FRDGTextureUAVRef ProbesRadianceUAV, bool highBitCount)
+    {
+        FGlobalShaderMap* ShaderMap = GetGlobalShaderMap(ERHIFeatureLevel::SM5);
+        FDDGIIrradianceBlend::FPermutationDomain PermutationVector;
+        PermutationVector.Set<FDDGIIrradianceBlend::FRaysPerProbeEnum>(int(VolProxy->ComponentData.RaysPerProbe));
+        PermutationVector.Set<FDDGIIrradianceBlend::FEnableRelocation>(VolProxy->ComponentData.EnableProbeRelocation);
+        PermutationVector.Set<FDDGIIrradianceBlend::FDebugFormatRadiance>(highBitCount);
+        PermutationVector.Set<FDDGIIrradianceBlend::FEnableScrolling>(VolProxy->ComponentData.EnableProbeScrolling);
+        TShaderMapRef<FDDGIIrradianceBlend> ComputeShader(ShaderMap, PermutationVector);
+
+        FDDGIIrradianceBlend::FParameters DefaultPassParameters;
+        FDDGIIrradianceBlend::FParameters* PassParameters = GraphBuilder.AllocParameters<FDDGIIrradianceBlend::FParameters>();
+        *PassParameters = DefaultPassParameters;
+
+        PassParameters->DDGIVolume_probeGridCounts = VolProxy->ComponentData.ProbeCounts;
+        PassParameters->DDGIVolume_numRaysPerProbe = VolProxy->ComponentData.GetNumRaysPerProbe();
+        PassParameters->DDGIVolume_probeRayRotationTransform = ProbeRayRotationTransform;
+        PassParameters->DDGIVolume_probeDistanceExponent = VolProxy->ComponentData.ProbeDistanceExponent;
+        PassParameters->DDGIVolume_probeInverseIrradianceEncodingGamma = 1.0f / VolProxy->ComponentData.ProbeIrradianceEncodingGamma;
+        PassParameters->DDGIVolume_probeHysteresis = VolProxy->ComponentData.ProbeHysteresis;
+        PassParameters->DDGIVolume_probeChangeThreshold = VolProxy->ComponentData.ProbeChangeThreshold;
+        PassParameters->DDGIVolume_probeBrightnessThreshold = VolProxy->ComponentData.ProbeBrightnessThreshold;
+        PassParameters->DDGIVolume_probeScrollOffsets = VolProxy->ComponentData.ProbeScrollOffsets;
+        PassParameters->DDGIVolume_ProbeIndexStart = VolProxy->ProbeIndexStart;
+        PassParameters->DDGIVolume_ProbeIndexCount = VolProxy->ProbeIndexCount;
+
+        // calculate grid spacing based on size (scale) and probe count
+        // regarding the *200: the scale is the radius so we need to double it. There is also an implict * 100 of the basic box.
+        FVector volumeSize = VolProxy->ComponentData.Transform.GetScale3D() * 200.0f;
+        FVector probeGridSpacing;
+        probeGridSpacing.X = volumeSize.X / float(VolProxy->ComponentData.ProbeCounts.X);
+        probeGridSpacing.Y = volumeSize.Y / float(VolProxy->ComponentData.ProbeCounts.Y);
+        probeGridSpacing.Z = volumeSize.Z / float(VolProxy->ComponentData.ProbeCounts.Z);
+        PassParameters->DDGIVolume_probeGridSpacing = probeGridSpacing;
+
+        PassParameters->DDGIProbeRTRadianceUAV = ProbesRadianceUAV;
+        PassParameters->DDGIProbeUAV = VolProxy->ProbesIrradianceUAV;
+        PassParameters->DDGIProbeStates = VolProxy->ProbesStatesUAV ? VolProxy->ProbesStatesUAV : GBlackTextureWithUAV->UnorderedAccessViewRHI;
+
+        FRDGTextureDesc DDGIDebugOutputDesc = FRDGTextureDesc::Create2D(
+            VolProxy->ProbesIrradianceTex->GetSizeXY(),
+            VolProxy->ProbesIrradianceTex->GetFormat(),
+            FClearValueBinding::None,
+            TexCreate_ShaderResource | TexCreate_UAV
+        );
+        PassParameters->DebugOutput = GraphBuilder.CreateUAV(GraphBuilder.CreateTexture(DDGIDebugOutputDesc, TEXT("DDGIIrradianceBlendDebug")));
+
+        FIntPoint ProbeCount2D = VolProxy->ComponentData.Get2DProbeCount();
+        FComputeShaderUtils::AddPass(
+            GraphBuilder,
+            RDG_EVENT_NAME("DDGI Radiance Blend"),
+            ComputeShader,
+            PassParameters,
+            FIntVector(ProbeCount2D.X, ProbeCount2D.Y, 1)
+        );
+    }
+
+    void DDGIUpdateVolume_RenderThread_DistanceBlend(const FViewInfo& View, FRDGBuilder& GraphBuilder, FDDGIVolumeSceneProxy* VolProxy, const FMatrix& ProbeRayRotationTransform, FRDGTextureUAVRef ProbesRadianceUAV, bool highBitCount)
+    {
+        FGlobalShaderMap* ShaderMap = GetGlobalShaderMap(ERHIFeatureLevel::SM5);
+        FDDGIDistanceBlend::FPermutationDomain PermutationVector;
+        PermutationVector.Set<FDDGIDistanceBlend::FRaysPerProbeEnum>(int(VolProxy->ComponentData.RaysPerProbe));
+        PermutationVector.Set<FDDGIDistanceBlend::FEnableRelocation>(int(VolProxy->ComponentData.EnableProbeRelocation));
+        PermutationVector.Set<FDDGIDistanceBlend::FDebugFormatRadiance>(highBitCount);
+        PermutationVector.Set<FDDGIDistanceBlend::FEnableScrolling>(int(VolProxy->ComponentData.EnableProbeScrolling));
+        TShaderMapRef<FDDGIDistanceBlend> ComputeShader(ShaderMap, PermutationVector);
+
+        FDDGIDistanceBlend::FParameters DefaultPassParameters;
+        FDDGIDistanceBlend::FParameters* PassParameters = GraphBuilder.AllocParameters<FDDGIDistanceBlend::FParameters>();
+        *PassParameters = DefaultPassParameters;
+
+        PassParameters->DDGIVolume_probeGridCounts = VolProxy->ComponentData.ProbeCounts;
+        PassParameters->DDGIVolume_numRaysPerProbe = VolProxy->ComponentData.GetNumRaysPerProbe();
+        PassParameters->DDGIVolume_probeRayRotationTransform = ProbeRayRotationTransform;
+        PassParameters->DDGIVolume_probeDistanceExponent = VolProxy->ComponentData.ProbeDistanceExponent;
+        PassParameters->DDGIVolume_probeInverseIrradianceEncodingGamma = 1.0f / VolProxy->ComponentData.ProbeIrradianceEncodingGamma;
+        PassParameters->DDGIVolume_probeHysteresis = VolProxy->ComponentData.ProbeHysteresis;
+        PassParameters->DDGIVolume_probeChangeThreshold = VolProxy->ComponentData.ProbeChangeThreshold;
+        PassParameters->DDGIVolume_probeBrightnessThreshold = VolProxy->ComponentData.ProbeBrightnessThreshold;
+        PassParameters->DDGIVolume_probeScrollOffsets = VolProxy->ComponentData.ProbeScrollOffsets;
+        PassParameters->DDGIVolume_ProbeIndexStart = VolProxy->ProbeIndexStart;
+        PassParameters->DDGIVolume_ProbeIndexCount = VolProxy->ProbeIndexCount;
+
+        // calculate grid spacing based on size (scale) and probe count
+        // regarding the *200: the scale is the radius so we need to double it. There is also an implict * 100 of the basic box.
+        FVector volumeSize = VolProxy->ComponentData.Transform.GetScale3D() * 200.0f;
+        FVector probeGridSpacing;
+        probeGridSpacing.X = volumeSize.X / float(VolProxy->ComponentData.ProbeCounts.X);
+        probeGridSpacing.Y = volumeSize.Y / float(VolProxy->ComponentData.ProbeCounts.Y);
+        probeGridSpacing.Z = volumeSize.Z / float(VolProxy->ComponentData.ProbeCounts.Z);
+        PassParameters->DDGIVolume_probeGridSpacing = probeGridSpacing;
+
+        PassParameters->DDGIProbeRTRadianceUAV = ProbesRadianceUAV;
+        PassParameters->DDGIProbeUAV = VolProxy->ProbesDistanceUAV;
+        PassParameters->DDGIProbeStates = VolProxy->ProbesStatesUAV ? VolProxy->ProbesStatesUAV : GBlackTextureWithUAV->UnorderedAccessViewRHI;
+
+        FRDGTextureDesc DDGIDebugOutputDesc = FRDGTextureDesc::Create2D(
+            VolProxy->ProbesDistanceTex->GetSizeXY(),
+            VolProxy->ProbesDistanceTex->GetFormat(),
+            FClearValueBinding::None,
+            TexCreate_ShaderResource | TexCreate_UAV
+        );
+        PassParameters->DebugOutput = GraphBuilder.CreateUAV(GraphBuilder.CreateTexture(DDGIDebugOutputDesc, TEXT("DDGIDistanceBlendDebug")));
+
+        FIntPoint ProbeCount2D = VolProxy->ComponentData.Get2DProbeCount();
+        FComputeShaderUtils::AddPass(
+            GraphBuilder,
+            RDG_EVENT_NAME("DDGI Distance Blend"),
+            ComputeShader,
+            PassParameters,
+            FIntVector(ProbeCount2D.X, ProbeCount2D.Y, 1)
+        );
+
+        // UAV barrier for irradiance and distance uavs so the blends are done before doing border updates
+        FUnorderedAccessViewRHIRef irradianceUAV = VolProxy->ProbesIrradianceUAV;
+        FUnorderedAccessViewRHIRef distanceUAV = VolProxy->ProbesDistanceUAV;
+        GraphBuilder.AddPass(
+            RDG_EVENT_NAME("DDGI Pre Border Update UAV Barrier"),
+            GraphBuilder.AllocParameters<FDummyShaderParameters>(),
+            ERDGPassFlags::Compute | ERDGPassFlags::NeverCull,
+            [irradianceUAV, distanceUAV](FRHICommandList& RHICmdList)
+            {
+                RHICmdList.Transition(FRHITransitionInfo(irradianceUAV, ERHIAccess::ERWBarrier, ERHIAccess::ERWBarrier));
+                RHICmdList.Transition(FRHITransitionInfo(distanceUAV, ERHIAccess::ERWBarrier, ERHIAccess::ERWBarrier));
+            }
+        );
+    }
+
+    void DDGIUpdateVolume_RenderThread_IrradianceBorderUpdate(const FViewInfo& View, FRDGBuilder& GraphBuilder, FDDGIVolumeSceneProxy* VolProxy)
+    {
+        float groupSize = 8.0f;
+        FIntPoint ProbeCount2D = VolProxy->ComponentData.Get2DProbeCount();
+
+        // Row
+        {
+            FGlobalShaderMap* ShaderMap = GetGlobalShaderMap(ERHIFeatureLevel::SM5);
+            TShaderMapRef<FDDGIBorderRowUpdate> ComputeShader(ShaderMap);
+
+            FDDGIBorderRowUpdate::FParameters DefaultPassParameters;
+            FDDGIBorderRowUpdate::FParameters* PassParameters = GraphBuilder.AllocParameters<FDDGIBorderRowUpdate::FParameters>();
+            *PassParameters = DefaultPassParameters;
+
+            PassParameters->ProbeNumIrradianceOrDistanceTexels = FDDGIVolumeSceneProxy::FComponentData::c_NumTexelsIrradiance;
+            PassParameters->DDGIProbeUAV = VolProxy->ProbesIrradianceUAV;
+
+            uint32 numThreadsX = (ProbeCount2D.X * (PassParameters->ProbeNumIrradianceOrDistanceTexels + 2));
+            uint32 numThreadsY = ProbeCount2D.Y;
+            uint32 numGroupsX = (uint32)ceil((float)numThreadsX / groupSize);
+            uint32 numGroupsY = (uint32)ceil((float)numThreadsY / groupSize);
+
+            FComputeShaderUtils::AddPass(
+                GraphBuilder,
+                RDG_EVENT_NAME("DDGI Irradiance Border Update Row"),
+                ComputeShader,
+                PassParameters,
+                FIntVector(numGroupsX, numGroupsY, 1)
+            );
+        }
+
+        // Column
+        {
+            FGlobalShaderMap* ShaderMap = GetGlobalShaderMap(ERHIFeatureLevel::SM5);
+            TShaderMapRef<FDDGIBorderColumnUpdate> ComputeShader(ShaderMap);
+
+            FDDGIBorderColumnUpdate::FParameters DefaultPassParameters;
+            FDDGIBorderColumnUpdate::FParameters* PassParameters = GraphBuilder.AllocParameters<FDDGIBorderColumnUpdate::FParameters>();
+            *PassParameters = DefaultPassParameters;
+
+            PassParameters->ProbeNumIrradianceOrDistanceTexels = FDDGIVolumeSceneProxy::FComponentData::c_NumTexelsIrradiance;
+            PassParameters->DDGIProbeUAV = VolProxy->ProbesIrradianceUAV;
+
+            uint32 numThreadsX = (ProbeCount2D.X * 2);
+            uint32 numThreadsY = (ProbeCount2D.Y * (PassParameters->ProbeNumIrradianceOrDistanceTexels + 2));
+            uint32 numGroupsX = (uint32)ceil((float)numThreadsX / groupSize);
+            uint32 numGroupsY = (uint32)ceil((float)numThreadsY / groupSize);
+
+            FComputeShaderUtils::AddPass(
+                GraphBuilder,
+                RDG_EVENT_NAME("DDGI Irradiance Border Update Column"),
+                ComputeShader,
+                PassParameters,
+                FIntVector(numGroupsX, numGroupsY, 1)
+            );
+        }
+    }
+
+    void DDGIUpdateVolume_RenderThread_DistanceBorderUpdate(const FViewInfo& View, FRDGBuilder& GraphBuilder, FDDGIVolumeSceneProxy* VolProxy)
+    {
+        float groupSize = 8.0f;
+        FIntPoint ProbeCount2D = VolProxy->ComponentData.Get2DProbeCount();
+
+        // Row
+        {
+            FGlobalShaderMap* ShaderMap = GetGlobalShaderMap(ERHIFeatureLevel::SM5);
+            TShaderMapRef<FDDGIBorderRowUpdate> ComputeShader(ShaderMap);
+
+            FDDGIBorderRowUpdate::FParameters DefaultPassParameters;
+            FDDGIBorderRowUpdate::FParameters* PassParameters = GraphBuilder.AllocParameters<FDDGIBorderRowUpdate::FParameters>();
+            *PassParameters = DefaultPassParameters;
+
+            PassParameters->ProbeNumIrradianceOrDistanceTexels = FDDGIVolumeSceneProxy::FComponentData::c_NumTexelsDistance;
+            PassParameters->DDGIProbeUAV = VolProxy->ProbesDistanceUAV;
+
+            uint32 numThreadsX = (ProbeCount2D.X * (PassParameters->ProbeNumIrradianceOrDistanceTexels + 2));
+            uint32 numThreadsY = ProbeCount2D.Y;
+            uint32 numGroupsX = (uint32)ceil((float)numThreadsX / groupSize);
+            uint32 numGroupsY = (uint32)ceil((float)numThreadsY / groupSize);
+
+            FComputeShaderUtils::AddPass(
+                GraphBuilder,
+                RDG_EVENT_NAME("DDGI Distance Border Update Row"),
+                ComputeShader,
+                PassParameters,
+                FIntVector(numGroupsX, numGroupsY, 1)
+            );
+        }
+
+        // Column
+        {
+            FGlobalShaderMap* ShaderMap = GetGlobalShaderMap(ERHIFeatureLevel::SM5);
+            TShaderMapRef<FDDGIBorderColumnUpdate> ComputeShader(ShaderMap);
+
+            FDDGIBorderColumnUpdate::FParameters DefaultPassParameters;
+            FDDGIBorderColumnUpdate::FParameters* PassParameters = GraphBuilder.AllocParameters<FDDGIBorderColumnUpdate::FParameters>();
+            *PassParameters = DefaultPassParameters;
+
+            PassParameters->ProbeNumIrradianceOrDistanceTexels = FDDGIVolumeSceneProxy::FComponentData::c_NumTexelsDistance;
+            PassParameters->DDGIProbeUAV = VolProxy->ProbesDistanceUAV;
+
+            uint32 numThreadsX = (ProbeCount2D.X * 2);
+            uint32 numThreadsY = (ProbeCount2D.Y * (PassParameters->ProbeNumIrradianceOrDistanceTexels + 2));
+            uint32 numGroupsX = (uint32)ceil((float)numThreadsX / groupSize);
+            uint32 numGroupsY = (uint32)ceil((float)numThreadsY / groupSize);
+
+            FComputeShaderUtils::AddPass(
+                GraphBuilder,
+                RDG_EVENT_NAME("DDGI Distance Border Update Column"),
+                ComputeShader,
+                PassParameters,
+                FIntVector(numGroupsX, numGroupsY, 1)
+            );
+        }
+
+        // UAV barrier for irradiance and distance uavs so the border updates are done before they are read by the next processes
+        FUnorderedAccessViewRHIRef irradianceUAV = VolProxy->ProbesIrradianceUAV;
+        FUnorderedAccessViewRHIRef distanceUAV = VolProxy->ProbesDistanceUAV;
+        GraphBuilder.AddPass(
+            RDG_EVENT_NAME("DDGI Post Border Update UAV Barrier"),
+            GraphBuilder.AllocParameters<FDummyShaderParameters>(),
+            ERDGPassFlags::Compute | ERDGPassFlags::NeverCull,
+            [irradianceUAV, distanceUAV](FRHICommandList& RHICmdList)
+            {
+                RHICmdList.Transition(FRHITransitionInfo(irradianceUAV, ERHIAccess::ERWBarrier, ERHIAccess::ERWBarrier));
+                RHICmdList.Transition(FRHITransitionInfo(distanceUAV, ERHIAccess::ERWBarrier, ERHIAccess::ERWBarrier));
+            }
+        );
+    }
+
+    void DDGIUpdateVolume_RenderThread_RelocateProbes(FRDGBuilder& GraphBuilder, FDDGIVolumeSceneProxy* VolProxy, const FMatrix& ProbeRayRotationTransform, FRDGTextureUAVRef ProbesRadianceUAV, bool highBitCount)
+    {
+        FDDGIProbesRelocate::FPermutationDomain PermutationVector;
+        PermutationVector.Set<FDDGIProbesRelocate::FDebugFormatRadiance>(highBitCount);
+        PermutationVector.Set<FDDGIProbesRelocate::FEnableScrolling>(VolProxy->ComponentData.EnableProbeScrolling);
+        FGlobalShaderMap* ShaderMap = GetGlobalShaderMap(ERHIFeatureLevel::SM5);
+        TShaderMapRef<FDDGIProbesRelocate> ComputeShader(ShaderMap, PermutationVector);
+
+        FDDGIProbesRelocate::FParameters DefaultPassParameters;
+        FDDGIProbesRelocate::FParameters* PassParameters = GraphBuilder.AllocParameters<FDDGIProbesRelocate::FParameters>();
+        *PassParameters = DefaultPassParameters;
+
+        // run every frame with full distance scale value for continuous relocation
+        PassParameters->ProbeDistanceScale = 1.0f;
+
+        // calculate grid spacing based on size (scale) and probe count
+        // regarding the *200: the scale is the radius so we need to double it. There is also an implict * 100 of the basic box.
+        FVector volumeSize = VolProxy->ComponentData.Transform.GetScale3D() * 200.0f;
+        FVector probeGridSpacing;
+        probeGridSpacing.X = volumeSize.X / float(VolProxy->ComponentData.ProbeCounts.X);
+        probeGridSpacing.Y = volumeSize.Y / float(VolProxy->ComponentData.ProbeCounts.Y);
+        probeGridSpacing.Z = volumeSize.Z / float(VolProxy->ComponentData.ProbeCounts.Z);
+        PassParameters->DDGIVolume_probeGridSpacing = probeGridSpacing;
+
+        PassParameters->DDGIVolume_probeGridCounts = VolProxy->ComponentData.ProbeCounts;
+        PassParameters->DDGIVolume_numRaysPerProbe = VolProxy->ComponentData.GetNumRaysPerProbe();
+
+        PassParameters->DDGIVolume_ProbeScrollOffsets = VolProxy->ComponentData.ProbeScrollOffsets;
+        PassParameters->DDGIVolume_ProbeIndexStart = VolProxy->ProbeIndexStart;
+        PassParameters->DDGIVolume_ProbeIndexCount = VolProxy->ProbeIndexCount;
+
+        PassParameters->DDGIVolume_probeBackfaceThreshold = VolProxy->ComponentData.ProbeBackfaceThreshold;
+        PassParameters->DDGIVolume_probeRayRotationTransform = ProbeRayRotationTransform;
+        PassParameters->DDGIVolume_probeMinFrontfaceDistance = VolProxy->ComponentData.ProbeMinFrontfaceDistance;
+
+        PassParameters->DDGIProbeRTRadianceUAV = ProbesRadianceUAV;
+        PassParameters->DDGIProbeOffsets = VolProxy->ProbesOffsetsUAV ? VolProxy->ProbesOffsetsUAV : GBlackTextureWithUAV->UnorderedAccessViewRHI;
+
+        float groupSizeX = 8.f;
+        float groupSizeY = 4.f;
+
+        FIntPoint ProbeCount2D = VolProxy->ComponentData.Get2DProbeCount();
+        uint32 numThreadsX = ProbeCount2D.X;
+        uint32 numThreadsY = ProbeCount2D.Y;
+        uint32 numGroupsX = (uint32)ceil((float)numThreadsX / groupSizeX);
+        uint32 numGroupsY = (uint32)ceil((float)numThreadsY / groupSizeY);
+
+        FComputeShaderUtils::AddPass(
+            GraphBuilder,
+            RDG_EVENT_NAME("DDGI Probe Relocation"),
+            ComputeShader,
+            PassParameters,
+            FIntVector(numGroupsX, numGroupsY, 1)
+        );
+
+        // UAV barrier for ProbesOffsets
+        FUnorderedAccessViewRHIRef offsetsUAV = VolProxy->ProbesOffsetsUAV;
+        GraphBuilder.AddPass(
+            RDG_EVENT_NAME("DDGI Probe Relocation UAV Barrier"),
+            GraphBuilder.AllocParameters<FDummyShaderParameters>(),
+            ERDGPassFlags::Compute | ERDGPassFlags::NeverCull,
+            [offsetsUAV](FRHICommandList& RHICmdList)
+            {
+                RHICmdList.Transition(FRHITransitionInfo(offsetsUAV, ERHIAccess::ERWBarrier, ERHIAccess::ERWBarrier));
+            }
+        );
+    }
+
+    void DDGIUpdateVolume_RenderThread_ClassifyProbes(FRDGBuilder& GraphBuilder, FDDGIVolumeSceneProxy* VolProxy, FRDGTextureUAVRef ProbesRadianceUAV, bool highBitCount)
+    {
+        // get the permuted shader
+        FDDGIProbesClassify::FPermutationDomain PermutationVector;
+        PermutationVector.Set<FDDGIProbesClassify::FEnableRelocation>(VolProxy->ComponentData.EnableProbeRelocation);
+        PermutationVector.Set <FDDGIProbesClassify::FDebugFormatRadiance>(highBitCount);
+        PermutationVector.Set <FDDGIProbesClassify::FEnableScrolling>(VolProxy->ComponentData.EnableProbeScrolling);
+        FGlobalShaderMap* ShaderMap = GetGlobalShaderMap(ERHIFeatureLevel::SM5);
+        TShaderMapRef<FDDGIProbesClassify> ComputeShader(ShaderMap, PermutationVector);
+
+        // set up the shader parameters
+        FDDGIProbesClassify::FParameters DefaultPassParameters;
+        FDDGIProbesClassify::FParameters* PassParameters = GraphBuilder.AllocParameters<FDDGIProbesClassify::FParameters>();
+        *PassParameters = DefaultPassParameters;
+
+        // calculate grid spacing based on size (scale) and probe count
+        // regarding the *200: the scale is the radius so we need to double it. There is also an implict * 100 of the basic box.
+        FVector volumeSize = VolProxy->ComponentData.Transform.GetScale3D() * 200.0f;
+        FVector probeGridSpacing;
+        probeGridSpacing.X = volumeSize.X / float(VolProxy->ComponentData.ProbeCounts.X);
+        probeGridSpacing.Y = volumeSize.Y / float(VolProxy->ComponentData.ProbeCounts.Y);
+        probeGridSpacing.Z = volumeSize.Z / float(VolProxy->ComponentData.ProbeCounts.Z);
+        PassParameters->DDGIVolume_probeGridSpacing = probeGridSpacing;
+
+        PassParameters->DDGIVolume_probeGridCounts = VolProxy->ComponentData.ProbeCounts;
+        PassParameters->DDGIVolume_numRaysPerProbe = VolProxy->ComponentData.GetNumRaysPerProbe();
+        PassParameters->DDGIVolume_probeBackfaceThreshold = VolProxy->ComponentData.ProbeBackfaceThreshold;
+        PassParameters->DDGIVolume_probeScrollOffsets = VolProxy->ComponentData.ProbeScrollOffsets;
+        PassParameters->DDGIVolume_ProbeIndexStart = VolProxy->ProbeIndexStart;
+        PassParameters->DDGIVolume_ProbeIndexCount = VolProxy->ProbeIndexCount;
+
+        PassParameters->DDGIProbeRTRadianceUAV = ProbesRadianceUAV;
+        PassParameters->DDGIProbeStates = VolProxy->ProbesStatesUAV;
+
+        // Dispatch the compute shader
+        float groupSizeX = 8.f;
+        float groupSizeY = 4.f;
+
+        FIntPoint ProbeCount2D = VolProxy->ComponentData.Get2DProbeCount();
+        uint32 numThreadsX = ProbeCount2D.X;
+        uint32 numThreadsY = ProbeCount2D.Y;
+        uint32 numGroupsX = (uint32)ceil((float)numThreadsX / groupSizeX);
+        uint32 numGroupsY = (uint32)ceil((float)numThreadsY / groupSizeY);
+
+        FComputeShaderUtils::AddPass(
+            GraphBuilder,
+            RDG_EVENT_NAME("DDGI Probe Classification"),
+            ComputeShader,
+            PassParameters,
+            FIntVector(numGroupsX, numGroupsY, 1)
+        );
+
+        // UAV barrier for ProbesStates
+        FUnorderedAccessViewRHIRef statesUAV = VolProxy->ProbesStatesUAV;
+        GraphBuilder.AddPass(
+            RDG_EVENT_NAME("DDGI Probe Classification UAV Barrier"),
+            GraphBuilder.AllocParameters<FDummyShaderParameters>(),
+            ERDGPassFlags::Compute|ERDGPassFlags::NeverCull,
+            [statesUAV](FRHICommandList& RHICmdList)
+            {
+                RHICmdList.Transition(FRHITransitionInfo(statesUAV, ERHIAccess::ERWBarrier, ERHIAccess::ERWBarrier));
+            }
+        );
+    }
+
+} // namespace DDGIVolumeUpdate
+
+#undef LOCTEXT_NAMESPACE
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Private/DDGIVolumeUpdate.h b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Private/DDGIVolumeUpdate.h
new file mode 100644
index 00000000000..c619be80c52
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Private/DDGIVolumeUpdate.h
@@ -0,0 +1,26 @@
+/*
+* Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#pragma once
+
+#include "CoreMinimal.h"
+
+class FViewInfo;
+class FRDGBuilder;
+class UDDGIVolumeComponent;
+class FScene;
+
+namespace DDGIVolumeUpdate
+{
+    void Startup();
+    void Shutdown();
+
+    void DDGIUpdatePerFrame_RenderThread(const FScene& Scene, const FViewInfo& View, FRDGBuilder& GraphBuilder);
+}
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Private/DDGIVolumeVisualize.cpp b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Private/DDGIVolumeVisualize.cpp
new file mode 100644
index 00000000000..472c8a058d6
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Private/DDGIVolumeVisualize.cpp
@@ -0,0 +1,538 @@
+/*
+* Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#include "DDGIVolumeComponent.h"
+#include "DDGIVolume.h"
+#include "DDGIVolumeUpdate.h"
+#include "RTXGIPluginSettings.h"
+#include "RenderGraphBuilder.h"
+#include "ShaderParameterStruct.h"
+#include "ShaderParameterUtils.h"
+#include "SystemTextures.h"
+
+// UE4 private interfaces
+#include "PostProcess/SceneRenderTargets.h"
+#include "SceneRendering.h"
+#include "DeferredShadingRenderer.h"
+#include "ScenePrivate.h"
+
+#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+
+DECLARE_GPU_STAT_NAMED(RTXGI_Visualizations, TEXT("RTXGI Visualizations"));
+
+static TAutoConsoleVariable<int> CVarShowProbes(
+    TEXT("r.RTXGI.DDGIShowProbes"),
+    0,
+    TEXT("Show the probes within DDGI volumes.\n"),
+    ECVF_RenderThreadSafe);
+
+static TAutoConsoleVariable<float> CVarShowProbeDepthScale(
+    TEXT("r.RTXGI.DDGIShowProbeDepthScale"),
+    500.0f,
+    TEXT("The depth value is divided by this before being shown on the sphere.\n"),
+    ECVF_RenderThreadSafe);
+
+BEGIN_SHADER_PARAMETER_STRUCT(FVolumeVisualizeShaderParameters, )
+    SHADER_PARAMETER_TEXTURE(Texture2D, ProbeIrradianceTexture)
+    SHADER_PARAMETER_TEXTURE(Texture2D, ProbeDistanceTexture)
+    SHADER_PARAMETER_TEXTURE(Texture2D, ProbeOffsets)
+    SHADER_PARAMETER_UAV(RWTexture2D<uint>, ProbeStates)
+    SHADER_PARAMETER_SAMPLER(SamplerState, ProbeSampler)
+    SHADER_PARAMETER(int, Mode)
+    SHADER_PARAMETER(float, ProbeRadius)
+    SHADER_PARAMETER(float, DepthScale)
+    SHADER_PARAMETER(int, VolumeProbeNumIrradianceTexels)
+    SHADER_PARAMETER(int, VolumeProbeNumDistanceTexels)
+    SHADER_PARAMETER(float, VolumeProbeIrradianceEncodingGamma)
+    SHADER_PARAMETER(FVector, VolumePosition)
+    SHADER_PARAMETER(FVector4, VolumeRotation)
+    SHADER_PARAMETER(FVector, VolumeProbeGridSpacing)
+    SHADER_PARAMETER(FIntVector, VolumeProbeGridCounts)
+    SHADER_PARAMETER(FMatrix, WorldToClip)
+    SHADER_PARAMETER(FVector, CameraPosition)
+    SHADER_PARAMETER(float, PreExposure)
+    SHADER_PARAMETER(int32, ShouldUsePreExposure)
+    SHADER_PARAMETER(FIntVector, VolumeProbeScrollOffsets)
+    SHADER_PARAMETER(float, IrradianceScalar)
+    RENDER_TARGET_BINDING_SLOTS()
+END_SHADER_PARAMETER_STRUCT()
+
+class FVolumeVisualizeShaderVS : public FGlobalShader
+{
+public:
+    DECLARE_GLOBAL_SHADER(FVolumeVisualizeShaderVS);
+    SHADER_USE_PARAMETER_STRUCT(FVolumeVisualizeShaderVS, FGlobalShader);
+
+    using FParameters = FVolumeVisualizeShaderParameters;
+
+    class FEnableRelocation : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_RELOCATION");
+    class FEnableScrolling : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_SCROLL");
+
+    using FPermutationDomain = TShaderPermutationDomain<FEnableRelocation, FEnableScrolling>;
+
+    static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)
+    {
+        FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);
+        OutEnvironment.SetDefine(TEXT("RTXGI_DDGI_PROBE_STATE_CLASSIFIER"), FDDGIVolumeSceneProxy::FComponentData::c_RTXGI_DDGI_PROBE_STATE_CLASSIFIER ? 1 : 0);
+
+        // needed for a typed UAV load. This already assumes we are raytracing, so should be fine.
+        OutEnvironment.CompilerFlags.Add(CFLAG_AllowTypedUAVLoads);
+    }
+
+    static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters& Parameters)
+    {
+        return IsFeatureLevelSupported(Parameters.Platform, ERHIFeatureLevel::SM5);
+    }
+};
+
+class FVolumeVisualizeShaderPS : public FGlobalShader
+{
+public:
+    DECLARE_GLOBAL_SHADER(FVolumeVisualizeShaderPS);
+    SHADER_USE_PARAMETER_STRUCT(FVolumeVisualizeShaderPS, FGlobalShader);
+
+    using FParameters = FVolumeVisualizeShaderParameters;
+
+    class FEnableRelocation : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_RELOCATION");
+    class FEnableScrolling : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_PROBE_SCROLL");
+    class FDebugFormatRadiance : SHADER_PERMUTATION_BOOL("RTXGI_DDGI_DEBUG_FORMAT_RADIANCE");
+
+    using FPermutationDomain = TShaderPermutationDomain<FEnableRelocation, FEnableScrolling, FDebugFormatRadiance>;
+
+    static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)
+    {
+        FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);
+        OutEnvironment.SetDefine(TEXT("RTXGI_DDGI_PROBE_STATE_CLASSIFIER"), FDDGIVolumeSceneProxy::FComponentData::c_RTXGI_DDGI_PROBE_STATE_CLASSIFIER ? 1 : 0);
+
+        // needed for a typed UAV load. This already assumes we are raytracing, so should be fine.
+        OutEnvironment.CompilerFlags.Add(CFLAG_AllowTypedUAVLoads);
+    }
+
+    static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters& Parameters)
+    {
+        return IsFeatureLevelSupported(Parameters.Platform, ERHIFeatureLevel::SM5);
+    }
+};
+
+IMPLEMENT_GLOBAL_SHADER(FVolumeVisualizeShaderVS, "/Plugin/RTXGI/Private/VisualizeDDGIProbes.usf", "VisualizeDDGIProbesVS", SF_Vertex);
+IMPLEMENT_GLOBAL_SHADER(FVolumeVisualizeShaderPS, "/Plugin/RTXGI/Private/VisualizeDDGIProbes.usf", "VisualizeDDGIProbesPS", SF_Pixel);
+
+/**
+* Probe sphere vertex buffer. Defines a sphere of unit size.
+*/
+template<int32 NumSphereSides, int32 NumSphereRings, typename VectorType>
+class TDDGIProbeSphereVertexBuffer : public FVertexBuffer
+{
+public:
+
+    int32 GetNumRings() const
+    {
+        return NumSphereRings;
+    }
+
+    /**
+    * Initialize the RHI for this rendering resource
+    */
+    void InitRHI() override
+    {
+        const int32 NumSides = NumSphereSides;
+        const int32 NumRings = NumSphereRings;
+        const int32 NumVerts = (NumSides + 1) * (NumRings + 1);
+
+        const float RadiansPerRingSegment = PI / (float)NumRings;
+        float Radius = 1;
+
+        TArray<VectorType, TInlineAllocator<NumRings + 1> > ArcVerts;
+        ArcVerts.Empty(NumRings + 1);
+        // Calculate verts for one arc
+        for (int32 i = 0; i < NumRings + 1; i++)
+        {
+            const float Angle = i * RadiansPerRingSegment;
+            ArcVerts.Add(FVector(0.0f, FMath::Sin(Angle), FMath::Cos(Angle)));
+        }
+
+        TResourceArray<VectorType, VERTEXBUFFER_ALIGNMENT> Verts;
+        Verts.Empty(NumVerts);
+        // Then rotate this arc NumSides + 1 times.
+        const FVector Center = FVector(0, 0, 0);
+        for (int32 s = 0; s < NumSides + 1; s++)
+        {
+            FRotator ArcRotator(0, 360.f * ((float)s / NumSides), 0);
+            FRotationMatrix ArcRot(ArcRotator);
+
+            for (int32 v = 0; v < NumRings + 1; v++)
+            {
+                const int32 VIx = (NumRings + 1) * s + v;
+                Verts.Add(Center + Radius * ArcRot.TransformPosition(ArcVerts[v]));
+            }
+        }
+
+        NumSphereVerts = Verts.Num();
+        uint32 Size = Verts.GetResourceDataSize();
+
+        // Create vertex buffer. Fill buffer with initial data upon creation
+        FRHIResourceCreateInfo CreateInfo(&Verts);
+        VertexBufferRHI = RHICreateVertexBuffer(Size, BUF_Static, CreateInfo);
+    }
+
+    int32 GetVertexCount() const { return NumSphereVerts; }
+
+    /**
+    * Calculates the world transform for a sphere.
+    * @param OutTransform - The output world transform.
+    * @param Sphere - The sphere to generate the transform for.
+    * @param PreViewTranslation - The pre-view translation to apply to the transform.
+    * @param bConservativelyBoundSphere - when true, the sphere that is drawn will contain all positions in the analytical sphere,
+    *		 Otherwise the sphere vertices will lie on the analytical sphere and the positions on the faces will lie inside the sphere.
+    */
+    void CalcTransform(FVector4& OutPosAndScale, const FSphere& Sphere, const FVector& PreViewTranslation, bool bConservativelyBoundSphere = true)
+    {
+        float Radius = Sphere.W;
+        if (bConservativelyBoundSphere)
+        {
+            const int32 NumRings = NumSphereRings;
+            const float RadiansPerRingSegment = PI / (float)NumRings;
+
+            // Boost the effective radius so that the edges of the sphere approximation lie on the sphere, instead of the vertices
+            Radius /= FMath::Cos(RadiansPerRingSegment);
+        }
+
+        const FVector Translate(Sphere.Center + PreViewTranslation);
+        OutPosAndScale = FVector4(Translate, Radius);
+    }
+
+private:
+    int32 NumSphereVerts;
+};
+
+/**
+* Probe sphere index buffer.
+*/
+template<int32 NumSphereSides, int32 NumSphereRings>
+class TDDGIProbeSphereIndexBuffer : public FIndexBuffer
+{
+public:
+    /**
+    * Initialize the RHI for this rendering resource
+    */
+    void InitRHI() override
+    {
+        const int32 NumSides = NumSphereSides;
+        const int32 NumRings = NumSphereRings;
+        TResourceArray<uint16, INDEXBUFFER_ALIGNMENT> Indices;
+
+        // Add triangles for all the vertices generated
+        for (int32 s = 0; s < NumSides; s++)
+        {
+            const int32 a0start = (s + 0) * (NumRings + 1);
+            const int32 a1start = (s + 1) * (NumRings + 1);
+
+            for (int32 r = 0; r < NumRings; r++)
+            {
+                Indices.Add(a0start + r + 0);
+                Indices.Add(a1start + r + 0);
+                Indices.Add(a0start + r + 1);
+                Indices.Add(a1start + r + 0);
+                Indices.Add(a1start + r + 1);
+                Indices.Add(a0start + r + 1);
+            }
+        }
+
+        NumIndices = Indices.Num();
+        const uint32 Size = Indices.GetResourceDataSize();
+        const uint32 Stride = sizeof(uint16);
+
+        // Create index buffer. Fill buffer with initial data upon creation
+        FRHIResourceCreateInfo CreateInfo(&Indices);
+        IndexBufferRHI = RHICreateIndexBuffer(Stride, Size, BUF_Static, CreateInfo);
+    }
+
+    int32 GetIndexCount() const { return NumIndices; };
+
+private:
+    int32 NumIndices;
+};
+
+struct FVisualDDGIProbesVertex
+{
+    FVector4 Position;
+    FVisualDDGIProbesVertex() {}
+    FVisualDDGIProbesVertex(const FVector4& InPosition) : Position(InPosition) {}
+};
+
+class FVisualizeDDGIProbesVertexDeclaration : public FRenderResource
+{
+public:
+
+    FVertexDeclarationRHIRef VertexDeclarationRHI;
+
+    virtual ~FVisualizeDDGIProbesVertexDeclaration() {}
+
+    virtual void InitRHI() override
+    {
+        FVertexDeclarationElementList Elements;
+        uint16 Stride = sizeof(FVisualDDGIProbesVertex);
+        Elements.Add(FVertexElement(0, STRUCT_OFFSET(FVisualDDGIProbesVertex, Position), VET_Float4, 0, Stride));
+        VertexDeclarationRHI = PipelineStateCache::GetOrCreateVertexDeclaration(Elements);
+    }
+
+    virtual void ReleaseRHI() override
+    {
+        VertexDeclarationRHI.SafeRelease();
+    }
+};
+
+TGlobalResource<FVisualizeDDGIProbesVertexDeclaration> GVisualizeDDGIProbesVertexDeclaration;
+TGlobalResource<TDDGIProbeSphereVertexBuffer<36, 24, FVector4>> GDDGIProbeSphereVertexBuffer;
+TGlobalResource<TDDGIProbeSphereIndexBuffer<36, 24>> GDDGIProbeSphereIndexBuffer;
+
+void FDDGIVolumeSceneProxy::RenderDiffuseIndirectVisualizations_RenderThread(
+    const FScene& Scene,
+    const FViewInfo& View,
+    FRDGBuilder& GraphBuilder,
+    FGlobalIlluminationExperimentalPluginResources& Resources)
+{
+    check(IsInRenderingThread() || IsInParallelRenderingThread());
+
+    int mode = CVarShowProbes.GetValueOnRenderThread();
+    if (mode < 1 || mode > 3) return;
+
+    RDG_GPU_STAT_SCOPE(GraphBuilder, RTXGI_Visualizations);
+    RDG_EVENT_SCOPE(GraphBuilder, "RTXGI Visualizations");
+
+    float probeRadius = GetDefault<URTXGIPluginSettings>()->DebugProbeRadius;
+    float depthScale = CVarShowProbeDepthScale.GetValueOnRenderThread();
+
+    // Get other things we'll need for all proxies
+    FIntRect ViewRect = View.ViewRect;
+    FRDGTextureRef SceneColorTexture = GraphBuilder.RegisterExternalTexture(Resources.SceneColor);
+    FRDGTextureRef SceneDepthTexture = GraphBuilder.RegisterExternalTexture(Resources.SceneDepthZ);
+
+    for (FDDGIVolumeSceneProxy* proxy : FDDGIVolumeSceneProxy::AllProxiesReadyForRender_RenderThread)
+    {
+        // Skip this volume if it isn't part of the current scene
+        if (proxy->OwningScene != &Scene) continue;
+
+        // Skip this volume if it is not enabled
+        //if (!proxy->ComponentData.EnableVolume) continue;
+
+        // Skip this volume if it doesn't intersect the view frustum
+        if (!proxy->IntersectsViewFrustum(View)) continue;
+
+        // Get the shader permutation
+        FVolumeVisualizeShaderVS::FPermutationDomain PermutationVectorVS;
+        PermutationVectorVS.Set<FVolumeVisualizeShaderVS::FEnableRelocation>(proxy->ComponentData.EnableProbeRelocation);
+        PermutationVectorVS.Set<FVolumeVisualizeShaderVS::FEnableScrolling>(proxy->ComponentData.EnableProbeScrolling);
+
+        FVolumeVisualizeShaderPS::FPermutationDomain PermutationVectorPS;
+        PermutationVectorPS.Set<FVolumeVisualizeShaderPS::FEnableRelocation>(proxy->ComponentData.EnableProbeRelocation);
+        PermutationVectorPS.Set<FVolumeVisualizeShaderPS::FEnableScrolling>(proxy->ComponentData.EnableProbeScrolling);
+        bool highBitCount = (GetDefault<URTXGIPluginSettings>()->IrradianceBits == EDDGIIrradianceBits::n32);
+        PermutationVectorPS.Set<FVolumeVisualizeShaderPS::FDebugFormatRadiance>(highBitCount);
+
+        FGlobalShaderMap* GlobalShaderMap = GetGlobalShaderMap(ERHIFeatureLevel::SM5);
+        TShaderMapRef<FVolumeVisualizeShaderVS> VertexShader(GlobalShaderMap, PermutationVectorVS);
+        TShaderMapRef<FVolumeVisualizeShaderPS> PixelShader(GlobalShaderMap, PermutationVectorPS);
+
+        // Set shader pass parameters
+        FVolumeVisualizeShaderParameters DefaultPassParameters;
+        FVolumeVisualizeShaderParameters* PassParameters = GraphBuilder.AllocParameters<FVolumeVisualizeShaderParameters>();
+        *PassParameters = DefaultPassParameters;
+
+        PassParameters->ProbeIrradianceTexture = proxy->ProbesIrradianceTex;
+        PassParameters->ProbeDistanceTexture = proxy->ProbesDistanceTex;
+        PassParameters->ProbeOffsets = proxy->ProbesOffsetsTex;
+        PassParameters->ProbeStates = proxy->ProbesStatesUAV ? proxy->ProbesStatesUAV: GBlackTextureWithUAV->UnorderedAccessViewRHI;
+        PassParameters->ProbeRadius = probeRadius;
+        PassParameters->DepthScale = depthScale;
+        PassParameters->WorldToClip = View.ViewMatrices.GetViewProjectionMatrix();
+        PassParameters->CameraPosition = View.ViewLocation;
+
+        PassParameters->ShouldUsePreExposure = View.Family->EngineShowFlags.Tonemapper;
+        PassParameters->PreExposure = View.PreExposure;
+        PassParameters->IrradianceScalar = proxy->ComponentData.IrradianceScalar;
+
+        PassParameters->VolumeProbeScrollOffsets = proxy->ComponentData.ProbeScrollOffsets;
+
+        PassParameters->ProbeSampler = TStaticSamplerState<SF_Bilinear, AM_Clamp, AM_Clamp, AM_Clamp>::GetRHI();
+        PassParameters->Mode = mode;
+        PassParameters->VolumeProbeIrradianceEncodingGamma = proxy->ComponentData.ProbeIrradianceEncodingGamma;
+
+        PassParameters->VolumePosition = proxy->ComponentData.Origin;
+        FQuat rotation = proxy->ComponentData.Transform.GetRotation();
+        PassParameters->VolumeRotation = FVector4{ rotation.X, rotation.Y, rotation.Z, rotation.W };
+
+        FVector volumeSize = proxy->ComponentData.Transform.GetScale3D() * 200.0f;
+        FVector probeGridSpacing;
+        probeGridSpacing.X = volumeSize.X / float(proxy->ComponentData.ProbeCounts.X);
+        probeGridSpacing.Y = volumeSize.Y / float(proxy->ComponentData.ProbeCounts.Y);
+        probeGridSpacing.Z = volumeSize.Z / float(proxy->ComponentData.ProbeCounts.Z);
+        PassParameters->VolumeProbeGridSpacing = probeGridSpacing;
+
+        PassParameters->VolumeProbeGridCounts = proxy->ComponentData.ProbeCounts;
+
+        PassParameters->VolumeProbeNumIrradianceTexels = FDDGIVolumeSceneProxy::FComponentData::c_NumTexelsIrradiance;
+        PassParameters->VolumeProbeNumDistanceTexels = FDDGIVolumeSceneProxy::FComponentData::c_NumTexelsDistance;
+
+        PassParameters->RenderTargets[0] = FRenderTargetBinding(SceneColorTexture, ERenderTargetLoadAction::ELoad);
+        PassParameters->RenderTargets.DepthStencil = FDepthStencilBinding(SceneDepthTexture, ERenderTargetLoadAction::ELoad, ERenderTargetLoadAction::ENoAction, FExclusiveDepthStencil::DepthWrite_StencilNop);
+
+        uint32 NumInstances = uint32(proxy->ComponentData.ProbeCounts.X * proxy->ComponentData.ProbeCounts.Y * proxy->ComponentData.ProbeCounts.Z);
+
+        GraphBuilder.AddPass(
+            Forward<FRDGEventName>(RDG_EVENT_NAME("DDGI Visualize Probes")),
+            PassParameters,
+            ERDGPassFlags::Raster,
+            [PassParameters, GlobalShaderMap, VertexShader, PixelShader, ViewRect, NumInstances](FRHICommandList& RHICmdList)
+            {
+                RHICmdList.SetViewport(ViewRect.Min.X, ViewRect.Min.Y, 0.0f, ViewRect.Max.X, ViewRect.Max.Y, 1.0f);
+
+                FGraphicsPipelineStateInitializer GraphicsPSOInit;
+                RHICmdList.ApplyCachedRenderTargets(GraphicsPSOInit);
+
+                GraphicsPSOInit.RasterizerState = TStaticRasterizerState<FM_Solid, CM_CW>::GetRHI();
+                GraphicsPSOInit.DepthStencilState = TStaticDepthStencilState<true, CF_DepthNearOrEqual>::GetRHI();
+                GraphicsPSOInit.BlendState = TStaticBlendStateWriteMask<CW_RGB, CW_RGBA>::GetRHI();
+
+                GraphicsPSOInit.BoundShaderState.VertexDeclarationRHI = GVisualizeDDGIProbesVertexDeclaration.VertexDeclarationRHI;
+                GraphicsPSOInit.BoundShaderState.VertexShaderRHI = VertexShader.GetVertexShader();
+                GraphicsPSOInit.BoundShaderState.PixelShaderRHI = PixelShader.GetPixelShader();
+                GraphicsPSOInit.PrimitiveType = PT_TriangleList;
+                SetGraphicsPipelineState(RHICmdList, GraphicsPSOInit);
+
+                SetShaderParameters(RHICmdList, VertexShader, VertexShader.GetVertexShader(), *PassParameters);
+                SetShaderParameters(RHICmdList, PixelShader, PixelShader.GetPixelShader(), *PassParameters);
+
+                RHICmdList.SetStreamSource(0, GDDGIProbeSphereVertexBuffer.VertexBufferRHI, 0);
+                RHICmdList.DrawIndexedPrimitive(GDDGIProbeSphereIndexBuffer.IndexBufferRHI, 0, 0, GDDGIProbeSphereVertexBuffer.GetVertexCount(), 0, GDDGIProbeSphereIndexBuffer.GetIndexCount() / 3, NumInstances);
+            }
+        );
+    }
+}
+#else
+void FDDGIVolumeSceneProxy::RenderDiffuseIndirectVisualizations_RenderThread(
+    const FScene& Scene,
+    const FViewInfo& View,
+    FRDGBuilder& GraphBuilder,
+	FGlobalIlluminationExperimentalPluginResources& Resources){}
+#endif //!(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+
+#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+
+static bool MemoryUseExec(UWorld* InWorld, const TCHAR* Cmd, FOutputDevice& Ar)
+{
+    if (!FParse::Command(&Cmd, TEXT("r.RTXGI.MemoryUsed")))
+        return false;
+
+    struct VolumeMemoryInfo
+    {
+        const FDDGIVolumeSceneProxy* proxy = nullptr;
+        const AActor* actor = nullptr;
+        int irradianceBytes = 0;
+        int distanceBytes = 0;
+        int offsetsBytes = 0;
+        int statesBytes = 0;
+    };
+
+    TArray<VolumeMemoryInfo> memoryInfo;
+
+    ENQUEUE_RENDER_COMMAND(MemoryUsage)(
+        [&memoryInfo](FRHICommandListImmediate& RHICmdList)
+        {
+            for (FDDGIVolumeSceneProxy* proxy : FDDGIVolumeSceneProxy::AllProxiesReadyForRender_RenderThread)
+            {
+                VolumeMemoryInfo info;
+                info.proxy = proxy;
+
+                if (proxy->ProbesIrradianceTex)
+                {
+                    FRHITexture2D* texture = proxy->ProbesIrradianceTex->GetTexture2D();
+                    if (texture)
+                        info.irradianceBytes = texture->GetSizeX()* texture->GetSizeY()* GPixelFormats[texture->GetFormat()].BlockBytes;
+                }
+
+                if (proxy->ProbesDistanceTex)
+                {
+                    FRHITexture2D* texture = proxy->ProbesDistanceTex->GetTexture2D();
+                    if (texture)
+                        info.distanceBytes = texture->GetSizeX() * texture->GetSizeY() * GPixelFormats[texture->GetFormat()].BlockBytes;
+                }
+
+                if (proxy->ProbesOffsetsTex)
+                {
+                    FRHITexture2D* texture = proxy->ProbesOffsetsTex->GetTexture2D();
+                    if (texture)
+                        info.offsetsBytes = texture->GetSizeX() * texture->GetSizeY() * GPixelFormats[texture->GetFormat()].BlockBytes;
+                }
+
+                if (proxy->ProbesStatesTex)
+                {
+                    FRHITexture2D* texture = proxy->ProbesStatesTex->GetTexture2D();
+                    if (texture)
+                        info.statesBytes = texture->GetSizeX() * texture->GetSizeY() * GPixelFormats[texture->GetFormat()].BlockBytes;
+                }
+
+                memoryInfo.Push(info);
+            }
+        }
+    );
+    FlushRenderingCommands();
+
+    ULevel* level = InWorld->GetCurrentLevel();
+
+    for (AActor* actor : level->Actors)
+    {
+        if (!actor)
+            continue;
+
+        UDDGIVolumeComponent* volume = Cast<UDDGIVolumeComponent>(actor->GetComponentByClass(UDDGIVolumeComponent::StaticClass()));
+        if (!volume)
+            continue;
+
+        for (VolumeMemoryInfo& info : memoryInfo)
+        {
+            if (info.proxy == volume->SceneProxy)
+            {
+                info.actor = actor;
+                break;
+            }
+        }
+    }
+
+    UE_LOG(LogConsoleResponse, Log, TEXT("RTXGI Texture Memory Usage (NOTE: Does not include alignment padding, so actual memory usage could be higher):"));
+
+    int totalBytes = 0;
+    static const float c_oneMegabyte = 1024.0f * 1024.0f;
+
+    for (VolumeMemoryInfo& info : memoryInfo)
+    {
+        int bytes = 0;
+        bytes += info.irradianceBytes;
+        bytes += info.distanceBytes;
+        bytes += info.offsetsBytes;
+        bytes += info.statesBytes;
+        totalBytes += bytes;
+
+        UE_LOG(LogConsoleResponse, Log, TEXT("  %s: %0.2f MB (%d B)"), (info.actor ? *info.actor->GetFullName() : *FString("<Unknown>")), float(bytes) / c_oneMegabyte, bytes);
+
+        UE_LOG(LogConsoleResponse, Log, TEXT("    Irradiance: %0.2f MB (%d B)"), float(info.irradianceBytes) / c_oneMegabyte, info.irradianceBytes);
+        UE_LOG(LogConsoleResponse, Log, TEXT("    Distance: %0.2f MB (%d B)"), float(info.distanceBytes) / c_oneMegabyte, info.distanceBytes);
+        UE_LOG(LogConsoleResponse, Log, TEXT("    Offsets: %0.2f MB (%d B)"), float(info.offsetsBytes) / c_oneMegabyte, info.offsetsBytes);
+        UE_LOG(LogConsoleResponse, Log, TEXT("    States: %0.2f MB (%d B)"), float(info.statesBytes) / c_oneMegabyte, info.statesBytes);
+    }
+
+    UE_LOG(LogConsoleResponse, Log, TEXT("Total: %0.2f MB (%d B)"), float(totalBytes) / c_oneMegabyte, totalBytes);
+
+    return true;
+}
+
+static FStaticSelfRegisteringExec RendererExecRegistration(MemoryUseExec);
+
+#endif  // !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Private/RTXGIPlugin.cpp b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Private/RTXGIPlugin.cpp
new file mode 100644
index 00000000000..ff327822fd3
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Private/RTXGIPlugin.cpp
@@ -0,0 +1,59 @@
+/*
+* Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#include "RTXGIPlugin.h"
+
+#include "Modules/ModuleManager.h"
+#include "Interfaces/IPluginManager.h"
+#include "Tickable.h"
+
+#include "DDGIVolumeUpdate.h"
+#include "DDGIVolumeComponent.h"
+#include "Misc/Paths.h"
+#include "ShaderCore.h"
+
+#define LOCTEXT_NAMESPACE "FRTXGIPlugin"
+
+void FRTXGIPlugin::StartupDDGI()
+{
+    DDGIVolumeUpdate::Startup();
+    UDDGIVolumeComponent::Startup();
+}
+
+void FRTXGIPlugin::ShutdownDDGI()
+{
+    DDGIVolumeUpdate::Shutdown();
+    UDDGIVolumeComponent::Shutdown();
+}
+
+void FRTXGIPlugin::StartupModule()
+{
+    // Get the base directory of this plugin
+    FString BaseDir = IPluginManager::Get().FindPlugin(GetModularFeatureName())->GetBaseDir();
+
+    // Register the shader directory
+    FString PluginShaderDir = FPaths::Combine(BaseDir, TEXT("Shaders"));
+    FString PluginMapping = TEXT("/Plugin/") + GetModularFeatureName();
+    AddShaderSourceDirectoryMapping(PluginMapping, PluginShaderDir);
+
+    StartupDDGI();
+}
+
+void FRTXGIPlugin::ShutdownModule()
+{
+    // This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,
+    // we call this function before unloading the module.
+
+    ShutdownDDGI();
+}
+
+#undef LOCTEXT_NAMESPACE
+
+IMPLEMENT_MODULE(FRTXGIPlugin, RTXGI)
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Private/RTXGIPluginSettings.cpp b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Private/RTXGIPluginSettings.cpp
new file mode 100644
index 00000000000..f230cee9d41
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Private/RTXGIPluginSettings.cpp
@@ -0,0 +1,47 @@
+/*
+* Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#include "RTXGIPluginSettings.h"
+#include "RTXGIPlugin.h"
+#include "DDGIVolumeComponent.h"
+
+#define LOCTEXT_NAMESPACE "RTXGIPlugin"
+
+#if WITH_EDITOR
+
+void URTXGIPluginSettings::PostEditChangeProperty(struct FPropertyChangedEvent& PropertyChangedEvent)
+{
+    Super::PostEditChangeProperty(PropertyChangedEvent);
+
+    // tell the scene proxies about the bit depth change
+    if (PropertyChangedEvent.MemberProperty)
+    {
+        if (PropertyChangedEvent.MemberProperty->GetFName() == GET_MEMBER_NAME_CHECKED(URTXGIPluginSettings, IrradianceBits) ||
+            PropertyChangedEvent.MemberProperty->GetFName() == GET_MEMBER_NAME_CHECKED(URTXGIPluginSettings, DistanceBits))
+        {
+            FDDGIVolumeSceneProxy::OnIrradianceOrDistanceBitsChange();
+        }
+    }
+}
+
+FText URTXGIPluginSettings::GetSectionText() const
+{
+    return LOCTEXT("SettingsDisplayName", "RTXGI");
+}
+
+#endif	// WITH_EDITOR
+
+URTXGIPluginSettings::URTXGIPluginSettings()
+{
+    CategoryName = TEXT("Plugins");
+    SectionName  = TEXT("RTXGI");
+}
+
+#undef LOCTEXT_NAMESPACE
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Private/RTXGIPluginSettings.h b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Private/RTXGIPluginSettings.h
new file mode 100644
index 00000000000..c4405e68d4f
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Private/RTXGIPluginSettings.h
@@ -0,0 +1,76 @@
+/*
+* Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "Engine/EngineTypes.h"
+#include "Engine/DeveloperSettings.h"
+#include "RTXGIPluginSettings.generated.h"
+
+UENUM()
+enum class EDDGIIrradianceBits : uint8
+{
+    n10 UMETA(DisplayName = "10 bit"),
+    n32 UMETA(DisplayName = "32 bit (for bright lighting and extended luminance range rendering)")
+};
+
+UENUM()
+enum class EDDGIDistanceBits : uint8
+{
+    n16 UMETA(DisplayName = "16 bit"),
+    n32 UMETA(DisplayName = "32 bit (for larger distances)")
+};
+
+/**
+ * Configure the RTXGI plug-in.
+ */
+UCLASS(config=Engine, defaultconfig)
+class URTXGIPluginSettings : public UDeveloperSettings
+{
+    GENERATED_BODY()
+
+public:
+    URTXGIPluginSettings();
+
+#if WITH_EDITOR
+    //~ UObject interface
+    virtual void PostEditChangeProperty(struct FPropertyChangedEvent& PropertyChangedEvent) override;
+
+    //~ UDeveloperSettings interface
+    virtual FText GetSectionText() const override;
+#endif
+
+    /** If the lighting values are too large, due to bright lights or extended radiance, they can clip using 10 bit textures.
+    * You can either adjust the irradiance scalar on the DDGI volume to help avoid clipping, or you can change this setting
+    * to use a 32 bit per color channel texture format.
+    */
+    UPROPERTY(config, EditAnywhere, Category=DDGI)
+    EDDGIIrradianceBits IrradianceBits = EDDGIIrradianceBits::n10;
+
+    /** Same story, but for probe distances and squared distances, used to prevent leaks.
+    */
+    UPROPERTY(config, EditAnywhere, Category=DDGI)
+    EDDGIDistanceBits DistanceBits = EDDGIDistanceBits::n16;
+
+    /** The radius of the spheres that visualize the ddgi probes */
+    UPROPERTY(config, EditAnywhere, Category=DDGI)
+    float DebugProbeRadius = 5.0f;
+
+    /** The number of rays per frame DDGI is allowed to use to update volumes at max. One volume is updated per frame
+    * in a weighted round robin fashion, based on each volume's update priority. It will use this many rays maximum
+    * when updating a volume.  A budget value of 0 means there is no budget, and all probes will be updated each time.
+    * A default volume has 8x8x8 probes, and uses 288 rays per probe for updates. That means it takes 147,456 rays
+    * to update all probes. If you set the budget to 50,000 rays, it would take 3 frames to update all the probes which
+    * means the probes will be less responsive to lighting changes, but will take less processing time each frame to update.
+    */
+    UPROPERTY(config, EditAnywhere, Category = DDGI, meta = (ClampMin = "0"))
+    int ProbeUpdateRayBudget = 0;
+};
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Public/DDGIBlueprintLibrary.h b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Public/DDGIBlueprintLibrary.h
new file mode 100644
index 00000000000..458bcffe772
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Public/DDGIBlueprintLibrary.h
@@ -0,0 +1,33 @@
+/*
+* Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "UObject/ObjectMacros.h"
+#include "Kismet/BlueprintFunctionLibrary.h"
+
+#include "DDGIBlueprintLibrary.generated.h"
+
+UCLASS(MinimalAPI, meta = (ScriptName = "DDGILibrary"))
+class UDDGIBlueprintLibrary : public UBlueprintFunctionLibrary
+{
+    GENERATED_UCLASS_BODY()
+
+    UFUNCTION(BlueprintCallable, Category = "DDGI")
+    static void ClearProbeData(const UDDGIVolumeComponent* DDGIVolumeComponent);
+
+    UFUNCTION(BlueprintCallable, Category = "DDGI")
+    static void DisableVolume(UDDGIVolumeComponent* DDGIVolumeComponent);
+
+    UFUNCTION(BlueprintCallable, Category = "DDGI")
+    static void EnableVolume(UDDGIVolumeComponent* DDGIVolumeComponent);
+
+};
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Public/DDGIVolume.h b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Public/DDGIVolume.h
new file mode 100644
index 00000000000..0837b3a215d
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Public/DDGIVolume.h
@@ -0,0 +1,43 @@
+/*
+* Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+#pragma once
+
+#include "CoreMinimal.h"
+#include "Engine/StaticMeshActor.h"
+#include "GameFramework/Actor.h"
+
+#include "DDGIVolume.generated.h"
+
+class UBillboardComponent;
+class UBoxComponent;
+class UDDGIVolumeComponent;
+
+UCLASS(HideCategories = (Navigation, Physics, Collision, Rendering, Tags, Cooking, Replication, Input, Actor, HLOD, Mobile, LOD))
+class RTXGI_API ADDGIVolume : public AActor
+{
+    GENERATED_UCLASS_BODY()
+
+public:
+    UPROPERTY(EditAnywhere, Category = "GI");
+    UDDGIVolumeComponent* DDGIVolumeComponent;
+
+#if WITH_EDITORONLY_DATA
+    UPROPERTY();
+    UBoxComponent* BoxComponent;
+
+    UPROPERTY()
+    UBillboardComponent* SpriteComponent;
+#endif // WITH_EDITORONLY_DATA
+
+#if WITH_EDITOR
+    void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent) override final;
+    void PostEditMove(bool bFinished) override final;
+#endif
+};
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Public/DDGIVolumeComponent.h b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Public/DDGIVolumeComponent.h
new file mode 100644
index 00000000000..465eb86809a
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Public/DDGIVolumeComponent.h
@@ -0,0 +1,376 @@
+/*
+* Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#pragma once
+
+// UE4 public interfaces
+#include "CoreMinimal.h"
+#include "UObject/ObjectMacros.h"
+#include "Engine/EngineTypes.h"
+#include "Components/SceneComponent.h"
+#include "RHI.h"
+#include "RHIResources.h"
+
+#include "DDGIVolumeComponent.generated.h"
+
+class FRDGBuilder;
+class FRHICommandListImmediate;
+class FScene;
+class FSceneInterface;
+class FSceneRenderTargets;
+class FViewInfo;
+class FGlobalIlluminationExperimentalPluginResources;
+
+enum class EDDGIIrradianceBits : uint8;
+enum class EDDGIDistanceBits : uint8;
+
+// This needs to match the shader code in ProbeBlendingCS.usf
+UENUM()
+enum class EDDGIRaysPerProbe : uint8
+{
+    n144 UMETA(DisplayName = "144"),
+    n288 UMETA(DisplayName = "288"),
+    n432 UMETA(DisplayName = "432"),
+    n576 UMETA(DisplayName = "576"),
+    n720 UMETA(DisplayName = "720"),
+    n864 UMETA(DisplayName = "864"),
+    n1008 UMETA(DisplayName = "1008"),
+
+    Count UMETA(Hidden)
+};
+
+struct FDDGITexturePixels
+{
+    uint32 w = 0;
+    uint32 h = 0;
+    uint32 stride = 0;
+    uint32 pixelFormat = 0;
+    TArray<uint8> pixels;
+    FTexture2DRHIRef texture;
+};
+
+struct FDDGITextureLoadContext
+{
+    bool ReadyForLoad = false;
+    FDDGITexturePixels Irradiance;
+    FDDGITexturePixels Distance;
+    FDDGITexturePixels Offsets;
+    FDDGITexturePixels States;
+
+    void Clear()
+    {
+        *this = FDDGITextureLoadContext();
+    }
+};
+
+class RTXGI_API FDDGIVolumeSceneProxy
+{
+public:
+
+    /** Initialization constructor. */
+    FDDGIVolumeSceneProxy(FSceneInterface* InOwningScene)
+        : OwningScene(InOwningScene)
+    {
+    }
+
+    virtual ~FDDGIVolumeSceneProxy()
+    {
+        check(IsInRenderingThread() || IsInParallelRenderingThread());
+        AllProxiesReadyForRender_RenderThread.Remove(this);
+    }
+
+    bool IntersectsViewFrustum(const FViewInfo& View);
+
+    static void RenderDiffuseIndirectLight_RenderThread(
+        const FScene& Scene,
+        const FViewInfo& View,
+        FRDGBuilder& GraphBuilder,
+        FGlobalIlluminationExperimentalPluginResources& Resources);
+
+    static void RenderDiffuseIndirectVisualizations_RenderThread(
+        const FScene& Scene,
+        const FViewInfo& View,
+        FRDGBuilder& GraphBuilder,
+        FGlobalIlluminationExperimentalPluginResources& Resources);
+
+    void ReallocateSurfaces_RenderThread(FRHICommandListImmediate& RHICmdList, EDDGIIrradianceBits IrradianceBits, EDDGIDistanceBits DistanceBits);
+    void ResetTextures_RenderThread(FRHICommandListImmediate& RHICmdList);
+
+    static void OnIrradianceOrDistanceBitsChange();
+
+    static FDelegateHandle RenderDiffuseIndirectLightHandle;
+    static FDelegateHandle RenderDiffuseIndirectVisualizationsHandle;
+
+    // data from the component
+    struct FComponentData
+    {
+        // A shared location cpp side for operational defines
+        static const bool c_RTXGI_DDGI_PROBE_STATE_CLASSIFIER = true;
+
+        // It considers this many volumes that pass frustum culling when sampling GI for the scene.
+        static const int c_RTXGI_DDGI_MAX_SHADING_VOLUMES = 6;
+
+        static const EPixelFormat c_pixelFormatRadianceLowBitDepth = EPixelFormat::PF_G32R32F;
+        static const EPixelFormat c_pixelFormatRadianceHighBitDepth = EPixelFormat::PF_A32B32G32R32F;
+        static const EPixelFormat c_pixelFormatIrradianceLowBitDepth = EPixelFormat::PF_A2B10G10R10;
+        static const EPixelFormat c_pixelFormatIrradianceHighBitDepth = EPixelFormat::PF_A32B32G32R32F;
+        static const EPixelFormat c_pixelFormatDistanceHighBitDepth = EPixelFormat::PF_G32R32F;
+        static const EPixelFormat c_pixelFormatDistanceLowBitDepth = EPixelFormat::PF_G16R16F;
+        static const EPixelFormat c_pixelFormatOffsets = EPixelFormat::PF_A16B16G16R16;
+        static const EPixelFormat c_pixelFormatStates = EPixelFormat::PF_R8_UINT;
+
+        // ProbeBlendingCS (.hlsl in SDK, .usf in plugin) needs this as a define so is a hard coded constant right now.
+        // We need that shader to not require that as a define. Then, we can make it a tuneable parameter on the volume.
+        // There should be a task on the SDK about this.
+        static const uint32 c_NumTexelsIrradiance = 6;
+        static const uint32 c_NumTexelsDistance = 14;
+
+        uint32 GetNumRaysPerProbe() const
+        {
+            switch (RaysPerProbe)
+            {
+                case EDDGIRaysPerProbe::n144: return 144;
+                case EDDGIRaysPerProbe::n288: return 288;
+                case EDDGIRaysPerProbe::n432: return 432;
+                case EDDGIRaysPerProbe::n576: return 576;
+                case EDDGIRaysPerProbe::n720: return 720;
+                case EDDGIRaysPerProbe::n864: return 864;
+                case EDDGIRaysPerProbe::n1008: return 1008;
+            }
+            check(false);
+            return 144;
+        }
+
+        EDDGIRaysPerProbe RaysPerProbe = EDDGIRaysPerProbe::n144;
+        float ProbeMaxRayDistance = 1000.0f;
+        FTransform Transform = FTransform::Identity;
+        FVector Origin = FVector(0);
+        FLightingChannels LightingChannels;
+        FIntVector ProbeCounts = FIntVector(0); // 0 = invalid, will be written with valid counts before use
+        float ProbeDistanceExponent = 1.0f;
+        float ProbeIrradianceEncodingGamma = 1.0f;
+        int   LightingPriority = 0;
+        float UpdatePriority = 1.0f;
+        float ProbeHysteresis = 0.0f;
+        float ProbeChangeThreshold = 0.0f;
+        float ProbeBrightnessThreshold = 0.0f;
+        float NormalBias = 0.0f;
+        float ViewBias = 0.0f;
+        float BlendDistance = 0.0f;
+        float BlendDistanceBlack = 0.0f;
+        float ProbeBackfaceThreshold = 0.0f;
+        float ProbeMinFrontfaceDistance = 0.0f;
+        bool EnableProbeRelocation = false;
+        bool EnableProbeScrolling = false;
+        bool EnableVolume = true;
+        FIntVector ProbeScrollOffsets = FIntVector{ 0, 0, 0 };
+        float IrradianceScalar = 1.0f;
+        float EmissiveMultiplier = 1.0f;
+        float LightingMultiplier = 1.0f;
+        bool RuntimeStatic = false; // If true, does not update during gameplay, only during editor.
+        bool SkyLight = true;
+
+        // This is GetDDGIVolumeProbeCounts() from the SDK
+        FIntPoint Get2DProbeCount() const
+        {
+            return FIntPoint(
+                ProbeCounts.Y * ProbeCounts.Z,
+                ProbeCounts.X
+            );
+        }
+
+        int GetProbeCount() const
+        {
+            return ProbeCounts.X * ProbeCounts.Y * ProbeCounts.Z;
+        }
+    };
+    FComponentData ComponentData;
+    FDDGITextureLoadContext TextureLoadContext;
+
+    FTexture2DRHIRef ProbesIrradianceTex;
+    FTexture2DRHIRef ProbesDistanceTex;
+    FTexture2DRHIRef ProbesOffsetsTex;
+    FTexture2DRHIRef ProbesStatesTex;
+
+    FUnorderedAccessViewRHIRef ProbesIrradianceUAV;
+    FUnorderedAccessViewRHIRef ProbesDistanceUAV;
+    FUnorderedAccessViewRHIRef ProbesOffsetsUAV;
+    FUnorderedAccessViewRHIRef ProbesStatesUAV;
+
+    // Where to start the probe update from, for updating a subset of probes
+    int ProbeIndexStart = 0;
+    int ProbeIndexCount = 0;
+
+    static TSet<FDDGIVolumeSceneProxy*> AllProxiesReadyForRender_RenderThread;
+    static TMap<const FSceneInterface*, float> SceneRoundRobinValue;
+
+    // Only render volumes in the scenes they are present in
+    FSceneInterface* OwningScene;
+};
+
+UCLASS(HideCategories = (Tags, AssetUserData, Collision, Cooking, Transform, Rendering, Mobility, LOD))
+class RTXGI_API UDDGIVolumeComponent : public USceneComponent, public FSelfRegisteringExec
+{
+    GENERATED_UCLASS_BODY()
+
+protected:
+
+    void InitializeComponent() override final;
+
+    void Serialize(FArchive& Ar) override final;
+
+    //~ Begin UActorComponent Interface
+    virtual bool ShouldCreateRenderState() const override { return true; }
+    virtual void CreateRenderState_Concurrent(FRegisterComponentContext* Context) override;
+    virtual void DestroyRenderState_Concurrent() override;
+    //~ Begin UActorComponent Interface
+
+public:
+    void UpdateRenderThreadData();
+    void EnableVolumeComponent(bool enabled);
+
+    static void Startup();
+    static void Shutdown();
+
+    /**
+     * FExec interface
+     */
+    virtual bool Exec(UWorld* InWorld, const TCHAR* Cmd, FOutputDevice& Ar) override;
+
+    // Clears the probe textures on all volumes
+    UFUNCTION(exec)
+    void DDGIClearVolumes();
+
+public:
+
+    // Number of rays shot for each probe when updating probe data.
+    UPROPERTY(EditAnywhere, Category = "GI");
+    EDDGIRaysPerProbe RaysPerProbe = EDDGIRaysPerProbe::n288;
+
+    // Number of probes on each axis.
+    UPROPERTY(EditAnywhere, Category = "GI", meta = (ClampMin = "1"));
+    FIntVector ProbeCounts = FIntVector(8, 8, 8);
+
+    // A priority value used to select volumes when applying lighting. The volume with the lowest priority value is selected.
+    // If volumes have the same priority, then volumes are selected based on probe density. The highest density volume is selected.
+    UPROPERTY(EditAnywhere, Category = "GI", meta = (ClampMin = "0", ClampMax = "10"));
+    int32 LightingPriority = 0;
+
+    // A priority value for scheduling updates to this volume's probes. Volumes with higher priority values get updated more often. Weighted round robin updating.
+    UPROPERTY(EditAnywhere, Category = "GI", meta = (ClampMin = "0.0001", ClampMax = "100.0"));
+    float UpdatePriority = 1.0f;
+
+    // Maximum distance a probe ray may travel. Shortening this can increase performance. If you shorten it too much, it can miss geometry.
+    UPROPERTY(EditAnywhere, Category = "GI", meta = (ClampMin = "0"));
+    float ProbeMaxRayDistance = 100000.0f;
+
+    // Controls the influence of new rays when updating each probe. Values towards 1 will keep history longer, while values towards 0 will be more responsive to current values.
+    UPROPERTY(EditAnywhere, Category = "GI", meta = (ClampMin = "0", ClampMax = "1"));
+    float ProbeHysteresis = 0.97f;
+
+    // Bias values for Indirect Lighting
+    UPROPERTY(EditAnywhere, Category = "GI", meta = (ClampMin = "0"));
+    float ViewBias = 40.0f;
+
+    // Bias values for Indirect Lighting
+    UPROPERTY(EditAnywhere, Category = "GI", meta = (ClampMin = "0"));
+    float NormalBias = 10.0f;
+
+    // Objects with overlapping channel flags will receive lighting from this volume
+    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "GI")
+    FLightingChannels LightingChannels;
+
+    // The distance in world units that this volume blends to a volume it overlaps, or fades out.
+    UPROPERTY(EditAnywhere, Category = "GI");
+    float VolumeBlendDistance = 20.0f;
+
+    // The distance from the edge of a volume at which it has zero weighting (turns black or yields to an encompassing volume). Useful if you don't want a linear fade all the way to the edge, which can be useful for scrolling volumes, hiding probes that haven't converged yet.
+    // Volume Blend Distance begins at this distance from the edge.
+    UPROPERTY(EditAnywhere, Category = "GI");
+    float VolumeBlendDistanceBlack = 0.0f;
+
+    // If true, probes will attempt to relocate within their cell to leave geometry.
+    UPROPERTY(EditAnywhere, Category = "GI");
+    bool EnableProbeRelocation = true;
+
+    // If true, probes will keep their same position in world space as the volume moves around. Useful for moving volumes to have more temporally stable probes.
+    UPROPERTY(EditAnywhere, Category = "GI");
+    bool EnableProbeScrolling = false;
+
+    // If true, the volume will be a candidate to be updated and render indirect light into the scene (if also in the view frustum).
+    UPROPERTY(EditAnywhere, Category = "GI");
+    bool EnableVolume = true;
+
+    // If true, the volume will not update at runtime, and will keep the lighting values seen during edit.
+    UPROPERTY(EditAnywhere, Category = "GI");
+    bool RuntimeStatic = false;
+
+
+
+
+    // --- "Advanced" properties below aka things people shouldn't have to touch
+
+    // Exponent for depth testing. A high value will rapidly react to depth discontinuities, but risks causing banding.
+    UPROPERTY(EditAnywhere, AdvancedDisplay, Category = "GI Advanced");
+    float probeDistanceExponent = 50.f;
+
+    // Irradiance blending happens in post-tonemap space
+    UPROPERTY(EditAnywhere, AdvancedDisplay, Category = "GI Advanced");
+    float probeIrradianceEncodingGamma = 5.f;
+
+    // A threshold ratio used during probe radiance blending that determines if a large lighting change has happened.
+    // If the max color component difference is larger than this threshold, the hysteresis will be reduced.
+    UPROPERTY(EditAnywhere, AdvancedDisplay, Category = "GI Advanced");
+    float probeChangeThreshold = 0.2f;
+
+    // A threshold value used during probe radiance blending that determines the maximum allowed difference in brightness
+    // between the previous and current irradiance values. This prevents impulses from drastically changing a
+    // texel's irradiance in a single update cycle.
+    UPROPERTY(EditAnywhere, AdvancedDisplay, Category = "GI Advanced");
+    float probeBrightnessThreshold = 2.0f;
+
+    // Probe relocation moves probes that see front facing triangles closer than this value
+    UPROPERTY(EditAnywhere, AdvancedDisplay, Category = "GI Advanced", meta = (ClampMin = "0"));
+    float ProbeMinFrontfaceDistance = 10.0f;
+
+    // Probe relocation and state classifier assume probes with more than this ratio of backface hits are inside of geometry.
+    UPROPERTY(EditAnywhere, AdvancedDisplay, Category = "GI Advanced", meta = (ClampMin = "0", ClampMax = "1"));
+    float ProbeBackfaceThreshold = 0.25f;
+
+    // If you want to artificially increase the amount of lighting given by this volume, you can modify this lighting multiplier to do so.
+    UPROPERTY(EditAnywhere, AdvancedDisplay, Category = "GI Advanced", meta = (ClampMin = "0"));
+    float LightMultiplier = 1.0f;
+
+    // Use this to artificially modify how much emissive lighting contributes to GI
+    UPROPERTY(EditAnywhere, AdvancedDisplay, Category = "GI Advanced", meta = (ClampMin = "0"));
+    float EmissiveMultiplier = 1.0f;
+
+    // The probe irradiance is multiplied by this value when stored, to keep from being too large to be stored in the irradiance texture format.
+    // If your irradiance clips (it will be too dim), use this number to help prevent clipping, or change the project settings for the plugin to
+    // use the 32 bit floating point irradiance texture format.
+    UPROPERTY(EditAnywhere, AdvancedDisplay, Category = "GI Advanced", meta = (ClampMin = "0.001", ClampMax = "1"));
+    float IrradianceScalar = 1.0f;
+
+    // If true, non raytraced skylight contributes to GI
+    UPROPERTY(EditAnywhere, Category = "GI");
+    bool SkyLight = true;
+
+    UPROPERTY(VisibleAnywhere, AdvancedDisplay, Category = "GI Advanced");
+    FVector LastOrigin = FVector{ 0.0f, 0.0f, 0.0f };
+
+    UPROPERTY(VisibleAnywhere, AdvancedDisplay, Category = "GI Advanced");
+    FIntVector ProbeScrollOffset = FIntVector{ 0, 0, 0 };
+
+    FDDGIVolumeSceneProxy* SceneProxy;
+
+    // When loading a volume we get data for it's textures but don't have a scene proxy yet.
+    // This is where that data is stored until the scene proxy is ready to take it.
+    FDDGITextureLoadContext LoadContext;
+};
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Public/RTXGIPlugin.h b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Public/RTXGIPlugin.h
new file mode 100644
index 00000000000..0b0b8e6ea68
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/Public/RTXGIPlugin.h
@@ -0,0 +1,37 @@
+/*
+* Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "Modules/ModuleManager.h"
+#include "Features/IModularFeatures.h"
+#include "Modules/ModuleInterface.h"
+
+/**
+* The public interface of the IRTXGIPlugin
+*/
+class FRTXGIPlugin : public IModuleInterface, public IModularFeature
+{
+public:
+    static FString GetModularFeatureName()
+    {
+        static FString FeatureName = FString(TEXT("RTXGI"));
+        return FeatureName;
+    }
+
+    /** IModuleInterface implementation */
+    virtual void StartupModule() override;
+    virtual void ShutdownModule() override;
+
+private:
+    void StartupDDGI();
+    void ShutdownDDGI();
+};
diff --git a/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI.Build.cs b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI.Build.cs
new file mode 100644
index 00000000000..81938faedd3
--- /dev/null
+++ b/Engine/Plugins/Runtime/Nvidia/RTXGI/Source/RTXGI.Build.cs
@@ -0,0 +1,51 @@
+/*
+* Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
+*
+* NVIDIA CORPORATION and its licensors retain all intellectual property
+* and proprietary rights in and to this software, related documentation
+* and any modifications thereto.  Any use, reproduction, disclosure or
+* distribution of this software and related documentation without an express
+* license agreement from NVIDIA CORPORATION is strictly prohibited.
+*/
+
+using UnrealBuildTool;
+using System.IO;
+
+public class RTXGI : ModuleRules
+{
+    private string ModulePath
+    {
+        get { return ModuleDirectory; }
+    }
+
+    public RTXGI(ReadOnlyTargetRules Target) : base(Target)
+    {
+        PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;
+
+        PrivateDependencyModuleNames.AddRange(new string[]
+        {
+            "CoreUObject",
+            "Engine",
+            "RenderCore",
+            "Renderer",
+            "DeveloperSettings",
+            "RHI",
+        });
+
+        PrivateIncludePaths.AddRange(new string[]
+        {
+            "../../../../../Source/Runtime/Renderer/Private",
+        });
+
+        PublicDependencyModuleNames.AddRange(new string[]
+        {
+            "Core",
+            "Projects"
+        });
+
+        PublicIncludePaths.AddRange(new string[]
+        {
+            "../Shaders/Shared"
+        });
+    }
+}
diff --git a/Engine/Source/Runtime/Renderer/Private/DeferredShadingRenderer.cpp b/Engine/Source/Runtime/Renderer/Private/DeferredShadingRenderer.cpp
index 2d8f20cacc6..e81052d2d97 100644
--- a/Engine/Source/Runtime/Renderer/Private/DeferredShadingRenderer.cpp
+++ b/Engine/Source/Runtime/Renderer/Private/DeferredShadingRenderer.cpp
@@ -251,6 +251,37 @@ DECLARE_GPU_STAT(PostOpaqueExtensions);
 
 CSV_DEFINE_CATEGORY(LightCount, true);
 
+/*-----------------------------------------------------------------------------
+	Global Illumination Plugin Function Delegates (experimental)
+-----------------------------------------------------------------------------*/
+
+static FGlobalIlluminationExperimentalPluginDelegates::FAnyRayTracingPassEnabled GIExperimentalPluginAnyRaytracingPassEnabledDelegate;
+FGlobalIlluminationExperimentalPluginDelegates::FAnyRayTracingPassEnabled& FGlobalIlluminationExperimentalPluginDelegates::AnyRayTracingPassEnabled()
+{
+	return GIExperimentalPluginAnyRaytracingPassEnabledDelegate;
+}
+
+static FGlobalIlluminationExperimentalPluginDelegates::FPrepareRayTracing GIExperimentalPluginPrepareRayTracingDelegate;
+FGlobalIlluminationExperimentalPluginDelegates::FPrepareRayTracing& FGlobalIlluminationExperimentalPluginDelegates::PrepareRayTracing()
+{
+	return GIExperimentalPluginPrepareRayTracingDelegate;
+}
+
+static FGlobalIlluminationExperimentalPluginDelegates::FRenderDiffuseIndirectLight GIExperimentalPluginRenderDiffuseIndirectLightDelegate;
+FGlobalIlluminationExperimentalPluginDelegates::FRenderDiffuseIndirectLight& FGlobalIlluminationExperimentalPluginDelegates::RenderDiffuseIndirectLight()
+{
+	return GIExperimentalPluginRenderDiffuseIndirectLightDelegate;
+}
+
+#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+static FGlobalIlluminationExperimentalPluginDelegates::FRenderDiffuseIndirectVisualizations GIExperimentalPluginRenderDiffuseIndirectVisualizationsDelegate;
+FGlobalIlluminationExperimentalPluginDelegates::FRenderDiffuseIndirectVisualizations& FGlobalIlluminationExperimentalPluginDelegates::RenderDiffuseIndirectVisualizations()
+{
+	return GIExperimentalPluginRenderDiffuseIndirectVisualizationsDelegate;
+}
+#endif //!(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+
+
 const TCHAR* GetDepthPassReason(bool bDitheredLODTransitionsUseStencil, EShaderPlatform ShaderPlatform)
 {
 	if (IsForwardShadingEnabled(ShaderPlatform))
@@ -1090,6 +1121,7 @@ bool FDeferredShadingSceneRenderer::DispatchRayTracingWorldUpdates(FRHICommandLi
 		PrepareRayTracingAmbientOcclusion(View, RayGenShaders);
 		PrepareRayTracingSkyLight(View, RayGenShaders);
 		PrepareRayTracingGlobalIllumination(View, RayGenShaders);
+		PrepareRayTracingGlobalIlluminationPlugin(View, RayGenShaders);
 		PrepareRayTracingTranslucency(View, RayGenShaders);
 		PrepareRayTracingDebug(View, RayGenShaders);
 		PreparePathTracing(View, RayGenShaders);
@@ -2101,7 +2133,7 @@ void FDeferredShadingSceneRenderer::Render(FRHICommandListImmediate& RHICmdList)
 		SCOPE_CYCLE_COUNTER(STAT_FDeferredShadingSceneRenderer_Lighting);
 
 		FRDGTextureRef DynamicBentNormalAOTexture = nullptr;
-		RenderDiffuseIndirectAndAmbientOcclusion(GraphBuilder, SceneTextures, SceneColorTexture.Target, HairDatas);
+		RenderDiffuseIndirectAndAmbientOcclusion(GraphBuilder, SceneTextures, SceneColorTexture.Target, LightingChannelsTexture, HairDatas);
 
 		// These modulate the scenecolor output from the basepass, which is assumed to be indirect lighting
 		if (SceneContext.IsStaticLightingAllowed())
@@ -2179,6 +2211,11 @@ void FDeferredShadingSceneRenderer::Render(FRHICommandListImmediate& RHICmdList)
 		// Render diffuse sky lighting and reflections that only operate on opaque pixels
 		RenderDeferredReflectionsAndSkyLighting(GraphBuilder, SceneTextures, SceneColorTexture, DynamicBentNormalAOTexture, VelocityTexture, HairDatas);
 
+#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+		// Renders debug visualizations for global illumination plugins (experimental)
+		RenderGlobalIlluminationExperimentalPluginVisualizations(GraphBuilder, LightingChannelsTexture);
+#endif
+
 		SceneColorTexture = FRDGTextureMSAA(AddSubsurfacePass(GraphBuilder, SceneTextures, Views, SceneColorTexture.Target));
 
 		if (HairDatas)
@@ -2721,9 +2758,9 @@ bool AnyRayTracingPassEnabled(const FScene* Scene, const FViewInfo& View)
 		|| ShouldRenderRayTracingTranslucency(View)
 		|| ShouldRenderRayTracingSkyLight(Scene ? Scene->SkyLight : nullptr)
 		|| ShouldRenderRayTracingShadows()
+		|| ShouldRenderExperimentalPluginRayTracingGlobalIllumination()
 		|| View.RayTracingRenderMode == ERayTracingRenderMode::PathTracing
-		|| View.RayTracingRenderMode == ERayTracingRenderMode::RayTracingDebug
-		)
+		|| View.RayTracingRenderMode == ERayTracingRenderMode::RayTracingDebug)
 	{
 		return true;
 	}
diff --git a/Engine/Source/Runtime/Renderer/Private/DeferredShadingRenderer.h b/Engine/Source/Runtime/Renderer/Private/DeferredShadingRenderer.h
index f1a44efc711..e206f17e321 100644
--- a/Engine/Source/Runtime/Renderer/Private/DeferredShadingRenderer.h
+++ b/Engine/Source/Runtime/Renderer/Private/DeferredShadingRenderer.h
@@ -32,6 +32,41 @@ struct FRayTracingReflectionOptions;
 struct FHairStrandsTransmittanceMaskData;
 struct FHairStrandsRenderingData;
 
+/**
+ * Encapsulates the resources and render targets used by global illumination plugins (experimental).
+ */
+class RENDERER_API FGlobalIlluminationExperimentalPluginResources : public FRenderResource
+{
+public:
+	TRefCountPtr<IPooledRenderTarget> GBufferA;
+	TRefCountPtr<IPooledRenderTarget> GBufferB;
+	TRefCountPtr<IPooledRenderTarget> GBufferC;
+	TRefCountPtr<IPooledRenderTarget> SceneDepthZ;
+	TRefCountPtr<IPooledRenderTarget> SceneColor;
+	FRDGTextureRef LightingChannelsTexture;
+};
+
+/**
+ * Delegate callback used by global illumination plugins (experimental).
+ */
+class RENDERER_API FGlobalIlluminationExperimentalPluginDelegates
+{
+public:
+	DECLARE_MULTICAST_DELEGATE_OneParam(FAnyRayTracingPassEnabled, bool& /*bAnyRayTracingPassEnabled*/);
+	DECLARE_MULTICAST_DELEGATE_TwoParams(FPrepareRayTracing, const FViewInfo& /*View*/, TArray<FRHIRayTracingShader*>& /*OutRayGenShaders*/);
+	DECLARE_MULTICAST_DELEGATE_FourParams(FRenderDiffuseIndirectLight, const FScene& /*Scene*/, const FViewInfo& /*View*/, FRDGBuilder& /*GraphBuilder*/, FGlobalIlluminationExperimentalPluginResources& /*Resources*/);
+
+	static FAnyRayTracingPassEnabled& AnyRayTracingPassEnabled();
+	static FPrepareRayTracing& PrepareRayTracing();
+	static FRenderDiffuseIndirectLight& RenderDiffuseIndirectLight();
+
+#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+	DECLARE_MULTICAST_DELEGATE_FourParams(FRenderDiffuseIndirectVisualizations, const FScene& /*Scene*/, const FViewInfo& /*View*/, FRDGBuilder& /*GraphBuilder*/, FGlobalIlluminationExperimentalPluginResources& /*Resources*/);
+	static FRenderDiffuseIndirectVisualizations& RenderDiffuseIndirectVisualizations();
+#endif //!(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+};
+
+
 /**
  * Scene renderer that implements a deferred shading pipeline and associated features.
  */
@@ -221,6 +256,7 @@ private:
 		FRDGBuilder& GraphBuilder,
 		TRDGUniformBufferRef<FSceneTextureUniformParameters> SceneTexturesUniformBuffer,
 		FRDGTextureRef SceneColorTexture,
+		FRDGTextureRef LightingChannelsTexture,
 		FHairStrandsRenderingData* HairDatas);
 
 	/** Renders sky lighting and reflections that can be done in a deferred pass. */
@@ -234,6 +270,11 @@ private:
 
 	void RenderDeferredReflectionsAndSkyLightingHair(FRDGBuilder& GraphBuilder, struct FHairStrandsRenderingData* HairDatas);
 
+#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+	/** Renders debug visualizations for global illumination plugins (experimental). */
+	void RenderGlobalIlluminationExperimentalPluginVisualizations(FRDGBuilder& GraphBuilder, FRDGTextureRef LightingChannelsTexture);
+#endif
+
 	/** Computes DFAO, modulates it to scene color (which is assumed to contain diffuse indirect lighting), and stores the output bent normal for use occluding specular. */
 	void RenderDFAOAsIndirectShadowing(
 		FRDGBuilder& GraphBuilder,
@@ -786,6 +827,7 @@ private:
 	static void PrepareRayTracingAmbientOcclusion(const FViewInfo& View, TArray<FRHIRayTracingShader*>& OutRayGenShaders);
 	static void PrepareRayTracingSkyLight(const FViewInfo& View, TArray<FRHIRayTracingShader*>& OutRayGenShaders);
 	static void PrepareRayTracingGlobalIllumination(const FViewInfo& View, TArray<FRHIRayTracingShader*>& OutRayGenShaders);
+	static void PrepareRayTracingGlobalIlluminationPlugin(const FViewInfo& View, TArray<FRHIRayTracingShader*>& OutRayGenShaders);
 	static void PrepareRayTracingTranslucency(const FViewInfo& View, TArray<FRHIRayTracingShader*>& OutRayGenShaders);
 	static void PrepareRayTracingDebug(const FViewInfo& View, TArray<FRHIRayTracingShader*>& OutRayGenShaders);
 	static void PreparePathTracing(const FViewInfo& View, TArray<FRHIRayTracingShader*>& OutRayGenShaders);
diff --git a/Engine/Source/Runtime/Renderer/Private/IndirectLightRendering.cpp b/Engine/Source/Runtime/Renderer/Private/IndirectLightRendering.cpp
index 038e9ad7048..fafcab5327b 100644
--- a/Engine/Source/Runtime/Renderer/Private/IndirectLightRendering.cpp
+++ b/Engine/Source/Runtime/Renderer/Private/IndirectLightRendering.cpp
@@ -17,6 +17,11 @@
 #include "DistanceFieldAmbientOcclusion.h"
 #include "VolumetricCloudRendering.h"
 
+static TAutoConsoleVariable<bool> CVarGlobalIlluminationExperimentalPluginEnable(
+	TEXT("r.GlobalIllumination.ExperimentalPlugin"),
+	false,
+	TEXT("Whether to use a plugin for global illumination (experimental) (default = false)"),
+	ECVF_RenderThreadSafe);
 
 static TAutoConsoleVariable<int32> CVarDiffuseIndirectDenoiser(
 	TEXT("r.DiffuseIndirect.Denoiser"), 1,
@@ -338,10 +343,37 @@ bool FDeferredShadingSceneRenderer::ShouldDoReflectionEnvironment() const
 		&& ViewFamily.EngineShowFlags.ReflectionEnvironment;
 }
 
+
+#if RHI_RAYTRACING
+
+bool ShouldRenderExperimentalPluginRayTracingGlobalIllumination()
+{
+	if (!CVarGlobalIlluminationExperimentalPluginEnable.GetValueOnRenderThread())
+	{
+		return false;
+	}
+
+	bool bAnyRayTracingPassEnabled = false;
+	FGlobalIlluminationExperimentalPluginDelegates::FAnyRayTracingPassEnabled& Delegate = FGlobalIlluminationExperimentalPluginDelegates::AnyRayTracingPassEnabled();
+	Delegate.Broadcast(bAnyRayTracingPassEnabled);
+
+	return ShouldRenderRayTracingEffect(bAnyRayTracingPassEnabled);
+}
+
+void FDeferredShadingSceneRenderer::PrepareRayTracingGlobalIlluminationPlugin(const FViewInfo& View, TArray<FRHIRayTracingShader*>& OutRayGenShaders)
+{
+	// Call the GI plugin delegate function to prepare ray tracing
+	FGlobalIlluminationExperimentalPluginDelegates::FPrepareRayTracing& Delegate = FGlobalIlluminationExperimentalPluginDelegates::PrepareRayTracing();
+	Delegate.Broadcast(View, OutRayGenShaders);
+}
+
+#endif
+
 void FDeferredShadingSceneRenderer::RenderDiffuseIndirectAndAmbientOcclusion(
 	FRDGBuilder& GraphBuilder,
 	TRDGUniformBufferRef<FSceneTextureUniformParameters> SceneTexturesUniformBuffer,
 	FRDGTextureRef SceneColorTexture,
+	FRDGTextureRef LightingChannelsTexture,
 	FHairStrandsRenderingData* InHairDatas)
 {
 	RDG_EVENT_SCOPE(GraphBuilder, "DiffuseIndirectAndAO");
@@ -362,6 +394,7 @@ void FDeferredShadingSceneRenderer::RenderDiffuseIndirectAndAmbientOcclusion(
 
 		// TODO: enum cvar. 
 		const bool bApplyRTGI = ShouldRenderRayTracingGlobalIllumination(View);
+		const bool bApplyPluginGI = CVarGlobalIlluminationExperimentalPluginEnable.GetValueOnRenderThread();
 		const bool bApplySSGI = ShouldRenderScreenSpaceDiffuseIndirect(View);
 		const bool bApplySSAO = SceneContext.bScreenSpaceAOIsValid;
 		const bool bApplyRTAO = ShouldRenderRayTracingAmbientOcclusion(View) && Views.Num() == 1; //#dxr_todo: enable RTAO in multiview mode
@@ -436,6 +469,22 @@ void FDeferredShadingSceneRenderer::RenderDiffuseIndirectAndAmbientOcclusion(
 			DenoiserOutputs.AmbientOcclusionMask = DenoiserInputs.AmbientOcclusionMask;
 		}
 
+		// Render GI from a plugin
+		if (bApplyPluginGI && !bApplyRTGI)
+		{
+			// Get the resources and call the GI plugin's rendering function delegate
+			FGlobalIlluminationExperimentalPluginResources GIPluginResources;
+			GIPluginResources.GBufferA = SceneContext.GBufferA;
+			GIPluginResources.GBufferB = SceneContext.GBufferB;
+			GIPluginResources.GBufferC = SceneContext.GBufferC;
+			GIPluginResources.LightingChannelsTexture = LightingChannelsTexture;
+			GIPluginResources.SceneDepthZ = SceneContext.SceneDepthZ;
+			GIPluginResources.SceneColor = SceneContext.GetSceneColor();
+
+			FGlobalIlluminationExperimentalPluginDelegates::FRenderDiffuseIndirectLight& Delegate = FGlobalIlluminationExperimentalPluginDelegates::RenderDiffuseIndirectLight();
+			Delegate.Broadcast(*Scene, View, GraphBuilder, GIPluginResources);
+		}
+
 		// Render RTAO that override any technic.
 		if (bApplyRTAO)
 		{
@@ -1001,3 +1050,31 @@ void FDeferredShadingSceneRenderer::RenderDeferredReflectionsAndSkyLightingHair(
 		}
 	}
 }
+
+#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
+void FDeferredShadingSceneRenderer::RenderGlobalIlluminationExperimentalPluginVisualizations(
+	FRDGBuilder& GraphBuilder,
+	FRDGTextureRef LightingChannelsTexture)
+{
+	// Early out if GI plugins aren't enabled
+	if (!CVarGlobalIlluminationExperimentalPluginEnable.GetValueOnRenderThread()) return;
+
+	FSceneRenderTargets& SceneContext = FSceneRenderTargets::Get(GraphBuilder.RHICmdList);
+
+	// Get the resources passed to GI plugins
+	FGlobalIlluminationExperimentalPluginResources GIPluginResources;
+	GIPluginResources.GBufferA = SceneContext.GBufferA;
+	GIPluginResources.GBufferB = SceneContext.GBufferB;
+	GIPluginResources.GBufferC = SceneContext.GBufferC;
+	GIPluginResources.LightingChannelsTexture = LightingChannelsTexture;
+	GIPluginResources.SceneDepthZ = SceneContext.SceneDepthZ;
+	GIPluginResources.SceneColor = SceneContext.GetSceneColor();
+
+	// Render visualizations to all views by calling the GI plugin's delegate
+	FGlobalIlluminationExperimentalPluginDelegates::FRenderDiffuseIndirectVisualizations& PRVDelegate = FGlobalIlluminationExperimentalPluginDelegates::RenderDiffuseIndirectVisualizations();
+	for (int32 ViewIndexZ = 0; ViewIndexZ < Views.Num(); ViewIndexZ++)
+	{
+		PRVDelegate.Broadcast(*Scene, Views[ViewIndexZ], GraphBuilder, GIPluginResources);
+	}
+}
+#endif //!(UE_BUILD_SHIPPING || UE_BUILD_TEST)
diff --git a/Engine/Source/Runtime/Renderer/Private/RayTracing/RayTracingLighting.h b/Engine/Source/Runtime/Renderer/Private/RayTracing/RayTracingLighting.h
index 269674c22c2..c75888a721c 100644
--- a/Engine/Source/Runtime/Renderer/Private/RayTracing/RayTracingLighting.h
+++ b/Engine/Source/Runtime/Renderer/Private/RayTracing/RayTracingLighting.h
@@ -12,7 +12,7 @@
 
 #if RHI_RAYTRACING
 
-BEGIN_GLOBAL_SHADER_PARAMETER_STRUCT(FRaytracingLightDataPacked, )
+BEGIN_GLOBAL_SHADER_PARAMETER_STRUCT(FRaytracingLightDataPacked, RENDERER_API)
 	SHADER_PARAMETER(uint32, Count)
 	SHADER_PARAMETER(float, IESLightProfileInvCount)
 	SHADER_PARAMETER(uint32, CellCount)
diff --git a/Engine/Source/Runtime/Renderer/Private/RayTracing/RaytracingOptions.h b/Engine/Source/Runtime/Renderer/Private/RayTracing/RaytracingOptions.h
index 09758038043..c14aaabb858 100644
--- a/Engine/Source/Runtime/Renderer/Private/RayTracing/RaytracingOptions.h
+++ b/Engine/Source/Runtime/Renderer/Private/RayTracing/RaytracingOptions.h
@@ -57,6 +57,7 @@ extern bool ShouldRenderRayTracingTranslucency(const FViewInfo& View);
 extern bool ShouldRenderRayTracingShadows();
 extern bool ShouldRenderRayTracingShadowsForLight(const FLightSceneProxy& LightProxy);
 extern bool ShouldRenderRayTracingShadowsForLight(const FLightSceneInfoCompact& LightInfo);
+extern bool ShouldRenderExperimentalPluginRayTracingGlobalIllumination();
 extern bool CanOverlayRayTracingOutput(const FViewInfo& View);
 
 extern bool EnableRayTracingShadowTwoSidedGeometry();
@@ -116,6 +117,11 @@ FORCEINLINE bool ShouldRenderRayTracingShadowsForLight(const FLightSceneInfoComp
 	return false;
 }
 
+FORCEINLINE bool ShouldRenderExperimentalPluginRayTracingGlobalIllumination()
+{
+	return false;
+}
+
 FORCEINLINE bool CanOverlayRayTracingOutput(const FViewInfo& View)
 {
 	return true;
